;***********************************************************************
;



;
















; NTLANMAN.INF
;
;       This is the Network Setup INF for NT/Lanman installation.
;
; Usage:
;         NORMAL:  This file is "shelled" from SETUP.INF during
;                  main installation.
;
; Warning:
;
;         This file is processed by that work of wonder, RCPP, into
;         three separate files:  NTLANMAN.INF, NTIDWNET.INF
;         and NTLMINST.INF. Because of this, some spurious errors are
;         occasionally emitted due
;         to the 'C' syntax knowledge of RCPP.  For this reason, some
;         comments dont use apostrophes and ellipses have been avoided.
;         Other errors, such as escaped quotes, are unavoidable.
;

;
; History:
;       davidhov  10-Mar-1992   Created
;
;








































;***********************************************************************
; CONSTANTS FOR USING DIALOGS
;***********************************************************************
[GeneralConstants]

Exit_Code = 0
BillboardVisible = 0
;
;  Return codes; Exit_Code is set to one of these
;
ExitCodeOk     = 0
ExitCodeCancel = 1
ExitCodeFatal  = 2
;
;  Program flow control variables.
;
retaddr   = ""
callresult = 0
from      = ""
to        = ""

;
;  Location of netcard product information
;
NetworkCardKeyName = $(!NTN_SoftwareBase)"\Microsoft\Windows NT\CurrentVersion\NetworkCards"
KeyNull            = ""
MAXIMUM_ALLOWED    = 33554432
SERVICE_NO_CHANGE  = 4294967295
KeyInfo            = {}
NoTitle            = 0
UtilityInf         = "UTILITY.INF"
NcParamInf         = "NCPARAM.INF"
RasAutoInstall     = 0
ComputerNameKeyName  = "SYSTEM\CurrentControlSet\Control\ComputerName"

[BaseGeneralConstants]

!STF_DOMAIN_ROLE  = STANDALONE
!STF_DOMAIN       = ""
!STF_SRCDIR_WINNT = ""

[DialogConstants]


















;
; Common button names, etc.
;
Help        = "&Help"
Exit        = "Cancel"
HelpContext = ""
Continue    = "Continue"
ExitState   = "Active"
Cancel      = "Cancel"
;
; Constants to support the use of radio button dialogs
;
Radio1  = "1"
Radio2  = "2"
Radio3  = "3"
Radio4  = "4"
Radio5  = "5"
Radio6  = "6"
Radio7  = "7"
Radio8  = "8"
Radio9  = "9"
;
; Constants to support the use of checkbox dialogs
;
;   DON'T TRANSLATE -- Internal use only
;
Chosen    = "ON"
NotChosen = "OFF"

NullFileName = "NOSUCH.FIL"






































































;***********************************************************************
; ERROR MESSAGE CONSTANTS-- Language-dependent
;***********************************************************************
[ErrorConstants]
;
;  Error handling variables
;
RegistryErrorList = ^(RegistryErrors$(!STF_LANGUAGE),1)
RegistryErrorIndex = 1

;------------------------------------------------------------------
; UI VARIABLES
; these variables are initialised with defaults, detected from the
; system configuration and/or queried from the user.  the variables
; are language independent.
;------------------------------------------------------------------

[UiVars]
DummyUnsedUiVar = ""

;**************************************************************************
;  Network UI Variables
;**************************************************************************
[DestNetPathNames]
DEST_NET_DRIVER   = $(!STF_NTPATH)\drivers
DEST_NET_PROTOCOL = $(!STF_NTPATH)\drivers
DEST_NET_EXE      = $(!STF_WINDOWSSYSPATH)
DEST_NET_INF      = $(!STF_WINDOWSSYSPATH)
DEST_NET_DLL      = $(!STF_WINDOWSSYSPATH)

;
;  Instantiate the platform dependent lists
;
[NetworkVars]
;
;  Global variables which would otherwise be supplied by NCPASHEL.INF
;
!STF_SRCDIR_KEYED     = ""       ;   source dir as entered
!STF_SRCDIR_USED      = ""       ;   source dir as used
!STF_SRCDIR_OVERRIDE  = ""       ;   OEM source path
!NTN_RegBase          = ""
!NTN_ServiceBase      = "SYSTEM\CurrentControlSet\SERVICES"
!NTN_SoftwareBase     = "SOFTWARE"
!NTN_InstallMode      = "install"
!NTN_Origination      = "install"
!NTN_InstallPhase     = "primary"

;
;  Set up the default lists for services and protocols
;
ServiceInfList     = ^(ServiceData, 1)
ServiceOptionList  = ^(ServiceData, 2)
ServiceBbList      = ^(ServiceData,3)
ServiceNameList    = ^(ServiceData,4)

ProtoInfList       = ^(ProtoData, 1)
ProtoOptionList    = ^(ProtoData, 2)
ProtoBbList        = ^(ProtoData, 3)
ProtoNameList      = ^(ProtoData, 4)


;
;  SERVICE and PROTOCOL INF lists.
;
;  Format:    <name of INF to run>,<option to install>,<billboard index>
;
;  Default NetBIOS transport INF: NetBeui (NBF.SYS)
;
[ProtoData]
ProtoData_1        = "OEMNXPIP.INF","NWLNKIPX",14,nwlnkipx
ProtoData_2        = "OEMNXPTC.INF","TC",15,tcpip
ProtoData_3        = "OEMNXPNB.INF","NBF",4,Nbf
;
;  NT LM service INFs.  Files is this list are "shelled" to, along with
;    the appropriate protocol INF and netcard INF.
;
[ServiceData]
    ;  Server service
ServiceData_1      = "OEMNSVSV.INF","SRV",3,LanmanServer
    ;  Workstation service
ServiceData_2      = "OEMNSVWK.INF","WKSTA",2,LanmanWorkstation
    ;  NetBIOS API support
ServiceData_3      = "OEMNSVNB.INF","NETBIOS",5,NetBIOS
    ;  RPC API support
ServiceData_4      = "OEMNSVRP.INF","RPCLOCATE",11,RPCLOCATOR

[RasServiceData]
RAS_InfName    = "OEMNSVRA.INF"
RAS_Option     = "RAS"
RAS_Billboard  = 12
RAS_Service    = "RAS"


;**************************************************************************
;**************************************************************************
;
;   SHELL COMMANDS SECTION
;
;**************************************************************************
;**************************************************************************




























































































































































































































































































































































































































































[DoNetwork]

   Set !G:DebugOutputControl = 0

   Debug-Output "NTLANMAN.INF: Section: Shell Commands"

   Set NetInstallStatus = STATUS_SUCCESSFUL

   set-subst LF = "\n"

   StartWait
;
; read general constants, etc.
;
   read-syms GeneralConstants
   read-syms BaseGeneralConstants

   Ifstr(i) $(!STF_PRODUCT) == "WINNT"
        read-syms ProductTitleWinNt$(!STF_LANGUAGE)
   Else
        read-syms ProductTitleLanmanNt$(!STF_LANGUAGE)
   Endif
   Debug-Output "NTLANMAN.INF: Product title is: "$(!NetProductTitle)
   set-title $(!NetProductTitle)" Network Installation"

   read-syms UiVars
   read-syms DestNetPathNames
   read-syms DialogConstants
   read-syms NetworkVars
   read-syms ProgressCopy$(!STF_LANGUAGE)

   Set !STF_IDW = FALSE

   Debug-Output "NTLANMAN.INF: Base variables loaded"

   LoadLibrary "x" $(!STF_CWDDIR)\setupdll.dll !LIBHANDLE

   Debug-Output "NTLANMAN.INF: Successfully linked to SETUPDLL.DLL"

   LoadLibrary "x" $(!STF_CWDDIR)\ncpa.cpl !NCPA_HANDLE

   Debug-Output "NTLANMAN.INF: Successfully linked to NCPA.CPL"

   Shell "subroutn.inf" ReadSetupHelpIds
   SetHelpFile "setupnt.hlp" $(!MinimumID) $(!MaximumID)

   EndWait

   Debug-Output "NTLANMAN.INF: Network variables loaded"

   ;
   ;   To support WINNT setup, record STF_SRCDIR into the Registry.
   ;   If present, this is used as an override to the "SourcePath"
   ;   value SETUP normally records.  The problem is that the "SourcePath"
   ;   is a lie for WINNT setup-- it always points at "A:\", not to the
   ;   hidden temporary directory.
   ;
   OpenRegKey $(!REG_H_LOCAL) "" "SYSTEM\Setup" $(MAXIMUM_ALLOWED) KeySetup
   Ifstr(i) $(KeySetup) != ""
       SetRegValue $(KeySetup) {WinntPath,$(NoTitle),$(!REG_VT_SZ),$(!STF_SRCDIR)}
       CloseRegKey $(KeySetup)
       Debug-Output "NTLANMAN.INF: Setup\WinntPath value set to: "$(!STF_SRCDIR)
   Endif

   ;
   ; If Upgrade, then go to do upgrade
   ;
   ifstr(i) $(!STF_NTUPGRADE) == "YES"
        ifint $(BillboardVisible) != 0
            Shell "subroutn.inf" PopBillboard
            Set BillboardVisible = 0
        Endif

        read-syms Billboard13$(!STF_LANGUAGE)
        Shell "subroutn.inf" PushBillboard NETSTATUSDLG $(Status)

        set BillboardVisible = 1

        Shell "" UpgradeNetwork

        goto end
   endif



;------------------------------------------------------------------------
;
;   NETCARD INSTALLATION
;
;   Since detection is always activated merely by shelling to
;   [InitialAdapterInstall], we just call the INF OEMHOOK.INF.
;   This file, normally absent, allows vendors to copy files,
;   manipulate the Registry, etc., to prepare for netcard operations.
;
;------------------------------------------------------------------------

   ;
   ;  Get global variables set up and enable detection.
   ;
   Shell $(NcParamInf) Param_SetGlobals
   Set !STF_NCDETECT = YES

   ;  Silently run the INF called OEMHOOK.INF if there is one.

   Shell "" InstallOemHook

   Debug-Output "NTLANMAN.INF: Establish netcard option"

   set retaddr = nphase$runinfs
   goto netgetdriver

nphase$runinfs = +
   Debug-Output "NTLANMAN.INF: Run subordinate INFs"

   Set retaddr = nphase$installfiles
   Goto netruninfs
;
;  Add all the networking files to the install list and
;  copy them.
;
nphase$installfiles = +
   Ifstr(i) $(!STF_IDW) != "TRUE"
       Set retaddr = nphase$runncpa
       Goto netinstallfiles
   Endif
;
; Run the NCPA to configure the network
;
nphase$runncpa = +
   ;
   ;  Does ActiveComputerName exist?  If so, stomp on it.
   ;
   Set KeyComputerName = $(KeyNull)
   OpenRegKey $(!REG_H_LOCAL) "" $(ComputerNameKeyName)"\ActiveComputerName" $(MAXIMUM_ALLOWED) KeyComputerName

   Ifstr(i) $(KeyComputerName) != $(KeyNull)
       GetRegValue $(KeyComputerName) "ComputerName" ValueActiveComputerName
       Set ActiveComputerName = *($(ValueActiveComputerName),4)
       Debug-Output "NTLANMAN.INF: *************************************"
       Debug-Output "NTLANMAN.INF: ActiveComputerName key exists: "$(ActiveComputerName)
       SetRegValue $(KeyComputerName) {ComputerName,$(NoTitle),$(!REG_VT_SZ),$(!STF_COMPUTERNAME)}
       Debug-Output "NTLANMAN.INF: ActiveComputerName was set to: "$(!STF_COMPUTERNAME)
       Debug-Output "NTLANMAN.INF: *************************************"
       CloseRegKey $(KeyComputerName)
   Else
       Debug-Output "NTLANMAN.INF: ActiveComputerName key does not exist."
   Endif







   Debug-Output "NTLANMAN.INF: Run NCPA to configure the network"
   Ifint $(BillboardVisible) != 0
       Shell "subroutn.inf" PopBillboard
       Set BillboardVisible = 0
   Endif

   Set retaddr = nphase$startnet
   Goto netrunncpa
;
; Start the network (workstation, rdr, xport, driver)
;
nphase$startnet = +
   ;
   ;  We may have been "retrying" the NCPA.  In this case, the ActiveComputerName and
   ;  ComputerName may be different.  If they are different, set ActiveComputerName to
   ;  ComputerName.
   ;
   Set KeyComputerName = $(KeyNull)
   OpenRegKey $(!REG_H_LOCAL) "" $(ComputerNameKeyName)"\ComputerName" $(MAXIMUM_ALLOWED) KeyComputerName
   Ifstr(i) $(KeyComputerName) == $(KeyNull)
       Goto nphase$compnameok
   Endif

   GetRegValue $(KeyComputerName) "ComputerName" ValueComputerName
   Set ComputerName = *($(ValueComputerName),4)

   Set KeyActiveComputerName = $(KeyNull)
   OpenRegKey $(!REG_H_LOCAL) "" $(ComputerNameKeyName)"\ActiveComputerName" $(MAXIMUM_ALLOWED) KeyActiveComputerName
   Ifstr(i) $(KeyActiveComputerName) == $(KeyNull)
       CloseRegKey $(KeyComputerName)
       Goto nphase$compnameok
   Endif

   GetRegValue $(KeyActiveComputerName) "ComputerName" ValueActiveComputerName
   Set ActiveComputerName = *($(ValueActiveComputerName),4)

   Ifstr(i) $(ActiveComputerName) != $(ComputerName)
       ;
       ;  The user apparently changed the name.  Make sure the network starts
       ;  with the correct name.
       ;
       Set !STF_COMPUTERNAME = $(ComputerName)
       SetRegValue $(KeyActiveComputerName) {ComputerName,$(NoTitle),$(!REG_VT_SZ),$(ComputerName)}
       Debug-Output "NTLANMAN.INF: Before starting network, ActiveComputerName was set to: "$(ComputerName)
   Endif

   CloseRegKey $(KeyComputerName)
   CloseRegKey $(KeyActiveComputerName)

nphase$compnameok = +

;   CAIRO BUGBUG
;
; Cairo -- restore dependency of workstation on mup
;
; BUGBUG: this is really ugly, and should be removed once Isaac's change
;  to RtlDosPathToNtPath_U has been verified.
   LibraryProcedure Result, $(!LIBHANDLE), SetupChangeServiceConfig, "LanmanWorkstation", $(SERVICE_NO_CHANGE), $(SERVICE_NO_CHANGE), $(SERVICE_NO_CHANGE), "%SystemRoot%\System32\services.exe", "NetworkProvider", {"+TDI","Mup"}, "", "", ""



   Debug-Output "NTLANMAN.INF: Run NCPA to start the network"

   read-syms Billboard6$(!STF_LANGUAGE)
   Shell "subroutn.inf" PushBillboard NETSTATUSDLG $(Status)
   Set BillboardVisible = 1

   Set retaddr = nphase$domainrole
   Set retaddrfailed = nphase$startnetfailed

   Goto netstartnetwork
;
;  The network start failed.
;  Return to the NCPA if the user so chooses.
;
nphase$startnetfailed = +

   shell "" QueryNcpaRetry $(!STF_LANGUAGE)

   Ifstr(i) $($R0) == STATUS_SUCCESSFUL
       Set retaddr = nphase$startnet
       Goto netretryncpa
   Endif
;
; The network started.  Now determine this machine's role in the network.
;
nphase$domainrole = +
   Debug-Output "NTLANMAN.INF: Run NCPA to establish domain"
   Ifint $(BillboardVisible) != 0
       Shell "subroutn.inf" PopBillboard
       Set BillboardVisible = 0
   Endif





;
; Connect to a remote sharepoint if necessary
;
nphase$connectshare = +
   ;
   ; connecting to a remote share is not necessary... in initial setup we don't
   ; have unc shares.
   ;

   Debug-Output "NTLANMAN.INF: Domain Role = "$(!STF_DOMAIN_ROLE)
   Set retaddr = nphase$done
   Debug-Output "NTLANMAN.INF: NOT connecting to remote sharepoint"
   Goto $(retaddr)
;
;  That's all for now...
;
nphase$done = +
   Debug-Output "NTLANMAN.INF: Done ************************"
;
;  Remove the billboard, if any
;
   Ifint $(BillboardVisible) != 0
       Shell "subroutn.inf" PopBillboard
       Set BillboardVisible = 0
   Endif

























































































































































































































































































































;
;  Discard the Billboard dialog if still present
;
    Ifint $(BillboardVisible) != 0
        Shell "subroutn.inf" PopBillboard
        Set BillboardVisible = 0
    Endif

    Goto end

;===========================================================================
;===========================================================================
;===========================================================================
;
;  Worker functions.
;
;===========================================================================
;===========================================================================
;===========================================================================

;****************************************************************
;
;  Install all files in copy list.
;
;****************************************************************

netinstallfiles = +


   Shell "initial.inf" ControlBitmaps START


   Debug-Output "NTLANMAN.INF: Installing all files in copy list"
   Install Install-All-Files-Now
   ifstr(i) $(STF_INSTALL_OUTCOME) != STF_SUCCESS
       set Reboot = YES
       install Install-Shutdown
       exit
   endif


   Shell "initial.inf" ControlBitmaps STOP


   goto $(retaddr)

;****************************************************************
;
;  Run the NCPA.CPL in "NCPA" mode; i.e., cause network binding,
;  OEM installation, etc.
;
;****************************************************************
netrunncpa = +

    LibraryProcedure NCPA_RESULT $(!NCPA_HANDLE), CPlSetup $(!STF_HWND), STARTSVC, Spooler
    Set STATUS = *($(NCPA_RESULT),1)
    ifstr(i) $(STATUS) != "0"
        set !STF_START_SPOOLSS = "NO"
    endif

;
;  Run the NCPA, giving it the proper information:  the window handle
;     of the main SETUP window, the function to run ("NCPA"), and
;    the parameters to use for dialogs and subordinate SETUP invocation.
;
   Shell "" BuildNcpaCommandLine $(!STF_INSTALL_MODE)
   Set NCPA_CMD_LINE = $($R0)
   Set NCPA_FUNC = NCPA
   Goto netcallncpa

;****************************************************************
;
;  Build the command line paramters for RETRYing the network start or
;  domain joining operations.  Then call the NCPA's main routine.
;
netretryncpa = +
   Shell "" BuildNcpaCommandLine RETRY
   Set NCPA_CMD_LINE = $($R0)
   Set NCPA_FUNC = NCPA
   Goto netcallncpa

netstartservice = +
;
; Call the NCPA's StartService wrapper.  It allows passing of parameters,
;    but we currently don't need this capability.
;
   Debug-Output "NTLANMAN.INF: calling NCPA.CPL to start service "$(NCPA_SERVICE)

   LibraryProcedure NCPA_RESULT $(!NCPA_HANDLE), CPlSetup $(!STF_HWND), STARTSVC, $(NCPA_SERVICE)
   Goto netreturnncpa

netcallncpa = +
;
;  Call the NCPA.CPL.  There are three standard parameters:
;
;        [0]   ASCII form of LONG window handle
;        [1]   ASCII name of NCPA.CPL function to perform
;        [2]   command line to pass to NCPA and subordinate INFs
;
;
   Debug-Output "NTLANMAN.INF: calling NCPA.CPL, function "$(NCPA_FUNC)

   LibraryProcedure NCPA_RESULT $(!NCPA_HANDLE),CPlSetup $(!STF_HWND), $(NCPA_FUNC), $(NCPA_CMD_LINE)

netreturnncpa = +

   Set NCPA_STATUS = *($(NCPA_RESULT),1)
   Debug-Output "NTLANMAN.INF: NCPA Status was: "$(NCPA_STATUS)
   goto $(retaddr)

;****************************************************************
;
;  Start the Network:  start LanmanWorkstation and LMHOSTS if it exists
;
;****************************************************************
netstartnetwork = +
   Debug-Output "NTLANMAN.INF: Starting workstation..."
   StartWait
   Set WaitStarted = 1
   Set FLibraryErrCtl = 1

   LibraryProcedure NCPA_RESULT $(!NCPA_HANDLE), CPlSetup $(!STF_HWND), STARTSVC, LanmanWorkstation

   Set NCPA_STATUS = *($(NCPA_RESULT),1)

   Debug-Output "NTLANMAN.INF: Start workstation; result was: "$(NCPA_STATUS)

   Ifint $(NCPA_STATUS) != 0
       EndWait
       Set WaitStarted = 0

       LibraryProcedure NCPA_RESULT $(!NCPA_HANDLE), CPlSetup $(!STF_HWND), ERRORMSG, $(NCPA_STATUS)

       Set NCPA_ERROR_MESSAGE = *($(NCPA_RESULT),2)
       Debug-Output "NTLANMAN.INF: Error "$(NCPA_STATUS)" translated to: "$(NCPA_ERROR_MESSAGE)
       Read-syms WarningNoNet$(!STF_LANGUAGE)
       Set Error = $(NCPA_ERROR_MESSAGE)$(ErrorSuffix)
       read-syms WarningDlg$(!STF_LANGUAGE)
       ui start SetupMessage
       set retaddr = $(retaddrfailed)
       goto netstartnetdone
   Endif

   Debug-Output "NTLANMAN.INF: Starting LMHOSTS service..."

   ;
   ; Start LMHOSTS service if it exists
   ;
   OpenRegKey $(!REG_H_LOCAL) "" "SYSTEM\CurrentControlSet\Services\LmHosts" $(MAXIMUM_ALLOWED) KeyLmHosts
   ifstr(i) $(KeyLmHosts) != ""
       EndWait
       Set WaitStarted = 0

       LibraryProcedure NCPA_RESULT $(!NCPA_HANDLE), CPlSetup $(!STF_HWND), STARTSVC, LmHosts

       Set NCPA_STATUS = *($(NCPA_RESULT),1)

       Debug-Output "NTLANMAN.INF: Start Lmhosts; result was: "$(NCPA_STATUS)

       Ifint $(NCPA_STATUS) != 0
           LibraryProcedure NCPA_RESULT $(!NCPA_HANDLE), CPlSetup $(!STF_HWND), ERRORMSG, $(NCPA_STATUS)
           Set NCPA_ERROR_MESSAGE = *($(NCPA_RESULT),2)
           Debug-Output "NTLANMAN.INF: Error "$(NCPA_STATUS)" translated to: "$(NCPA_ERROR_MESSAGE)
           Read-syms WarningNoLmHosts$(!STF_LANGUAGE)
           Set Error = $(NCPA_ERROR_MESSAGE)$(ErrorSuffix)
           read-syms WarningDlg$(!STF_LANGUAGE)
           ui start SetupMessage
           goto setupnotdone
       Endif
   Endif












netstartnetdone =+

   Set FLibraryErrCtl = 0
   Ifint $(WaitStarted) == 1
       EndWait
   Endif



   Goto $(retaddr)

;****************************************************************
;
;  Run NCPA.CPL in "DOMAIN" mode; i.e., establish domain
;  role, security info, etc.,
;
;  The DOMAIN subfunction returns a string (NCPA_RESULT) in
;  the following format:
;
;                       { <numeric error code>,
;                         COMPUTERNAME,
;                         DOMAINNAME,
;                         LOGONPASSWORD,
;                         COMPUTERROLE
;                       }
;****************************************************************
netdomain = +
   Debug-Output "NTLANMAN.INF: Running Domain Settings dialog..."

   Shell "" BuildNcpaCommandLine $(!STF_INSTALL_MODE)

   Set NCPA_CMD_LINE = $($R0)

   ;
   ; Unattended mode
   ;
   ifstr(i) $(!STF_GUI_UNATTENDED) == "YES"
      ifstr(i) $(!STF_AUTOWORKGROUP) != ""
          set NCPA_CMD_LINE = $(NCPA_CMD_LINE)" /t STF_AUTOWORKGROUP = "$(!STF_AUTOWORKGROUP)
      else-ifstr(i) $(!STF_AUTODOMAIN) != ""
          set NCPA_CMD_LINE = $(NCPA_CMD_LINE)" /t STF_AUTODOMAIN = "$(!STF_AUTODOMAIN)
          ifstr(i) $(!STF_PRODUCT) == "LanmanNT"
            ifstr(i) $(!STF_AUTOPRIMARY) == "YES"
                set NCPA_CMD_LINE = $(NCPA_CMD_LINE)" /t STF_AUTOPRIMARY = YES"
            endif
          endif
      endif
   endif

   Debug-Output "NTLANMAN.INF: Command line = "$(NCPA_CMD_LINE)

   Set FLibraryErrCtl = 1

   LibraryProcedure NCPA_RESULT $(!NCPA_HANDLE), CPlSetup $(!STF_HWND), DOMAIN, $(NCPA_CMD_LINE)

   Set FLibraryErrCtl = 0

   Set NCPA_STATUS = *($(NCPA_RESULT),1)

   Debug-Output "NTLANMAN.INF: Domain Settings result was: "$(NCPA_STATUS)

   Ifint $(NCPA_STATUS) != 0
       ;
       ;   Check for IDS_NCPA_SETUP_CANCELLED. If so, and LanmanNT,
       ;   discontinue installation.
       ;
       Ifint $(NCPA_STATUS) == 13074
           Ifstr(i) $(!STF_PRODUCT) == "LANMANNT"
               Debug-Output "NTLANMAN.INF: Aborting LanmanNT installation; user cancellation."
               Set NetInstallStatus = STATUS_USERCANCEL
               Goto setupnotdone
           Endif
       Endif
   Endif

;
;  Check the return variable, and update globals with new
;  information derived from domain installation process.
;
   Set TEMP_COMPUTERNAME  =  *($(NCPA_RESULT),2)
   Set TEMP_DOMAINNAME    =  *($(NCPA_RESULT),3)
   Set TEMP_COMPUTERROLE  =  *($(NCPA_RESULT),5)

   Ifstr(i) $(TEMP_COMPUTERNAME) != ""
        Ifstr(i) $(TEMP_COMPUTERNAME) != $(!STF_COMPUTERNAME)
            Set !STF_COMPUTERNAME = $(TEMP_COMPUTERNAME)
            Debug-Output "NTLANMAN.INF: Computername changed to "$(!STF_COMPUTERNAME)
        Endif
   Endif
   Ifstr(i) $(TEMP_DOMAINNAME) != ""
        Set !STF_DOMAIN = $(TEMP_DOMAINNAME)
        Debug-Output "NTLANMAN.INF: Domain name is "$(!STF_DOMAIN)
   Endif
   Ifstr(i) $(TEMP_COMPUTERROLE) != ""
        Set !STF_DOMAIN_ROLE = $(TEMP_COMPUTERROLE)
        Debug-Output "NTLANMAN.INF: Domain role is "$(!STF_DOMAIN_ROLE)
   Endif
;
;  Check to see if TEMP_COMPUTERROLE is STANDALONE.  If so, alter the NetLogon
;  service to be startable on demand (not auto-started).
;
   Ifstr(i) $(TEMP_COMPUTERROLE) == STANDALONE
        Debug-Output "NTLANMAN.INF: Prevent NETLOGON service from autostarting"
        LibraryProcedure DontCare, $(!LIBHANDLE), SetupChangeServiceConfig, NetLogon,+
               $(SERVICE_NO_CHANGE), 3, $(SERVICE_NO_CHANGE), "", "", "", "", "", ""
   Endif

   goto $(retaddr)
;****************************************************************
;
;   Get Primary Adapter Type
;
;****************************************************************
netgetdriver = +
    Debug-Output "NTLANMAN.INF: Label: netgetdriver"

    Shell "" InitialAdapterInstall

    Set NetInstallStatus = $($R0)

    Ifstr(i) $(NetInstallStatus) == STATUS_WANTRAS
        Set NetInstallStatus = STATUS_SUCCESSFUL
        Set RasAutoInstall = 1
        Debug-Output "NTLANMAN.INF: RAS auto-installation chosen"
    Endif

    Debug-Output "NTLANMAN.INF: netgetdriver; returning: "$(NetInstallStatus)

;****************************************************************
;
;   See if user has cancelled; exit if so.  Convert EXITNET to
;     SUCCESSFUL if this is main installation.
;
;****************************************************************
netcheckquit = +
    Debug-Output "NTLANMAN.INF: netcheckquit original status: "$(NetInstallStatus)

    Set UserChoiceList = {"STATUS_SUCCESSFUL",+   ; all is well
                          "STATUS_USERCANCEL",+   ; user wants to exit completely
                          "STATUS_EXITNET",+      ; user wants no network
                          "STATUS_FAILED"}        ; things are dismal

    Ifstr(i) $(!STF_PRODUCT) == "LANMANNT"
        Set InfReturnList  = {"STATUS_SUCCESSFUL",+   ; SUCCESSFUL -> SUCCESSFUL
                              "STATUS_USERCANCEL",+   ; USERCANCEL -> USERCANCEL
                              "STATUS_SUCCESSFUL",+   ; EXITNET    -> SUCCESSFUL
                              "STATUS_FAILED"}        ; FAILED     -> FAILED
        Set LabelList = {$(retaddr),setupnotdone,setupnotdone,setupnotdone}
    Else
        Set InfReturnList  = {"STATUS_SUCCESSFUL",+   ; SUCCESSFUL -> SUCCESSFUL
                              "STATUS_USERCANCEL",+   ; USERCANCEL -> USERCANCEL
                              "STATUS_USERCANCEL",+   ; EXITNET    -> USERCANCEL
                              "STATUS_FAILED"}        ; FAILED     -> FAILED
        Set LabelList = {$(retaddr),setupnotdone,nphase$done,setupnotdone}
    Endif






    ;  Set the user's choice index

    Set UserChoice = ~($(UserChoiceList),$(NetInstallStatus))
    Ifint $(UserChoice) == 0
        ;  Default to "STATUS_FAILED" if unintelligible
        Debug-Output "NTLANMAN.INF: netcheckquit defaulting status to STATUS_FAILED"
        Set UserChoice = 4
    Endif

    ;  Set the return value and return point based on status

    Set NetInstallStatus = *($(InfReturnList),$(UserChoice))
    Set UserRetAddr = *($(LabelList),$(UserChoice))

    Debug-Output "NTLANMAN.INF: netcheckquit status: "$(NetInstallStatus)", label: "$(UserRetAddr)

    Goto $(UserRetAddr)


;****************************************************************
;
;  Run the Subordinate INFs
;
;  Execute all the necessary component INFs.  First, run the adapter
;  INF, then the protocol INF.  After, run all the NT LM service INFs
;
;****************************************************************
netruninfs = +

   Debug-Output "NTLANMAN.INF: Label: netruninfs"

   Set InfsToBeRun      = {}
   Set OptionsToInstall = {}
   Set BbToBeShown      = {}
   Set SvcNameList      = {}
   Set AdapterSrcDir    = $(!STF_SRCDIR)

   ifstr(i) $(!STF_GUI_UNATTENDED) == YES
       Set !PromptForTransport = 0
       shell "subroutn.inf" GetDefaultAnswer "TransportData"
   else
       Set !PromptForTransports = 1

       Ifstr(i) $(!STF_PRODUCT) == "WINNT"
          Ifint $(RasAutoInstall) == 1
             Set !InstallNetBEUI = 1
             Set !InstallNWLink = 1
             Set !InstallTCPIP = 0
             Set !PromptForTransports = 0
          else
             Set !InstallNetBEUI = 0
             Set !InstallNWLink = 1
             Set !InstallTCPIP = 0
          endif
       else
           Set !InstallNetBEUI = 1
           Set !InstallNWLink = 1
           Set !InstallTCPIP = 0
       endif

       Shell "xports.inf" DefaultTransports

getproto = +
       ifint $(!PromptForTransports) == 1
          ifint $(!InstallNetBEUI) == 1
            Set CBInstallNetBEUI = "ON"
          else
            Set CBInstallNetBEUI = "OFF"
          endif
          ifint $(!InstallNWLink) == 1
            Set CBInstallNWLink = "ON"
          else
            Set CBInstallNWLink = "OFF"
          endif
          ifint $(!InstallTCPIP) == 1
            Set CBInstallTCPIP = "ON"
          else
            Set CBInstallTCPIP = "OFF"
          endif
          read-syms QueryProtocol$(!STF_LANGUAGE)

          ;
          ; Check the protocol and disable the installed
          ;
          set IPXAlreadyInstalled = FALSE
          set TCPAlreadyInstalled = FALSE
          set NetBEUIAlreadyInstalled = FALSE
          OpenRegKey $(!REG_H_LOCAL) "" "SYSTEM\CurrentControlSet\Services\NWLNKIPX" $(MAXIMUM_ALLOWED) IPXKey
          ifstr(i) $(IPXKey) != ""
                set IPXAlreadyInstalled = TRUE;
                CloseRegKey $(IPXKey)
          endif
          OpenRegKey $(!REG_H_LOCAL) "" "SYSTEM\CurrentControlSet\Services\Tcpip" $(MAXIMUM_ALLOWED) TCPKey
          ifstr(i) $(TCPKey) != ""
                set TCPAlreadyInstalled = TRUE;
                CloseRegKey $(TCPKey)
          endif
          OpenRegKey $(!REG_H_LOCAL) "" "SYSTEM\CurrentControlSet\Services\Nbf" $(MAXIMUM_ALLOWED) NetBEUIKey
          ifstr(i) $(NetBEUIKey) != ""
                set NetBEUIAlreadyInstalled = TRUE;
                CloseRegKey $(NetBEUIKey)
          endif

          ifstr(i) $(IPXAlreadyInstalled) == TRUE
                ifstr(i) $(OptionsGreyed) == {}
                    set OptionsGreyed = {1}
                else
                    set OptionsGreyed = >($(OptionsGreyed),"1")
                endif
          endif
          ifstr(i) $(TCPAlreadyInstalled) == TRUE
                ifstr(i) $(OptionsGreyed) == {}
                    set OptionsGreyed = {2}
                else
                    set OptionsGreyed = >($(OptionsGreyed),"2")
                endif
          endif
          ifstr(i) $(NetBEUIAlreadyInstalled) == TRUE
                ifstr(i) $(OptionsGreyed) == {}
                    set OptionsGreyed = {3}
                else
                    set OptionsGreyed = >($(OptionsGreyed),"3")
                endif
          endif

          ui start "InputDlg"

          set CBInstallNWLink   = *($(CheckItemsOut), 1)
          set CBInstallTCPIP   = *($(CheckItemsOut), 2)
          set CBInstallNetBEUI   = *($(CheckItemsOut), 3)
          ifstr(i) $(IPXAlreadyInstalled) == TRUE
                set CBInstallNWLink = OFF
          endif
          ifstr(i) $(TCPAlreadyInstalled) == TRUE
                set CBInstallTCPIP = OFF
          endif
          ifstr(i) $(NetBEUIAlreadyInstalled) == TRUE
                set CBInstallNetBEUI = OFF
          endif

          ifstr $(CBInstallNetBEUI) == "ON"
            Set !InstallNetBEUI = 1
          else
            Set !InstallNetBEUI = 0
          endif
          ifstr $(CBInstallNWLink) == "ON"
            Set !InstallNWLink = 1
          else
            Set !InstallNWLink = 0
          endif
          ifstr $(CBInstallTCPIP) == "ON"
            Set !InstallTCPIP = 1
          else
            Set !InstallTCPIP = 0
          endif


          ifint $(!InstallNWLink) == 0
             ifint $(!InstallNetBEUI) == 0
                ifint $(!InstallTCPIP) == 0
                    read-syms Strings$(!STF_LANGUAGE)
                    shell "SUBROUTN.INF" SetupMessage $(!STF_LANGUAGE) "NONFATAL" $(Error5)
                    goto getproto
                endif
             endif
          endif

          ui pop 1

       endif
   endif

   ForListDo $(ProtoInfList)
        Set AddIt = 0
        ifstr *($(ProtoOptionList),$(#)) == "NBF"
            ifint $(!InstallNetBEUI) == 1
                Set AddIt = 1
            endif
        else-ifstr *($(ProtoOptionList),$(#)) == "TC"
            ifint $(!InstallTCPIP) == 1
                Set AddIt = 1
            endif
        else-ifstr *($(ProtoOptionList),$(#)) == "NWLNKIPX"
            ifint $(!InstallNWLink) == 1
                Set AddIt = 1
            endif
        endif

        ifint $(AddIt) == 1
            Set InfsToBeRun = >($(InfsToBeRun),$($))
            Set OptionsToInstall = >($(OptionsToInstall),*($(ProtoOptionList),$(#)))
            Set BbToBeShown = >($(BbToBeShown),*($(ProtoBbList),$(#)))
        endif
   EndForListDo

   ForListDo $(ServiceInfList)
        Set InfsToBeRun = >($(InfsToBeRun),$($))
        Set OptionsToInstall = >($(OptionsToInstall),*($(ServiceOptionList),$(#)))
        Set BbToBeShown = >($(BbToBeShown),*($(ServiceBbList),$(#)))
   EndForListDo

    ;
    ;  If selected, append the RAS tokens to the extant lists
    ;
    Ifint $(RasAutoInstall) == 1
        Debug-Output "NTLANMAN.INF: Preparing RAS for installation"
        read-syms RasServiceData
        Set InfsToBeRun = >($(InfsToBeRun),$(RAS_InfName))
        Set OptionsToInstall = >($(OptionsToInstall),$(RAS_Option))
        Set BbToBeShown  = >($(BbToBeShown),$(RAS_Billboard))
    Endif

   Debug-Output "NTLANMAN.INF: INFs to be run: "$(InfsToBeRun)
   Debug-Output "NTLANMAN.INF: Options to install: "$(OptionsToInstall)
   Debug-Output "NTLANMAN.INF: Billboards to be shown: "$(BbToBeShown)
;
;  The list of INFs is now complete. Start shelling...
;
   Set FailedInfFile = ""

   ForListDo $(InfsToBeRun)
        Set ThisInfName = $($)
        Set BbIndex = *($(BbToBeShown),$(#))

        Debug-Output "NTLANMAN.INF: Installing "$(ThisInfName)

        Ifint $(BbIndex) != 0
            read-syms Billboard$(BbIndex)$(!STF_LANGUAGE)
            Shell "subroutn.inf" PushBillboard NETSTATUSDLG $(Status)
            Set BillboardVisible = 1
        Else-ifint $(BillboardVisible) != 0
            Shell "subroutn.inf" PopBillboard
            Set BillboardVisible = 0
        Endif

        Set FailedInfFile = $(ThisInfName)

        Set InfOption = *($(OptionsToInstall),$(#))

        set OldSTFInstallMode = $(!STF_INSTALL_MODE)
        ;ifstr(i) $(InfOption) == "TC"
        ;    set !STF_INSTALL_MODE = CUSTOM
        ;endif

        Shell $(ThisInfName) InstallOption $(!STF_LANGUAGE) $(InfOption) $(AdapterSrcDir) "YES" "NO" "NO"

        set !STF_INSTALL_MODE = $(OldSTFInstallMode)

        ; Reset the title string
        Set-title $(!NetProductTitle)" Network Installation"

        Ifint $($ShellCode) != $(!SHELL_CODE_OK)
            Debug-Output "NTLANMAN.INF: INF "$(ThisInfName)" SHELL ERROR!"
            Goto netruninfescape
        Endif

        Set NetInstallStatus = $($R0)

        Ifstr(i) $(NetInstallStatus) != STATUS_SUCCESSFUL
            Ifstr(i) $(NetInstallStatus) != STATUS_USERCANCEL
                Ifstr(i) $(NetInstallStatus) != STATUS_NO_EFFECT
                    Debug-Output "NTLANMAN.INF: INF "$(ThisInfName)" returned "$(NetInstallStatus)
                    Goto netruninfescape
                else
                    set NetInstallStatus = STATUS_SUCCESSFUL
                Endif
            Endif
        Endif

        Set FailedInfFile = ""

   EndForListDo

;
;  All the products are set to be copied, and the Registry is up to date.
;
netruninfescape = +

   Ifint $(BillboardVisible) != 0
       Shell "subroutn.inf" PopBillboard
       Set BillboardVisible = 0
   Endif

   Ifstr(i) $(FailedInfFile) != ""
        Read-syms FatalError14$(!STF_LANGUAGE)
        read-syms FatalDlg$(!STF_LANGUAGE)
        ui start "FatalError"
        Set NetInstallStatus = STATUS_FAILED
   Endif

   Goto netcheckquit

;****************************************************************
;
;  ERROR MESSAGE AND EXIT ROUTINES
;
;****************************************************************
;
; information display
;
infomsg = +
   read-syms InfoDlg
   ui start "Warning"
   goto $(from)

;
; non fatal error display
;
nonfatal = +
   read-syms NonfatalDlg$(!STF_LANGUAGE)
   ui start "NonFatalError"
   ifstr(i) $(DLGEVENT) == "OK"
       goto $(from)
   else
       goto end
   endif

;
;  Internal error in dialog handling.
;
bogusexit = +
   Debug-Output "NTLANMAN.INF: BOGUS EXIT from "$(from)" Return addr: "$(retaddr)
   read-syms FatalError999$(!STF_LANGUAGE)
   goto fatal

;
; fatal error display
;
fatal = +
   read-syms FatalDlg$(!STF_LANGUAGE)
   ui start "FatalError"
   goto term

end = +
    goto term

term =+

   Ifstr(i) $(!LIBHANDLE) != ""
       LibraryProcedure DontCare, $(!LIBHANDLE), DeleteAllConnections
   Endif



setupnotdone = +
   Set InfoMsgText = "Returning to INITIAL.INF"
   Debug-Output "NTLANMAN.INF: "$(InfoMsgText)"; status "$(NetInstallStatus)

returntocaller = +
   Return $(NetInstallStatus)


    exit






































;**************************************************************************
;
;   Code Lifted from HARDWARE.INF for the management of the "adapter type"
;   interface.
;
;**************************************************************************

[AdapterVars]
    AdapterHardwareDetected      = ""
    AdapterSystemSet             = ""
    AdapterDefault               = ""
    AdapterOurINFOptions         = {}
    AdapterOemINFOptions         = {}
    AdapterMergedOptions         = {}
    AdapterSpecialOption         = {}
    AdapterCurrentOption         = {}

    AdapterOptionList            = {}
    AdapterOptionTextList        = {}
    AdapterOption                = {}
    AdapterINF                   = ""
    AdapterInstall               = "NO"
    AdapterSrcDir                = ""
    AdapterDstDir                = ""
    NcParamInf                   = "NCPARAM.INF"

[InitialAdapterInstall]
    ;
    ;
    StartWait

    ;
    ;  Guarantee that netcard detection is activated
    ;
    Shell "" StartDetection

    set Status = STATUS_FAILED
    read-syms OemOptionDiskette$(!STF_LANGUAGE)
    read-syms Strings$(!STF_LANGUAGE)
    read-syms ProgressCopy$(!STF_LANGUAGE)

    Shell "subroutn.inf" ReadSetupHelpIds
    SetHelpFile "setupnt.hlp" $(!MinimumID) $(!MaximumID)

    read-syms AdapterVars

    ;
    ;;;;detect   AdapterVars
    ;

    ;
    ;  Set the Copy and Config flags based upon whether
    ;  the NCPA called us or this is main installation
    ;
    Set !NtLmDoCopy   = "YES"
    Set !NtLmAddCopy  = "YES"
    Set !NtLmDoConfig = "NO"

    Ifstr(i) $(!NTN_Origination) == "ncpa"
        ;  Secondary installation
        Ifstr(i) $(!STF_IDW) == "TRUE"
            Set !NtLmAddCopy  = "NO"
            Set !NtLmDoCopy   = "NO"
        Endif
    Else
        ;  Primary installation
        Set !NtLmDoCopy   = "NO"
        Ifstr(i) $(!STF_IDW) == "TRUE"
            Set !NtLmAddCopy  = "NO"
        Endif
    Endif

    EndWait
    ;
    ; initialize all the adapter option vars
    ;
    read-syms Billboard1$(!STF_LANGUAGE)
    Shell "subroutn.inf" PushBillboard NETSTATUSDLG $(Status)

    StartWait
    shell "" InitOptionVars $(!STF_LANGUAGE) NetAdapter +
        $(AdapterHardwareDetected) $(AdapterSystemSet) $(AdapterDefault)
    ifstr(i) $($R0) == "STATUS_SUCCESSFUL"
        set AdapterOurINFOptions = $($R1)
        set AdapterOemINFOptions = $($R2)
        set AdapterMergedOptions = $($R3)
        set AdapterSpecialOption = $($R4)
        set AdapterCurrentOption = $($R5)
        set AdapterOption        = *($($R5), 1)
    else
        EndWait
        Shell "subroutn.inf" PopBillboard
        shell "SUBROUTN.INF" SetupMessage $(!STF_LANGUAGE) "FATAL" $(Error1)
        Set Status = STATUS_FAILED
        goto finish_adapter
    endif

    EndWait
    Shell "subroutn.inf" PopBillboard
    StartWait
    ;
    ; Initalize the listbox vars.  Only allow the "None" option during
    ;    primary installation.
    ;
    Ifstr(i) $(!NTN_Origination) != "NCPA"
        Set NoneOption = $(None)
    Else
        Set NoneOption = ""
    Endif

    Shell "" InitListBoxVars $(!STF_LANGUAGE) $(AdapterMergedOptions) $(AdapterSpecialOption) $(Other) $(NoneOption)

    ifstr(i) $($R0) == "STATUS_SUCCESSFUL"
        set AdapterOptionList     = $($R1)
        set AdapterOptionTextList = $($R2)
    else
        EndWait
        shell "SUBROUTN.INF" SetupMessage $(!STF_LANGUAGE) "FATAL" $(Error2)
        goto  finish_adapter
    endif

    read-syms DialogConstants
    EndWait

;------------------------------------------------------------
;  Netcard Detection Logic
;------------------------------------------------------------
    ;
    ;  Clear all the local and global variables associated with
    ;  netcard detection.
    ;
    Set DtOption = ""
    Set DtIndex = 0
    Set DtInfIndex = 0
    Set DtAnyFound = NO
    Set !STF_NCOPTION = $(DtOption)
    Set !STF_NCDETCARD = $(DtIndex)
    Set !STF_NCDETINFO = {}

    ;
    ; Skip atuto detection in unattended mode
    ;
    ifstr(i) $(!STF_GUI_UNATTENDED) == "YES"
        ifstr(i) $(!OEMNetOption) == "YES"
            ;
            ; copy inf file and set net option
            ;
            set AdapterOption = $(!AutoNetOption)
            LibraryProcedure STATUS,$(!LIBHANDLE), CopySingleFile $(!OEMNetInfFile) $(!STF_WINDOWSSYSPATH)\oemnad0.inf
            set AdapterINF = $(!STF_WINDOWSSYSPATH)"\oemnad0.inf"
            set AdapterSrcDir = $(OEMNetDrive)
            ;
            ; copy the new driver from the OEMNetDrive location
            ;
            Set !STF_SRCDIR_OVERRIDE = $(AdapterSrcDir)
            Set !NtLmDoCopy = "YES"
            Set !NtLmAddCopy = "YES"
            goto install_adapter
        endif
        set AdapterOption = $(!AutoNetOption)
        ifstr(i) $(AdapterOption) != ""
            goto install_adapter
        endif
    endif

    ;
    ;  Call the NCPA wrapper (through NCPARAM.INF) to enable detection.
    ;
    Debug-Output "NTLANMAN.INF: calling DTSTART wrapper, mode = "$(!STF_INSTALL_MODE)

    Shell $(NcParamInf) Param_ControlDetection DTSTART
    Ifstr(i) $($ShellCode) != $(!SHELL_CODE_OK)
          Debug-Output "NTLANMAN.INF: shell error (NCPARAM.INF:Param_ControlDetection) : "$($ShellCode)
          Goto adapter_shell_error
    Endif

    Ifstr(i) $($R0) != STATUS_SUCCESSFUL
        Debug-Output "NTLANMAN.INF: DTSTART wrapper FAILED"
        Goto detectbypass
    Endif

    ;
    ;  If we aren't supposed to detect, skip out
    ;
    Ifstr(i) $(!STF_NCDETECT) == NO
        Goto detectbypass
    Endif
    ;
    ;   If CUSTOM, allow the user to skip detection
    ;
    Ifstr(i) $(!STF_INSTALL_MODE) == CUSTOM








        Shell "" WarnDetectStart
        Ifstr(i) $($R0) != STATUS_SUCCESSFUL
            Goto detectbypass
        Endif

    Endif

detectcycle = +

    Debug-Output "NTLANMAN.INF: calling DTCARD wrapper"

    StartWait

    Shell $(NcParamInf) Param_DetectCard
    Set StartResult = $($R0)
    Set StartStatus = *($(StartResult),1)

    Ifstr(i) $($ShellCode) != $(!SHELL_CODE_OK)
          Debug-Output "NTLANMAN.INF: shell error (NCPARAM.INF:Param_DetectCard) : "$($ShellCode)
          Goto adapter_shell_error
    Endif

    EndWait

    Ifint $(StartStatus) == 0
        Set DtOption  = *($(StartResult),2)
        Set DtIndex   = *($(StartResult),3)
        Set DtType    = *($(StartResult),4)
        Set DtConf    = *($(StartResult),5)
        Set DtBusType = *($(StartResult),6)
        Set DtBusNum  = *($(StartResult),7)
        Set DtInfo    = {$(DtOption),$(DtIndex),$(DtType),$(DtConf),$(DtBusType),$(DtBusNum)}

        Debug-Output "NTLANMAN.INF: card found is type "$(DtOption)", index "$(DtIndex)
        ;
        ;  Guarantee that there's an INF file for this card type;
        ;  if not, just try again.
        ;
        Set DtInfIndex = ~($(AdapterOptionList),$(DtOption))
        Ifint $(DtInfIndex) == 0
            Debug-Output "NTLANMAN.INF: Detect: no INF file for option: "$(DtOption)
            Set DtOption = ""
            Goto detectcycle
        Endif
    Else
        Set DtOption = ""
        Set DtIndex = 0
        Set DtInfIndex = 0
        Goto detectnotfound
    Endif

    Set DtAnyFound = YES
    Set DtInfOptionName = *($(AdapterOptionTextList),$(DtInfIndex))
    ;
    ;  If EXPRESS, accept the card automatically
    ;
    Ifstr(i) $(!STF_INSTALL_MODE) == EXPRESS
        Goto detectend
    Endif
    ;
    ;  See if the user wants this card or wants to quit
    ;











    Shell "" WarnDetectAccept $(DtInfOptionName)

    Ifstr(i) $($R0) == STATUS_SUCCESSFUL
        Goto detectend   ;  user likes this choice
    Endif


    Set DtInfOption = 0
    Set DtOption = ""
    Set DtInfIndex = 0

    Ifstr(i) $($R0) != STATUS_TRY_AGAIN
        Goto detectend   ;  user wants to quit
    Endif
    ;
    ;  User doesn't want this card; try again.
    ;
    Goto detectcycle

detectnotfound = +

    Shell "" WarnDetectFail $(DtAnyFound)
    Ifstr(i) $($R0) == STATUS_SUCCESSFUL
        Goto detectend
    Endif
    ;
    ;  User wants to keep trying; reset the iteration
    ;
    Debug-Output "NTLANMAN.INF: calling DTRESET wrapper"

    Shell $(NcParamInf) Param_ControlDetection DTRESET
    Ifstr(i) $($ShellCode) != $(!SHELL_CODE_OK)
          Debug-Output "NTLANMAN.INF: shell error (NCPARAM.INF:Param_ControlDetection) : "$($ShellCode)
          Goto adapter_shell_error
    Endif

    Goto detectcycle

detectend = +
    ;
    ;  Establish global variables.
    ;
    Set !STF_NCOPTION  = $(DtOption)
    Set !STF_NCDETCARD = $(DtIndex)
    Set !STF_NCDETINFO = $(DtInfo)

detectbypass = +
    ;
    ;  If we detected (and accepted) a netcard, use it.
    ;
    Ifstr(i) $(!STF_NCOPTION) != ""
        Set AdapterOption = $(!STF_NCOPTION)
        Goto install_adapter
    Endif

    ;
    ;  If main installation, check to see if the user wants RAS
    ;
    Ifstr(i) $(!NTN_Origination) != "ncpa"
        Shell "" WarnCheckRas
        Ifstr(i) $($R0) == STATUS_WANTRAS
            Set Status = STATUS_WANTRAS
            Goto finish_adapter
        Endif
    Endif

adapter = +

    read-syms QueryAdapter$(!STF_LANGUAGE)
    ;
    ;  Set textual variations for dialog text based on mode and product type
    ;
    Ifstr(i) $(!NTN_Origination) == "ncpa"
        ;  Secondary installation or NTLMINST.INF
        Set DlgText = $(DlgText2)
    Else-Ifstr(i) $(!STF_PRODUCT) == "LANMANNT"
        ;  Primary installation, Advanced Server
        Set DlgText = $(DlgTextLm)
        Set Cancel = $(ExitSetup)
    Else
        ;  Primary installation, Windows NT or Dedicated Server
        Set Cancel = $(ExitNoNet)
    Endif

    Set !STF_NCDETINFO = {}

    ui start "System"

    ifstr(i) $(DLGEVENT) == "CONTINUE"
        Debug-Output "NTLANMAN.INF: CONTINUE message from adapter dialog"

        ; Find out the option which changed.
        ;
        ifstr(i) $(Combo1Out) == $(None)

            ;  Verify that this is REALLY what the user wants

            Shell "" QueryNoNic $(!STF_LANGUAGE)
            Ifstr(i) $($ShellCode) != $(!SHELL_CODE_OK)
               Debug-Output "NTLANMAN.INF: SHELL ERROR: "$($ShellCode)
            Endif
            Ifstr(i) $($R0) == "OK"
                set AdapterOption = NONE
                set AdapterInstall = "NO"
                ui pop 1
                goto install_adapter
            Endif

            set ReInit = NO
            goto adapter

        else-ifstr(i) $(Combo1Out) != $(Other)
            set AdapterOption = *($(AdapterOptionList), ~($(Combo1List), $(Combo1Out)))
            ui pop 1
            goto install_adapter
        else
            Debug-Output "NTLANMAN.INF: Chose OTHER; calling GetNewOEMOption..."
            shell "OTHER.INF" GetNewOEMMultiOption $(!STF_LANGUAGE) +
                $(AdapterOemINFOptions) NetAdapter +
                $(AdapterDisketteSrc) $(OptionalDlgText)
            set ReInit = YES
            ifstr(i) $($R0) == STATUS_SUCCESSFUL
                Debug-Output "NTLANMAN.INF: GetNewOEMOption successful"
                ;
                ; extract the new variables
                ;
                set AdapterOemINFOptions  = $($R1)
                set AdapterOption         = $($R2)
                set AdapterDisketteSrc    = $($R4)
                ;
                ; Merge our options with the oem options
                ;
                shell "" MergeOptions $(AdapterOurINFOptions) $(AdapterOemINFOptions)
                ifstr(i) $($R0) == STATUS_SUCCESSFUL
                    set AdapterMergedOptions = {$($R1), $($R2)}
                else
                    shell "SUBROUTN.INF" SetupMessage $(!STF_LANGUAGE) "FATAL" $(Error4)
                    ui pop 1
                    goto finish_adapter
                endif

                ;
                ; Initialise the listbox vars
                ;
                shell "" InitListBoxVars $(!STF_LANGUAGE) $(AdapterMergedOptions) $(AdapterSpecialOption) $(Other) $(None)
                ifstr(i) $($R0) == "STATUS_SUCCESSFUL"
                    set AdapterOptionList     = $($R1)
                    set AdapterOptionTextList = $($R2)
                else
                    shell "SUBROUTN.INF" SetupMessage $(!STF_LANGUAGE) "FATAL" $(Error2)
                    ui pop 1
                    goto  finish_adapter
                endif

                ui pop 1
                goto install_adapter

            else-ifstr(i) $($R0) == "STATUS_USERCANCEL"
                Debug-Output "NTLANMAN.INF: GetNewOEMOption user cancelled"
                goto adapter
            else
                Debug-Output "NTLANMAN.INF: GetNewOEMOption other error"
                shell "SUBROUTN.INF" SetupMessage $(!STF_LANGUAGE) "NONFATAL" $(Error3)
                goto adapter
            endif

        endif

        set ReInit = NO
        goto adapter

    else-ifstr(i) $(DLGEVENT) == "BACK"
        set ExitChoice = "OK"

        ifstr(i) $(!NTN_Origination) != "NCPA"
            Debug-Output "NTLANMAN.INF: EXIT button: see if user wants to quit"
            Shell "" QueryUserQuit $(!STF_LANGUAGE)

            Ifstr(i) $($ShellCode) != $(!SHELL_CODE_OK)
               Debug-Output "NTLANMAN.INF: SHELL ERROR: "$($ShellCode)
            Endif

            Set Status = $($R0)
            Debug-Output "NTLANMAN.INF: QueryUserQuit returned "$(Status)
        Else
            Set Status = STATUS_USERCANCEL
        endif

        ifstr(i) $(Status) != STATUS_SUCCESSFUL
            Debug-Output "NTLANMAN.INF: Quitting [InitialAdapterInstall]"
            ui pop 1
            goto finish_adapter
        else
            set  ReInit = NO
            goto adapter
        endif
    else
        ui pop 1
        goto finish_adapter
    endif

install_adapter = +
    Debug-Output "NTLANMAN.INF: Adapter option is "$(AdapterOption)

    ;
    ; See if the option is NONE; skip out if so
    ;
    Ifstr(i) $(AdapterOption) == NONE
        Set Status = STATUS_SUCCESSFUL
        goto skip_setinstall
    Endif

    ;
    ; See if option has changed
    ;
    set Changed = YES
    ifstr(i) $(AdapterOption) == *($(AdapterCurrentOption), 1)
        set Changed = NO
    endif

    set AdapterInstall = YES

    ;
    ; check special option first... skip
    ;

    ifstr(i) $(AdapterSpecialOption) != {}
        ifstr(i) $(AdapterOption) == *($(AdapterSpecialOption), 1)
            goto skip_setinstall
        endif
    endif

    ; choose file name and path based upon origin

    set AdapterSrcDir = $(AdapterDisketteSrc)

    shell "" GetOptionFile $(AdapterOption) $(AdapterOemINFOptions)
    ifstr(i) $($R0) == "STATUS_SUCCESSFUL"
        set AdapterINF = $(!STF_WINDOWSSYSPATH)"\"$($R1)
        set AdapterSrcDir = $(AdapterDisketteSrc)
        ;
        ;  For both IDW and OEM, force "do copy" and "add copy" back to YES
        ;
        Set !STF_SRCDIR_OVERRIDE = $(AdapterSrcDir)
        Set !NtLmDoCopy = "YES"
        Set !NtLmAddCopy = "YES"
        goto skip_setinstall
    endif

    ;
    ; check if our option
    ;

    shell "" GetOptionFile $(AdapterOption) $(AdapterOurINFOptions)
    ifstr(i) $($R0) == "STATUS_SUCCESSFUL"
        set AdapterINF = $($R1)
        set AdapterSrcDir = $(!STF_SRCDIR)
    endif

skip_setinstall = +

    ifstr(i) $(AdapterInstall) == YES

        ifstr(i)  $(AdapterINF) != ""
            read-syms Billboard8$(!STF_LANGUAGE)

            Shell "subroutn.inf" PushBillboard NETSTATUSDLG $(Status)

            set TempGuiUnattended = $(!STF_GUI_UNATTENDED)
            ifstr(i) $(!AutoNetOption) == ""
                set !STF_GUI_UNATTENDED = NO
            endif
            shell $(AdapterINF) InstallOption $(!STF_LANGUAGE) $(AdapterOption) $(AdapterSrcDir) +
                  $(!NtLmAddCopy) $(!NtLmDoCopy) $(!NtLmDoConfig)
            Set Status = $($R0)
            set !STF_GUI_UNATTENDED = $(TempGuiUnattended)
            Set !STF_SRCDIR_OVERRIDE = ""

            Shell "subroutn.inf" PopBillboard
            Ifstr(i) $(Status) == STATUS_USERCANCEL
                Goto adapter
            Endif
        endif
    endif

    goto finish_adapter

adapter_shell_error = +
    set Status = STATUS_FAILED
;
;  At this point, $(Status) is one of:
;
;     STATUS_SUCCESSFUL
;     STATUS_USERCANCEL
;     STATUS_EXITNET   (only if main installation)
;     STATUS_WANTRAS   (if RAS was chosen as netcard option)
;
finish_adapter = +
    Ifstr(i)  $(AdapterSrcDir) != ""
        Ifstr(i)  $(AdapterSrcDir) != $(!STF_SRCDIR)
            Set !STF_SRCDIR_OVERRIDE = $(AdapterSrcDir)
        Endif
    Endif

    Return $(Status)

;-----------------------------------------------------------------------
;-----------------------------------------------------------------------
;-----------------------------------------------------------------------
;-----------------------------------------------------------------------
;-----------------------------------------------------------------------
;-----------------------------------------------------------------------
;-----------------------------------------------------------------------
;-----------------------------------------------------------------------
;  GenMergeLists
;
;    Merge any two lists:
;
; INPUTS:     $0   list A
;             $1   list B
;
; OUTPUTS:    $R0  list (A+B)
;
[GenMergeLists]
    ForListDo $($1)
        Set $0 = >($($0),$($))
    EndForListDo

    Return $($0)


[OemSoftVars]
    OemSoftHardwareDetected      = ""
    OemSoftSystemSet             = ""
    OemSoftDefault               = ""
    OemSoftOurINFOptions         = {}
    OemSoftOemINFOptions         = {}
    OemSoftMergedOptions         = {}
    OemSoftSpecialOption         = {}
    OemSoftCurrentOption         = {}

    OemSoftOptionList            = {}
    OemSoftOptionTextList        = {}
    OemSoftOption                = {}
    OemSoftINF                   = ""
    OemSoftInstall               = "NO"
    OemSoftSrcDir                = ""
    OemSoftDstDir                = ""

[OemSoftTypes]
    NDR = NetDriver,    ndr
    NXP = NetTransport, nxp
    NSV = NetService,   nsv
    NWK = Network,      nwk
    NPR = NetProvider,  npr

[OemSoftwareInstall]
    Debug-Output "NTLANMAN.INF: Begin OEM software installation"
    ;
    ;
    StartWait

    set Status = STATUS_FAILED
    read-syms OemOptionDiskette$(!STF_LANGUAGE)
    read-syms Strings$(!STF_LANGUAGE)
    read-syms ProgressCopy$(!STF_LANGUAGE)

    Shell "subroutn.inf" ReadSetupHelpIds
    SetHelpFile "setupnt.hlp" $(!MinimumID) $(!MaximumID)

    read-syms OemSoftVars

    ;
    ;  Set the Copy and Config flags based upon whether
    ;  the NCPA called us or this is main installation
    ;
    Set !NtLmDoCopy   = "YES"
    Set !NtLmAddCopy  = "YES"
    Set !NtLmDoConfig = "NO"

    Ifstr(i) $(!NTN_Origination) == "ncpa"
        ;  Secondary installation
        Ifstr(i) $(!STF_IDW) == "TRUE"
            Set !NtLmAddCopy  = "NO"
            Set !NtLmDoCopy   = "NO"
        Endif
    Else
        ;  Primary installation
        Set !NtLmDoCopy   = "NO"
        Ifstr(i) $(!STF_IDW) == "TRUE"
            Set !NtLmAddCopy  = "NO"
        Endif
    Endif


    Set OemSoftTypeNames = ^(OemSoftTypes,1)
    Set OemSoftTypeIds   = ^(OemSoftTypes,2)
    EndWait

    ;
    ; initialize all the OEM software option vars
    ;
    read-syms Billboard9$(!STF_LANGUAGE)
    Shell "subroutn.inf" PushBillboard NETSTATUSDLG $(Status)
    StartWait

    shell "" InitOptionVars $(!STF_LANGUAGE) $(OemSoftTypeNames) $(OemSoftHardwareDetected) $(OemSoftSystemSet) $(OemSoftDefault)
    ifstr(i) $($R0) == "STATUS_SUCCESSFUL"
        set OemSoftOurINFOptions = $($R1)
        set OemSoftOemINFOptions = $($R2)
        set OemSoftMergedOptions = $($R3)
        set OemSoftSpecialOption = $($R4)
        set OemSoftCurrentOption = $($R5)
        set OemSoftOption        = *($($R5), 1)
    else
        EndWait
        Shell "subroutn.inf" PopBillboard
        shell "SUBROUTN.INF" SetupMessage $(!STF_LANGUAGE) "FATAL" $(Error1)
        goto finish_oemsoft
    endif

    EndWait
    Shell "subroutn.inf" PopBillboard
    StartWait
    ;
    ; Initalize the listbox vars
    ;
    shell "" InitListBoxVars $(!STF_LANGUAGE) $(OemSoftMergedOptions) $(OemSoftSpecialOption) $(Other) ""

    ifstr(i) $($R0) == "STATUS_SUCCESSFUL"
        set OemSoftOptionList     = $($R1)
        set OemSoftOptionTextList = $($R2)
    else
        EndWait
        shell "SUBROUTN.INF" SetupMessage $(!STF_LANGUAGE) "FATAL" $(Error2)
        goto  finish_oemsoft
    endif

    read-syms DialogConstants
    EndWait

oemsoft = +

    read-syms QueryOemSoft$(!STF_LANGUAGE)

    ui start "System"

    ifstr(i) $(DLGEVENT) == "CONTINUE"
        Debug-Output "NTLANMAN.INF: CONTINUE message from OEM software dialog"
        ;
        ; Find out the option which changed.
        ;
        ifstr(i) $(Combo1Out) != $(Other)
            set OemSoftOption = *($(OemSoftOptionList), ~($(Combo1List), $(Combo1Out)))
            Debug-Output "NTLANMAN.INF: Changed to choice "$(OemSoftOption)
            ui pop 1
            goto install_oemsoft
        else
            Debug-Output "NTLANMAN.INF: Chose OTHER; calling GetNewOEMMultiOption..."
            shell "OTHER.INF" GetNewOEMMultiOption $(!STF_LANGUAGE) $(OemSoftOemINFOptions) $(OemSoftTypeNames) $(OemSoftDisketteSrc) $(OptionalDlgText)
            Set ReInit = YES
            ifstr(i) $($R0) == STATUS_SUCCESSFUL
                Debug-Output "NTLANMAN.INF: GetNewOEMOption successful"
                ;
                ; extract the new variables
                ;
                set OemSoftOemINFOptions  = $($R1)
                set OemSoftOption         = $($R2)
                set OemSoftDisketteSrc    = $($R4)
                ;
                ; Merge our options with the oem options
                ;
                shell "" MergeOptions $(OemSoftOurINFOptions) $(OemSoftOemINFOptions)
                ifstr(i) $($R0) == STATUS_SUCCESSFUL
                    set OemSoftMergedOptions = {$($R1), $($R2)}
                else
                    shell "SUBROUTN.INF" SetupMessage $(!STF_LANGUAGE) "FATAL" $(Error4)
                    ui pop 1
                    goto finish_oemsoft
                endif

                ;
                ; Initialise the listbox vars
                ;
                shell "" InitListBoxVars $(!STF_LANGUAGE) $(OemSoftMergedOptions) $(OemSoftSpecialOption) $(Other) ""
                ifstr(i) $($R0) == "STATUS_SUCCESSFUL"
                    set OemSoftOptionList     = $($R1)
                    set OemSoftOptionTextList = $($R2)
                else
                    shell "SUBROUTN.INF" SetupMessage $(!STF_LANGUAGE) "FATAL" $(Error2)
                    ui pop 1
                    goto  finish_oemsoft
                endif

                ui pop 1
                goto install_oemsoft

            else-ifstr(i) $($R0) == "STATUS_USERCANCEL"
                Debug-Output "NTLANMAN.INF: GetNewOEMOption user cancelled"
                goto oemsoft
            else
                Debug-Output "NTLANMAN.INF: GetNewOEMOption other error"
                shell "SUBROUTN.INF" SetupMessage $(!STF_LANGUAGE) "NONFATAL" $(Error3)
                goto oemsoft
            endif

        endif

        set ReInit = NO
        goto oemsoft

    else-ifstr(i) $(DLGEVENT) == "BACK"
        set Status = STATUS_USERCANCEL
        ui pop 1
        goto finish_oemsoft
    else
        ui pop 1
        goto finish_oemsoft
    endif

install_oemsoft = +
    ;
    ; See if option has changed
    ;
    set Changed = YES
    ifstr(i) $(OemSoftOption) == *($(OemSoftCurrentOption), 1)
        set Changed = NO
    endif

    ;
    ; If option has not changed and we are SETUPBOOTED mode then skip
    ;
    ifstr(i) $(Changed) == "NO"
        ifstr(i) $(!STF_INSTALL_TYPE) == "SETUPBOOTED"
            set OemSoftInstall = "NO"
            goto skip_setinstall
        endif
    endif
    set OemSoftInstall = "YES"

    ;
    ; check special option first
    ;

    ifstr(i) $(OemSoftSpecialOption) != {}
        ifstr(i) $(OemSoftOption) == *($(OemSoftSpecialOption), 1)
            goto skip_setinstall
        endif
    endif

    ; choose file name and path based upon origin

    set OemSoftSrcDir = $(OemSoftDisketteSrc)

    shell "" GetOptionFile $(OemSoftOption) $(OemSoftOemINFOptions)
    ifstr(i) $($R0) == "STATUS_SUCCESSFUL"
        set OemSoftINF = $(!STF_WINDOWSSYSPATH)"\"$($R1)
        set OemSoftSrcDir = $(OemSoftDisketteSrc)
        ;
        ;  For both IDW and OEM, force "do copy" and "add copy" back to YES
        ;
        Set !STF_SRCDIR_OVERRIDE = $(OemSoftSrcDir)
        Set !NtLmDoCopy = "YES"
        Set !NtLmAddCopy = "YES"
        goto skip_setinstall
    endif

    ; check if our option

    shell "" GetOptionFile $(OemSoftOption) $(OemSoftOurINFOptions)
    ifstr(i) $($R0) == "STATUS_SUCCESSFUL"
        set OemSoftINF = $($R1)
        set OemSoftSrcDir = $(!STF_SRCDIR)
        goto skip_setinstall
    endif

skip_setinstall = +

    ifstr(i) $(OemSoftInstall) == "YES"
        Ifstr(i) $(!NCPA_HANDLE) == ""
            LoadLibrary "y" $(!STF_CWDDIR)ncpa.cpl !NCPA_HANDLE
        Endif

        ifstr(i)  $(OemSoftINF) != ""

            shell $(OemSoftINF) InstallOption $(!STF_LANGUAGE) $(OemSoftOption) $(OemSoftSrcDir) +
                  $(!NtLmAddCopy) $(!NtLmDoCopy) $(!NtLmDoConfig)

            Set !STF_SRCDIR_OVERRIDE = ""
            Set Status = $($R0)

            Ifstr(i) $(Status) == STATUS_USERCANCEL
                Goto oemsoft
            Endif
        endif
    endif

finish_oemsoft = +

    Ifstr(i)  $(OemSoftSrcDir) != ""
        Ifstr(i)  $(OemSoftSrcDir) != $(!STF_SRCDIR)
            Set !STF_SRCDIR_OVERRIDE = $(OemSoftSrcDir)
        Endif
    Endif

    Return $(Status)



;-----------------------------------------------------------------------
;
; ROUTINE:      InitOptionVars
;
; DESCRIPTION:  This routine intialises the values for the option we are
;               dealing with.  It finds out the options supported by setup.
;               It also sees if there is an OEM INF in the windows system
;               directory which represents this option.  If so it reads in
;               the options supported by this INF and then forms a merged
;               list from the two.
;
; INPUTS:       $0:  Language to use
;               $1:  OptionTypeList; e.g.,  { NetDriver, NetTransport }
;               $2:  Hardware detected option
;               $3:  Software set option
;               $4:  Default value for option
;
; OUTPUTS:      $R0: STATUS:   STATUS_SUCCESSFUL |
;                              STATUS_FAILED
;
;               $R1: OurINFOptions var {{filename, {OptionList}, {OptionTextList}}}
;               $R2: OemINFOptions var {{filename, {OptionList}, {OptionTextList}}, etc}
;               $R3: Merged INF Options {{OptionList}, {OptionTextList}}
;               $R4: Special Options {Option, OptionText}
;               $R5: Current Option {Option, OptionText}
;
;------------------------------------------------------------------------
[InitOptionVars]

    Debug-Output "NTLANMAN.INF: InitOptionVars called"

    set Status           = STATUS_FAILED
    set OurINFOptions    = {}
    set OemINFOptions    = {}
    set MergedINFOptions = {}
    set SpecialOption    = {}
    set CurrentOption    = {}
    Set IovTypeList      = $($1)

    ;
    ; Determine all Oem options for all types given.  These
    ; are considered to be "our" options, as opposed to newly
    ; added INF files, which are "oem".
    ;
    ForListDo $(IovTypeList)
        Debug-Output "NTLANMAN.INF: Get options for type "$($)
        shell "OTHER.INF" ReturnOemOptions $($0) $($) TRUE
        ifstr(i) $($R0) == "STATUS_SUCCESSFUL"
            Debug-Output "NTLANMAN.INF: Other OEM options found for type "$($)
            shell "" GenMergeLists $(OurINFOptions) $($R1)
            set OurINFOptions = $($R0)
        endif
    EndForListDo
    ;
    ; Merge the two and set the merged list
    ;
    shell "" MergeOptions $(OurINFOptions) $(OemINFOptions)
    ifstr(i) $($R0) == STATUS_SUCCESSFUL
        set MergedINFOptionList     = $($R1)
        set MergedINFOptionTextList = $($R2)
        set MergedINFOptions        = {$($R1), $($R2)}
    else
        Debug-Output "NTLANMAN.INF: InitOptionVars: MergeOptions failed"
        goto finish_InitOptionVars
    endif

    ;
    ; Form current option.
    ;
    ; Algorithm:
    ;
    ; Check software set value.  If this doesn't exist get hardware detected
    ; value. If not detected set value to default.
    ;
    set Option = ""
    ifstr(i) $($3) != ""
        set Option = $($3)
    else
        ifstr(i) $($2) != ""
            set Option = $($2)
        else-ifstr(i) $($4) == ""
            set Option = ""
        else
            set Option = $($4)
        endif
    endif

    ;
    ; Check Option against all the options supported
    ; If found set Current Option, else set the special options var
    ; and set this to the current option.
    ;

    ifstr(i) $(Option) == ""
        set OptionText = ""
    else-ifcontains(i) $(Option) in $(MergedINFOptionList)
        set OptionText = *($(MergedINFOptionTextList), ~($(MergedINFOptionList), $(Option)))
    else
        set OptionText    = $(Option)
        set Option        = "OEMINSTALLEDOPTION"
        set SpecialOption = {$(Option), $(OptionText)}
    endif

    set CurrentOption = {$(Option), $(OptionText)}
    set Status = STATUS_SUCCESSFUL

finish_InitOptionVars = +
    Debug-Output "NTLANMAN.INF::InitOptionVars complete "

    Return $(Status) $(OurINFOptions) $(OemINFOptions) $(MergedINFOptions) $(SpecialOption) $(CurrentOption)


;-------------------------------------------------------------------------
;
; ROUTINE:      InitListBoxVars
;
; DESCRIPTION:  This routine initialises the option list and the option text
;               list to be displayed to the user.
;
; INPUTS:       $0: Language
;               $1: MergedINFOptions
;               $2: SpecialOption
;               $3: OtherOption
;               $4: NoneOption
;
; OUTPUTS:      $R0: STATUS: STATUS_FAILED |
;                            STATUS_SUCCESSFUL
;
;               $R1: OptionList
;               $R2: OptionTextList
;
;----------------------------------------------------------------------------
[InitListBoxVars]

    Debug-Output "NTLANMAN.INF::InitListBoxVars invoked"

    set Status         = STATUS_FAILED
    set OptionList     = {}
    set OptionTextList = {}
    Set OptOther       = $($3)
    Set OptNone        = $($4)
    Set UtilityInf     = "UTILITY.INF"

    ;
    ; Process the standard options
    ;

    ifstr(i) $($1) != {}
        set OptionList     = *($($1), 1)
        set OptionTextList = *($($1), 2)
    endif

    ;
    ; Process the special option if present
    ;

    ifstr(i) $($2) != {}
        set OptionList     = >($(OptionList),     *($($2), 1))
        set OptionTextList = >($(OptionTextList), *($($2), 2))
    endif
    ;
    ; Sort the lists ascending, case-insensitive
    ;
    Shell $(UtilityInf) SortListIndex $(OptionTextList) TRUE FALSE
    Set IndexList = $($R0)
    Shell $(UtilityInf) SortByIndex $(OptionTextList) $(IndexList)
    Set OptionTextList = $($R0)
    Shell $(UtilityInf) SortByIndex $(OptionList) $(IndexList)
    Set OptionList = $($R0)

    ;
    ; Add the "other" and "none" options only to the text list
    ;  (if present)
    ;
    Ifstr(i) $(OptOther) != ""
        set OptionTextList = >($(OptionTextList), $(OptOther))
    Endif
    Ifstr(i) $(OptNone) != ""
        set OptionTextList = >($(OptionTextList), $(OptNone))
    Endif

    set Status = STATUS_SUCCESSFUL

    Return $(Status) $(OptionList) $(OptionTextList)


;-----------------------------------------------------------------------
;
; ROUTINE:      MergeOptions
;
; DESCRIPTION:  This merges the option lists to form the master list of
;               options and optiontext.
;
; INPUTS:       $0:  OurOptionList
;               $1:  OemOptionList
;
; OUTPUTS:      $R0: STATUS:   STATUS_SUCCESSFUL  |
;                              STATUS_FAILED
;
;               $R1: MergedOptionList
;               $R2: MergedOptionTextList
;
;
;------------------------------------------------------------------------
[MergeOptions]

    Debug-Output "NTLANMAN.INF: MergeOptions called"

    set Status               = STATUS_FAILED
    set MergedOptionList     = {}
    set MergedOptionTextList = {}

    ;
    ; First merge our options in
    ;

    ForListDo $($0)
        set OptionList     = *($($), 2)
        set OptionTextList = *($($), 3)
        ForListDo $(OptionList)
            Ifcontains(i) $($) in $(MergedOptionList)
            else
                set MergedOptionList     = >($(MergedOptionList), $($))
                set MergedOptionTextList = >($(MergedOptionTextList), *($(OptionTextList), $(#)))
            endif
        EndForListDo
    EndForListDo


    ;
    ; Then merge the oem options in
    ;

    ForListDo $($1)
        set OptionList     = *($($), 2)
        set OptionTextList = *($($), 3)
        ForListDo $(OptionList)
            Ifcontains(i) $($) in $(MergedOptionList)
            else
                set MergedOptionList     = >($(MergedOptionList), $($))
                set MergedOptionTextList = >($(MergedOptionTextList), *($(OptionTextList), $(#)))
            endif
        EndForListDo
    EndForListDo

    set Status = STATUS_SUCCESSFUL
    Return $(Status) $(MergedOptionList) $(MergedOptionTextList)


;-----------------------------------------------------------------------
;
; ROUTINE:      GetOptionFile
;
; DESCRIPTION:  Given the Option list and the current option, determines
;               if the current option is a supported option and returns the
;               file representing the option
;
; INPUTS:       $0:  OptionChosen
;               $1:  OptionList {{filename, {optionlist}, {optiontextlist}}
;
; OUTPUTS:      $R0: STATUS:   STATUS_SUCCESSFUL   |
;                              STATUS_FILENOTFOUND |
;                              STATUS_FAILED
;
;               $R1: FileName
;
;------------------------------------------------------------------------
[GetOptionFile]

    Debug-Output "NTLANMAN.INF: GetOptionFile called"

    set Status      = STATUS_FILENOTFOUND
    set FileName = ""
    ;
    ForListDo $($1)
        set OptionFile = *($($), 1)
        set OptionList = *($($), 2)
        ForListDo $(OptionList)
            ifstr(i) $($) == $($0)
                set Status = STATUS_SUCCESSFUL
                set FileName = $(OptionFile)
            endif
        EndForListDo
    EndForListDo

finish_GetOptionFile = +
    Debug-Output "NTLANMAN.INF: GetOptionFile status "$(Status)"; file: "$(FileName)
    Return $(Status) $(FileName)

;-----------------------------------------------------------------------
; ROUTINE:      QueryUserQuit
;
; DESCRIPTION:  This routine queries whether the user wants to quit
;               networking setup.  Three choices are allowed:
;
;                   OK     means cancel the installation operation
;                   CANCEL means cancel
;
;
; INPUTS:       $0:  Language To Use
;
; OUTPUTS:      $R0:  STATUS_EXITNET    if OK in WinNT
;                     STATUS_USERCANCEL if OK in LanmanNT (AS)
;                     STATUS_SUCCESSFUL if CANCEL  (continue installation)
;
;------------------------------------------------------------------------
[QueryUserQuit]
    Set Status = STATUS_SUCCESSFUL
    Set StatusOK = STATUS_USERCANCEL




    Ifstr(i) $(!STF_PRODUCT) == "LANMANNT"
        read-syms LmExitWarningDlg$($0)
    Else
        Set StatusOK = STATUS_EXITNET
        read-syms ExitWarningDlg$($0)
    Endif


    ui start "MessageBox"
    Ifstr(i) $(DLGEVENT) == "OK"
        Set Status = $(StatusOK)
    Endif

fin_QueryUserQuit = +
    Return $(Status)

;-----------------------------------------------------------------------
; ROUTINE:      QueryNcpaRetry
;
; DESCRIPTION:  This routine queries whether the user wants to return
;               to the NCPA to attempt to make his netork operate.
;
;                   YES    means return to NCPA for another try
;                   NO     means continue the installation
;
;
; INPUTS:       $0:  Language To Use
;
; OUTPUTS:      $R0:  STATUS_SUCCESSFUL if YES
;                     STATUS_USERCANCEL if NO
;
;------------------------------------------------------------------------
[QueryNcpaRetry]
    Set Status = STATUS_SUCCESSFUL

    read-syms NcpaRetryDlg$($0)

    ui start "MessageBox"
    Ifstr(i) $(DLGEVENT) != "YES"
        Set Status = STATUS_USERCANCEL
    Endif

    Return $(Status)

;-----------------------------------------------------------------------
; ROUTINE:      QueryNoNic
;
; DESCRIPTION:  This routine queries whether the user really wants
;               the "None" network card choice.
;
; INPUTS:       $0:  Language To Use
;
; OUTPUTS:      $R0: OK or CANCEL
;
;------------------------------------------------------------------------
[QueryNoNic]
    read-syms NoNicWarningDlg$($0)
    ui start "MessageBox"
    return $(DLGEVENT)


;-----------------------------------------------------------------------
; ROUTINE:      InstallLmNetFiles
;
; DESCRIPTION:  Function called by NTLMINST.INF to install network files.
;
; INPUTS:       none
;
; OUTPUTS:      $R0: STATUS_SUCCESSFUL
;                 or STATUS_USERCANCEL
;                 or STATUS_FAILED
;
;------------------------------------------------------------------------
[InstallLmNetFiles]
   read-syms GeneralConstants
   read-syms DestNetPathNames
   Set Status = STATUS_FAILED

   Shell $(UtilityInf), DoAskSource, $(!STF_CWDDIR), $(!STF_SRCDIR) NO

   Ifint $($ShellCode) != $(!SHELL_CODE_OK)
       Goto ILMNF_Return
   Else-Ifstr(i) $($R0) == STATUS_FAILED
       Goto ILMNF_Return
   Else-Ifstr(i) $($R0) == STATUS_USERCANCEL
       Set Status = $($R0)
       Goto ILMNF_Return
   Endif

   Set !STF_SRCDIR = $($R1)

   Set Status = STATUS_SUCCESSFUL

ILMNF_Return = +
   Return $(Status)



;-----------------------------------------------------------------------
;
; ROUTINE:      InstallOemHook
;
; DESCRIPTION:  Install the INF file OEMHOOK.INF, which contains
;               whatever network alterations and enhancements the
;               OEM requires.
;
;               Since this file is not required, no error checking
;               is done.
;
; INPUTS:       None
;
; OUTPUTS:      $R0: STATUS:   STATUS_SUCCESSFUL   always
;
;------------------------------------------------------------------------
[InstallOemHook]
    Set InfName = "OEMHOOK.INF"

    Debug-Output "NTLANMAN.INF: Installing OEMHOOK.INF if present"

    Shell $(InfName) InstallOption $(!STF_LANGUAGE) $(InfOption) $(!STF_SRCDIR) "YES" "NO" "NO"

IHK_Exit = +
    Return STATUS_SUCCESSFUL

















































;-----------------------------------------------------------------------
;
; ROUTINE:      BuildNcpaCommandLine
;
; DESCRIPTION:  Construct the command line for the NCPA
;
; INPUTS:       $0: Install mode: CUSTOM, EXPRESS, RETRY
;
; OUTPUTS:      $R0: value to pass to NCPA for setup-related functions
;
;------------------------------------------------------------------------
[BuildNcpaCommandLine]
   Set CommandLine = " /t STF_PRODUCT = "$(!STF_PRODUCT)
   Set CommandLine = " /t STF_COMPUTERNAME = """$(!STF_COMPUTERNAME)""""$(CommandLine)
   Set CommandLine = " /t STF_USERNAME = """$(!STF_USERNAME)""""$(CommandLine)
   Set CommandLine = " /t STF_INSTALL_MODE = "$($0)$(CommandLine)
   Set CommandLine = " /t STF_SRCDIR = "$(!STF_SRCDIR)$(CommandLine)

   Ifstr(i) $(!STF_IDW) == TRUE
       Set CommandLine = " /t STF_IDW = "$(!STF_IDW)$(CommandLine)
   Endif

   return $(CommandLine)

;-----------------------------------------------------------------------
;
; ROUTINE:      StartDetection
;
; DESCRIPTION:  Start the newly installed netcard detection service
;
;
; INPUTS:       None
;
; OUTPUTS:      $R0: STATUS:   STATUS_SUCCESSFUL   always
;
;------------------------------------------------------------------------
[StartDetection]
    Set UtilityInf   = "UTILITY.INF"
    Set ServiceName  = "NETDETECT"
    Set ReturnStatus = STATUS_SUCCESSFUL

    Debug-Output "NTLANMAN.INF: Starting the netcard detection service"

    Set FLibraryErrCtl = 1
    LibraryProcedure StartResult $(!NCPA_HANDLE), CPlSetup $(!STF_HWND), STARTSVC, $(ServiceName)
    Set FLibraryErrCtl = 0

    Set StartStatus = *($(StartResult),1)
    Debug-Output "NTLANMAN.INF: NETDETECT status was: "$(StartStatus)

    ;  Check that it started or is already running

    Ifint $(StartStatus) != 0
       Ifint $(StartStatus) != 1056
           Set ReturnStatus = STATUS_FAILED
       Endif
    Endif

    ;  Update the netcard detection DLL name list

    Shell $(UtilityInf) UpdateDetectionDllNames

IHK_Exit = +
    Return $(ReturnStatus)


;-----------------------------------------------------------------------
;
; ROUTINE:      WarnDetectStart
;
; DESCRIPTION:  Warn the user that netcard detection is about to start
;
; INPUTS:       None
;
; OUTPUTS:      $R0: STATUS:   STATUS_SUCCESSFUL   if detection desired
;                              STATUS_FAILED       if undesirable
;
;------------------------------------------------------------------------
[WarnDetectStart]
    Set Result = STATUS_SUCCESSFUL
    Read-syms WarnDetectDlg$(!STF_LANGUAGE)

    ui start "Info"

    Ifstr(i) $(DLGEVENT) != CONTINUE
        Set Result = STATUS_FAILED
    Endif

    ui pop 1
    Return $(Result)

;-----------------------------------------------------------------------
;
; ROUTINE:      WarnDetectAccept
;
; DESCRIPTION:  Warn the user that netcard detection is about to start
;
; INPUTS:       $0:  Name of netcard found
;
; OUTPUTS:      $R0: STATUS:   STATUS_SUCCESSFUL   if card is OK
;                              STATUS_FAILED       if detection is to cease
;                              STATUS_TRY_AGAIN    if another card is to be found
;
;------------------------------------------------------------------------
[WarnDetectAccept]
    Set Result = STATUS_SUCCESSFUL
    Set DlgData = $($0)
    Read-syms WarnDetectAccept$(!STF_LANGUAGE)
    ui start "Info"

    Ifstr(i) $(DLGEVENT) == EXIT
        Set Result = STATUS_FAILED
    Else-Ifstr(i) $(DLGEVENT) == BACK
        Set Result = STATUS_TRY_AGAIN
    Else
        Set Result = STATUS_SUCCESSFUL
    Endif

    ui pop 1
    Return $(Result)

;-----------------------------------------------------------------------
;
; ROUTINE:      WarnDetectFail
;
; DESCRIPTION:  Warn the user that netcard detection has failed.
;               Allow reiteration
;
; INPUTS:       $0:  YES if a netcard was detected previously
;
; OUTPUTS:      $R0: STATUS:   STATUS_SUCCESSFUL   if user wants to stop
;                              STATUS_FAILED       if user wants to retry
;
;------------------------------------------------------------------------
[WarnDetectFail]
    Set FoundCard = $($0)
    Set Result = STATUS_SUCCESSFUL
    Read-syms WarnDetectFail$(!STF_LANGUAGE)
    Ifstr(i) $(FoundCard) != YES
        Read-syms WarnDetectFail2$(!STF_LANGUAGE)
    Endif

    ui start "Info"

    Ifstr(i) $(DLGEVENT) != CONTINUE
        Set Result = STATUS_FAILED
    Endif

    ui pop 1
    Return $(Result)

;-----------------------------------------------------------------------
;
; ROUTINE:      WarnCheckRas
;
; DESCRIPTION:  See if the user wants RAS installed.
;
; INPUTS:       None
;
; OUTPUTS:      $R0: STATUS:   STATUS_SUCCESSFUL   if continue to pick net card
;                              STATUS_WANTRAS      if RAS is to be installed
;
;------------------------------------------------------------------------
[WarnCheckRas]
    Set Result = STATUS_SUCCESSFUL
    Read-syms WarnInstallRas$(!STF_LANGUAGE)

    ui start "Info"

    Ifstr(i) $(DLGEVENT) != CONTINUE
        Set Result = STATUS_WANTRAS
    Endif

    ui pop 1
    Return $(Result)





















































;****************************************************************************
;                                                                           *
;     BDC Replication                                                       *
;                                                                           *
;****************************************************************************
[DoBDCReplication]
;
; read general constants, etc.
;
   read-syms GeneralConstants

   read-syms ProductTitleLanmanNt$(!STF_LANGUAGE)

   Ifstr(i) $(!NCPA_HANDLE) == ""
       LoadLibrary "x" $(!STF_CWDDIR)\ncpa.cpl !NCPA_HANDLE
   Endif

   Debug-Output "NTLANMAN.INF: Product title is: "$(!NetProductTitle)
   set-title $(!NetProductTitle)" Network Installation"
   Debug-Output "NTLANMAN.INF: Starting Netlogon..."
   Set FLibraryErrCtl = 1

   LibraryProcedure NCPA_RESULT $(!NCPA_HANDLE), CPlSetup $(!STF_HWND), STARTSVC, Netlogon

   Set NCPA_STATUS = *($(NCPA_RESULT),1)

   Debug-Output "NTLANMAN.INF: Start Netlogon; result was: "$(NCPA_STATUS)

   Ifint $(NCPA_STATUS) == 0
       LibraryProcedure NCPA_RESULT $(!NCPA_HANDLE), CPlSetup $(!STF_HWND), DOBDCREPL $(!STF_HWND)
       Set NCPA_STATUS = *($(NCPA_RESULT),1)
   Endif

   Ifint $(NCPA_STATUS) != 0

       LibraryProcedure NCPA_RESULT $(!NCPA_HANDLE), CPlSetup $(!STF_HWND), ERRORMSG, $(NCPA_STATUS)

       Set NCPA_ERROR_MESSAGE = *($(NCPA_RESULT),2)
       Debug-Output "NTLANMAN.INF: Error "$(NCPA_STATUS)" translated to: "$(NCPA_ERROR_MESSAGE)
       Read-syms WarningNoBDCRepl$(!STF_LANGUAGE)
       Set Error = $(NCPA_ERROR_MESSAGE)$(ErrorSuffix)
       read-syms WarningDlg$(!STF_LANGUAGE)
       ui start SetupMessage
   Endif

   Set FLibraryErrCtl = 0
   Return





;****************************************************************************
;                                                                           *
;     Network File Installation                                             *
;                                                                           *
;****************************************************************************
[Install-All-Files-Now]
    set !STF_NCPA_FLUSH_COPYLIST = TRUE
    CopyFilesInCopyList
    exit

























;***********************************************************************************************
;
; UpgradeNetwork - Upgrade all the network components.
;
;***********************************************************************************************

[UpgradeNetwork]
    ;
    ; Enable network card first
    ;
    Shell "" EnableNetworkComponents

    ;
    ; For each inf files upgrade
    ;
    Shell "" UpdateEachInf

    ;
    ; Change the card number from 0x to X
    ;
    LibraryProcedure STATUS, $(!NCPA_HANDLE), UpgradeCardNum

    ;
    ; Update SNA stuff
    ;
    LibraryProcedure STATUS, $(!NCPA_HANDLE), UpgradeSNA

    ;
    ; Remove some old inf files
    ;
    Shell "" RemoveOldInfFile "NWWKSTA", "NetService", "oemnsv", "oemnsvnw.inf"

    ;
    ; Popup NCPA to do the binding
    ;
    Shell "" BuildNcpaCommandLine "EXPRESS"
    Set NCPA_CMD_LINE = $($R0)
    Set NCPA_FUNC = NCPA

    LibraryProcedure NCPA_RESULT $(!NCPA_HANDLE),CPlSetup $(!STF_HWND), $(NCPA_FUNC), $(NCPA_CMD_LINE)

    return

;***********************************************************************************************
;
; EnableNetworkComponents - Enable all the network components.
;
;***********************************************************************************************

[EnableNetworkComponents]
    set MAXIMUM_ALLOWED = 33554432
    set NcpaName = "Software\Microsoft\Ncpa\CurrentVersion"
    OpenRegKey $(!REG_H_LOCAL) "" $(NcpaName) $(MAXIMUM_ALLOWED) KeyNcpa

    ifstr(i) $(KeyNcpa) != ""
        GetRegValue $(KeyNcpa),"DisableList", DisableListInfo
        set DisableList = *($(DisableListInfo),4)

        ForListDo $(DisableList)
            ;
            ; Enable each network component
            ;
            set ServiceName = "System\CurrentControlSet\Services\"$($)
            OpenRegKey $(!REG_H_LOCAL) "" $(ServiceName) $(MAXIMUM_ALLOWED) KeyService

            ifstr(i) $(KeyService) != ""
                GetRegValue $(KeyService),"OldStart", OldStartInfo
                set OldStart = *($(OldStartInfo),4)
                LibraryProcedure Result, $(!LIBHANDLE), SetupChangeServiceStart, $($), $(OldStart)
                ;
                ; Remove Old Start Value
                ;
                DeleteRegValue $(KeyService) "OldStart"
                CloseRegKey $(KeyService)
            endif
        EndForListDo
        DeleteRegValue $(KeyNcpa) "DisableList"
        CloseRegKey $(KeyNcpa)
    endif

    return

;***********************************************************************************************
;
; UpdateEachInf - Search the register for all the network components. Then
;                 update each one of them.
;
;***********************************************************************************************

[UpdateEachInf]
    read-syms UpgradeDialog$(!STF_LANGUAGE)
    set MAXIMUM_ALLOWED = 33554432
    set OptionList = {}
    set InfFileList = {}
    set ManufacturerList = { "Software\DigiBoard" , "Software\Microsoft" }
    ForListDo $(ManufacturerList)
        set SoftwareName = $($)
        OpenRegKey $(!REG_H_LOCAL) "" $(SoftwareName) $(MAXIMUM_ALLOWED) KeySoftware

        ifstr(i) $(KeySoftware) != ""
            EnumRegKey $(KeySoftware) SoftwareList
            ForListDo $(SoftwareList)
                ;
                ; Find all the network component
                ;
                set ComponentName = $(SoftwareName)"\"*($($),1)
                OpenRegKey $(!REG_H_LOCAL) "" $(ComponentName) $(MAXIMUM_ALLOWED) KeyComponent
                ifstr(i) $(KeyComponent) != ""
                    set NetRulesName = $(ComponentName)"\CurrentVersion\NetRules"
                    OpenRegKey $(!REG_H_LOCAL) "" $(NetRulesName) $(MAXIMUM_ALLOWED) KeyNetRules
                    ifstr(i) $(KeyNetRules) != ""
                        ;
                        ; Put the inf option and file into the list
                        ;
                        GetRegValue $(KeyNetRules),"InfName", InfNameInfo
                        GetRegValue $(KeyNetRules),"InfOption", InfOptionInfo
                        set ComponentInfName = *($(InfNameInfo),4)
                        set ComponentInfOption = *($(InfOptionInfo),4)

                        ;
                        ; Handle special case for NWCWorkstation and MCSXNS
                        ;
                        ifstr(i) $(ComponentInfOption) == "NWWKSTA"
                            ifstr(i) $(ComponentInfName) != "oemnsvnw.inf"
                                LibraryProcedure Status1, $(!LIBHANDLE), DelFile, $(!STF_WINDOWSSYSPATH)"\"$(ComponentInfName)
                                set ComponentInfName = "oemnsvnw.inf"
                                SetRegValue $(KeyNetRules) {InfName,$(NoTitle),$(!REG_VT_SZ),"oemnsvnw.inf"}
                            endif
                        endif

                        ifstr(i) $(ComponentInfOption) == "NWLINK"
                            set ComponentInfOption = "NWLNKIPX"
                            SetRegValue $(KeyNetRules) {InfOption,$(NoTitle),$(!REG_VT_SZ),"NWLNKIPX"}
                        endif

                        ifstr(i) $(ComponentInfOption) == "BLOODHOUND"
                            ifstr(i) $(ComponentInfName) != "oemnsvbh.inf"
                                LibraryProcedure Status1, $(!LIBHANDLE), DelFile, $(!STF_WINDOWSSYSPATH)"\"$(ComponentInfName)
                                set ComponentInfName = "oemnsvbh.inf"
                                SetRegValue $(KeyNetRules) {InfName,$(NoTitle),$(!REG_VT_SZ),"oemnsvbh.inf"}
                            endif
                            set ComponentInfOption = "NETMON"
                            SetRegValue $(KeyNetRules) {InfOption,$(NoTitle),$(!REG_VT_SZ),"NETMON"}
                        endif

			ifstr(i) $(ComponentInfOption) == "PCNTN3"
			    ;
			    ; remove the third party inf file
			    ;
                            LibraryProcedure Status1, $(!LIBHANDLE), DelFile, $(!STF_WINDOWSSYSPATH)"\"$(ComponentInfName)
			    set ComponentInfOption = "AMDPCI"
			    set ComponentInfName = "oemnadap.inf"
			endif

                        ifstr(i) $(ComponentInfOption) == "MCSXNS"
                            goto skipxns
                        endif

                        ifstr(i) $(ComponentInfOption) == "Ubnb"
                            goto skipxns
                        endif

                        Shell $(ComponentInfName) GetSignature
                        Ifstr(i) $($ShellCode) != $(!SHELL_CODE_OK)
                            goto skipxns
                        endif
                        ifstr(i) $($R0) != "MICROSOFT_FILE"
                            goto skipxns
                        endif

                        ifcontains(i) $(ComponentInfName) NOT-IN $(InfFileList)
                            ifstr(i) $(InfFileList) == {}
                                set InfFileList = {$(ComponentInfName)}
                                set OptionList = {$(ComponentInfOption)}
                            else
                                set InfFileList = >($(InfFileList),$(ComponentInfName))
                                set OptionList  = >($(OptionList),$(ComponentInfOption))
                            endif
                        endif
skipxns = +

                        CloseRegKey $(KeyNetRules)
                    endif
                    CloseRegKey $(KeyComponent)
                endif
            EndForListDo
            CloseRegKey $(KeySoftware)
        endif
    EndForListDo

    ; Upgrade all the component in the option list
    ;
    debug-output $(InfFileList)
    debug-output $(OptionList)

    set OldInstallMode = $(!NTN_InstallMode)
    set !NTN_InstallMode = "Update"
    set AddCopy = YES
    set DoCopy = YES
    set DoConfig = YES

    set Position = 1

    ForListDo $(InfFileList)
        debug-output $($)
        debug-output *($(OptionList), $(Position))

        Shell $($) "InstallOption" +
             $(!STF_LANGUAGE) *($(OptionList), $(Position)) +
             $(!STF_SRCDIR) $(AddCopy) $(DoCopy) $(DoConfig)

        Ifstr(i) $($ShellCode) != $(!SHELL_CODE_OK)
           Debug-Output "NCPASHEL.INF: SHELL ERROR: "$($ShellCode)
        Endif

        set-add Position = $(Position),1

    EndForListDo

    set !NTN_InstallMode = $(OldInstallMode)

    install "Install-UpdateFiles"

    return

;***********************************************************************************************
;
; RemoveoldInfFile - remove old inf file
; Entry: $0 - Option name (ie NWWKSTA)
;        $1 - Inf file type (ie, NetService)
;        $2 - inf prefix (ie oemnsv)
;        $3 - the new inf file to keep (ie oemnsvnw.inf)
;
;***********************************************************************************************

[OEMFiles]
    OemFiles = {} ? $(!LIBHANDLE) FindFileInstances $(!STF_WINDOWSSYSPATH)"\"$(Prefix)"*.inf"

[RemoveOldInfFile]
    set OptionName = $($0)
    set OptionType = $($1)
    set Prefix     = $($2)
    set CurrentInf = $($3)

    ;
    ; First get all the filenames
    ;
    set OemOptionList  = {}
    set InfToDelete    = {}
    read-syms OEMFiles
    detect OEMFiles

    ;
    ; Get the option from each file
    ;
    ForListDo $(OemFiles)
        ifstr(i) $($) != $(CurrentInf)
            set OemFileName = $(!STF_WINDOWSSYSPATH)"\"$($)
            shell "other.inf", GetOptionsFromINF $(!STF_LANGUAGE) $(OptionType) $(OemFileName)
            ifstr(i) $($R0) == STATUS_SUCCESSFUL
                ifcontains(i) $(OptionName) in $($R1)
                    set InfToDelete = >($(InfToDelete), $($))
                endif
            endif
        endif
    EndForListDo

    debug-output $(InfToDelete)

    ;
    ; del all the old files
    ;
    ForListDo $(InfToDelete)
        LibraryProcedure Status1, $(!LIBHANDLE), DelFile, $(!STF_WINDOWSSYSPATH)"\"$($)
    EndForListDo

    return

;***********************************************************************************************
;
; Install-UpdateFiles - Copy all the new network components files.
;
;***********************************************************************************************

[Install-UpdateFiles]
    set !STF_NCPA_FLUSH_COPYLIST = TRUE
    CopyFilesInCopyList
    exit

[DoCreateIcons]
    read-syms IconInfo$(!STF_LANGUAGE)
    install CreateIcons
    return

[CreateIcons]
    ifstr(i) $(!STF_PRODUCT) != "WINNT"
        CreateCommonProgManGroup $(NetAdminGroupName) ""
        ShowCommonProgManGroup $(NetAdminGroupName), 1
        RemoveCommonProgManItem $(NetAdminGroupName), $(NCADMIN)
        CreateCommonProgManItem $(NetAdminGroupName), $(NCADMIN), "ncadmin.exe" ""  0
        RemoveCommonProgManItem $(NetAdminGroupName), $(LICMAN)
        CreateCommonProgManItem $(NetAdminGroupName), $(LICMAN), "llsmgr.exe" ""  0
        ShowCommonProgManGroup $(NetAdminGroupName), 6
        CreateProgManGroup $(MainGroup), ""
        ShowProgManGroup $(MainGroup), 1
    endif
    exit


[DoCairoInitialization]

   set InitializationStatus = STATUS_SUCCESSFUL
   ;
   ;   CAIRO BUGBUG: Initialize Cairo SCM
   ;
;   Set PushDebugLevel = !G:DebugOutputControl
;   set !G:DebugOutputControl = DebugCairoSteps
   shell "cairo.inf" GetDrive
   ifstr(i) $($R0) != "STATUS_SUCCESSFUL"
        Debug-Output "NTCAIRO.INF:  Failed to get OFS drive"
        read-syms FatalError20$(!STF_LANGUAGE)
        shell "subroutn.inf" SetupMessage $(!STF_LANGUAGE) "FATAL" $(Fatal)
;        goto setupnotdone
        set InitializationStatus = STATUS_FAILED
        Return $(InitializationStatus)
   Endif
   Debug-Output "NTCAIRO.INF:  Starting RecOM/OFS"
   ;
   ;    CAIRO BUGBUG: variable made public
   ;
   Set !ObjDrive = $($R1)
   shell "cairo.inf" RegSetEnvVar "CairoDrv" $(!ObjDrive)
   Debug-Output "NTCAIRO.INF:  ObjDrive = "$(!ObjDrive)
   Shell "subroutn.inf" PushBillboard NETSTATUSDLG "Running format on "$(!ObjDrive)
   RunProgram RC "" "" $(!STF_WINDOWSSYSPATH)"\format.com" $(!ObjDrive) /fs:ofs /q
   Debug-Output "NTCAIRO.INF: Format returned "$(RC)
   Install Install-Create-Cairo-Dir
   Debug-Output "NTCAIRO.INF:  Created directory "$(!ObjDrive)"\cairo"
   LibraryProcedure STATUS, $(!LIBHANDLE), Delnode $(!ObjDrive)"\cairo\ds"
   Shell "subroutn.inf" PopBillboard
   Debug-Output "NTCAIRO.INF:  Setting OLE to autostart"
   shell "registry.inf" ModifyServicesEntry "OLE"     $(!SERVICE_AUTO_START)
   shell "registry.inf" ModifyServicesEntry "CiFilter"     $(!SERVICE_AUTO_START)

;   set !G:DebugOutputControl = PushDebugLevel

   Return $(InitializationStatus)





;
;   CAIRO BUGBUG
;

;GetCairoParams= +
[GetCairoParams]

   set GetCairoParamsStatus = STATUS_FAILED
;   set PushDebugLevel = !G:DebugOutputControl
;   set !G:DebugOutputControl = DebugCairoSteps

   Debug-Output "NTCAIRO.INF:  Getting uplevel password"
;   shell "cairo.inf" GetDomainPassword
;   ifstr(i) $($R0) == "STATUS_SUCCESSFUL"
;        Set CairoDomainPassword = $($R1)
;   else-ifstr(i) $($R0) == "STATUS_USE_DOWNLEVEL"
;        Set CairoDomainPassword = $(!STF_PASSWORD)
;   else
;        goto SetupNotDone
;   Endif
    Set !CairoDomainPassword = $(!STF_USERNAME)

   Debug-Output "NTCAIRO.INF:  uplevel PW ="$(!CairoDomainPassword)
   Debug-Output "NTCAIRO.INF:  Get Installation type"
   shell "cairo.inf" GetCairoInstallType
   ifstr(i) $($R0) == "STATUS_SUCCESSFUL"
        set !STF_DOMAIN_ROLE = $($R1)
   else
        goto endGetCairoParams
   Endif

   ifstr(i) $(!STF_DOMAIN_ROLE) == "DC"
        ;
        ; Get DC type
        shell "cairo.inf" GetDCType
        ifstr(i) $($R0) != "STATUS_SUCCESSFUL"
            goto endGetCairoParams
        endif
        ifstr $($R1) == ""
            goto endGetCairoParams
        else
            ;
            ;   CAIRO BUGBUG: Variable made public
            ;
            set !DCType = $($R1)
        endif
        Debug-Output "NTCAIRO.INF:  DC type is "$(!DCType)"."
   Endif

   ifstr(i) $(!STF_DOMAIN_ROLE) != STANDALONE
        Debug-Output "NTCAIRO.INF:  Not standalone, so setting up domain"
        ;
        ;   CAIRO BUGBUG: variable made global
        ;
        Set !AccountFile = $(!STF_WINDOWSSYSPATH)"\accounts.inf"
        Debug-Output "NTCAIRO.INF:  Account file "$(!AccountFile)
        shell $(!AccountFile) setup $(!STF_USERNAME)
        ifint $($ShellCode) != $(!SHELL_CODE_OK)
            shell "cairo.inf" MsgBox "File: "$(!AccountFile)" is missing."+
                                    "User's DomainName must be entered manually"
        else-ifstr(i) $($R0) != STATUS_SUCCESSFUL
            shell "cairo.inf" MsgBox "Error: "+$($R0)" Accessing: "+$(!AccountFile)+
                                    "User's DomainName must be entered manually"
        else
            ;
            ;   CAIRO BUGBUG: variable made public
            ;
            set !CairoDomainName = $($R1)
            set !CairoOuName = $($R2)
        endif
        shell "cairo.inf" GetCairoDomainPath
        ifstr(i) $($R0) != "STATUS_SUCCESSFUL"
            goto endGetCairoParams
        endif
        ;
        ;   CAIRO BUGBUG: variable made public
        ;
        set !CairoDomainName = $($R1)
        ifstr $(!CairoDomainName) == ""
            shell "cairo.inf" ErrMsg "Network domain not set!  Aborting setup."
            goto endGetCairoParams
        endif
;        Debug-Output "NTCAIRO.INF:  setting workgroup from "$(CairoDomainName)
;        RunProgram RC "" "" $(!STF_WINDOWSSYSPATH)"\SetDom.exe" $(CairoDomainName)
   Endif

;   set !G:DebugOutputControl = PushDebugLevel
   set GetCairoParamsStatus = STATUS_SUCCESSFUL

endGetCairoParams = +

   Return $(GetCairoParamsStatus)
;   goto $(retaddr)





;
;   CAIRO BUGBUG
;

;DoCairoSetup= +
[DoCairoSetup]
   read-syms GeneralConstants
;   read-syms BaseGeneralConstants

   set DoCairoSetupStatus = STATUS_FAILED
;   set PushDebugLevel = !G:DebugOutputControl
;   set !G:DebugOutputControl = DebugCairoSteps
   Debug-Output "NTCAIRO.INF:  Disabling Netlogon"
   LibraryProcedure DontCare, $(!LIBHANDLE), SetupChangeServiceConfig, NetLogon,+
               $(SERVICE_NO_CHANGE), 3, $(SERVICE_NO_CHANGE), "", "", "", "", "", ""
   Debug-Output "NTCAIRO.INF:  Initializing Cairo file"
   ifstr(i) $(!STF_NTPATH) == ""
        Debug-Output "!STF_NTPATH is NULL? "$(!STF_NTPATH)
        ifstr(i) $(!STF_WINDOWSPATH) == ""
             Debug-Output "WINDOWSPATH is NULL, too? "$(!STF_WINDOWSPATH)
        Else
             set CairoInstFile = $(!STF_WINDOWSPATH)"\CairoStd.ini"
        Endif
   Else
        set CairoInstFile = $(!STF_NTPATH)"\CairoStd.ini"
   Endif
   Debug-Output "NTCAIRO.INF:  CairoInstFile set to: "$(CairoInstFile)
   shell "cairo.inf" UpdateCairoIniFile $(CairoInstFile) "Key" "Value"
   Debug-Output "NTCAIRO.INF:  UpdateCairoInitFile returned "$($R0)
   shell "cairo.inf" UpdateCairoIniFile $(CairoInstFile) "InstallType" $(!STF_DOMAIN_ROLE)
   shell "cairo.inf" UpdateCairoIniFile $(CairoInstFile) "UserName" $(!STF_USERNAME)
   shell "cairo.inf" UpdateCairoIniFile $(CairoInstFile) "DomainPassword" $(!CairoDomainPassword)
   shell "cairo.inf" UpdateCairoIniFile $(CairoInstFile) "MachineName" $(!STF_COMPUTERNAME)
   shell "cairo.inf" UpdateCairoIniFile $(CairoInstFile) "MachinePassword" $(!STF_COMPUTERNAME)
   shell "cairo.inf" UpdateCairoIniFile $(CairoInstFile) "MachineAddress" $(!STF_COMPUTERNAME)
   shell "cairo.inf" UpdateCairoIniFile $(CairoInstFile) "ObjDrive" $(!ObjDrive)
   shell "cairo.inf" UpdateCairoIniFile $(CairoInstFile) "InstallDir" "Cairo"
   shell "cairo.inf" UpdateCairoIniFile $(CairoInstFile) "DownlevelPassword" $(!STF_PASSWORD)
   shell "cairo.inf" UpdateCairoIniFile $(CairoInstFile) "DownlevelDomain" $(!STF_NTDOMAIN)
   Debug-Output "NTCAIRO.INF:  Setup Installtype, Username, etc."
   ifstr(i) $(!STF_DOMAIN_ROLE) != STANDALONE
        shell "cairo.inf" UpdateCairoIniFile $(CairoInstFile) "CairoDomainName" $(!CairoDomainName)
        shell "cairo.inf" UpdateCairoIniFile $(CairoInstFile) "OuName" $(!CairoOuName)
   Endif
   ifstr $(!STF_DOMAIN_ROLE) == "DC"
        shell "cairo.inf" UpdateCairoIniFile $(CairoInstFile) "AdminGroupName"  "AdminGroup"
        shell "cairo.inf" UpdateCairoIniFile $(CairoInstFile) "BackupGroupName" "BackupGroup"
        shell "cairo.inf" UpdateCairoIniFile $(CairoInstFile) "DCType" $(!DCType)
   endif

   ;
   ; Make directories for Cairo desktop
   ; BUGBUG: I'm sure this isn't how it will really work
   ;
   Install Install-Create-Desktop

   Debug-Output "NTCAIRO.INF:  running cairostd.exe"
   Shell "subroutn.inf" PushBillboard NETSTATUSDLG "Setting up base cairo "
   RunProgram RC "" "" $(!STF_WINDOWSSYSPATH)"\cairostd.exe" $(CairoInstFile)
   Shell "subroutn.inf" PopBillboard
   Debug-Output "cairostd.exe returned "$(RC)
   ifint $(RC) != 0
       shell "cairo.inf" MsgBox "Standalone returned "$(RC).
       goto CairoSetupNotDone
   endif

;   RunProgram RC "" "" $(!STF_WINDOWSSYSPATH)"\credini.exe" -u $(!STF_USERNAME) -p ""$(!STF_PASSWORD)""
;
;   ifstr(i) $(!STF_DOMAIN_ROLE) == STANDALONE
;        set Status = STATUS_SUCCESS
;        goto CairoSetupOuttaHere
;   EndIf

   set DoReplicatedDC = 0
   ifstr(i) $(!STF_DOMAIN_ROLE) == SERVER
        set DoJoinDom = 1
        set DoMakeDc = 0
   Endif
   ifstr(i) $(!STF_DOMAIN_ROLE) == WORKSTATION
        set DoJoinDom = 1
        set DoMakeDc = 0
   EndIf
   ifstr(i) $(!STF_DOMAIN_ROLE) == DC
        ifcontains(i) $(!DCType) in {FirstDC}
            set DoJoinDom = 0
            set DoMakeDc = 1
        Else
            ; should be one of {ReplicaDC}
            set DoJoinDom = 1
            set DoMakeDc = 1
            set DoReplicatedDC = 1
        Endif
   Endif

   ifint $(DoJoinDom) == 1

        Debug-Output "NTCAIRO.INF:  Trying to join domain "$(!CairoDomainName)

        Shell "subroutn.inf" PushBillboard NETSTATUSDLG "Setting up a Workstation...."

        RunProgram RC "" "" $(!STF_WINDOWSSYSPATH)"\joindom.exe" $(CairoInstFile)
        shell "subroutn.inf" PopBillboard
        ifint $(RC) != 0
            ifint $(RC) == 8
                shell "cairo.inf" MsgBox "Workstation Setup Failed.  "+
                    "This machine has no account on the DC.  "+
                    "Standalone Cairo is installed, but you will need to "+
                    "run joindom once you have an account."
            else
                shell "cairo.inf" MsgBox "Standalone Cairo is installed, "+
                    "but Workstation Setup failed.  joindom returned "$(RC).
            endif
            goto CairoSetupOuttaHere
        endif
   Endif

   ifint $(DoMakeDc) == 1

        Debug-Output "NTCAIRO.INF:  Running makedc (run for cover)"

        Shell "subroutn.inf" PushBillboard NETSTATUSDLG "Setting up a DC..."

        RunProgram RC "" "" $(!STF_WINDOWSSYSPATH)"\makedc.exe" $(CairoInstFile)

        Shell "subroutn.inf" PopBillboard

        ifint $(RC) != 0
            shell "cairo.inf" MsgBox "MakeDC failed with error "$(RC)
            goto CairoSetupOuttaHere
        Endif

;        ifstr(i) $(!STF_DOMAIN_ROLE) == "DC"
;            RunProgram RC "" "" $(!STF_WINDOWSSYSPATH)"\SetDom.exe" -sid $(CairoDomainName)
;        endif

        ifint $(DoReplicatedDC) == 0

            Shell "subroutn.inf" PushBillboard NETSTATUSDLG "Creating account objects..."

            RunProgram RC "" "" $(!STF_WINDOWSSYSPATH)"\dsmgr.exe" -file $(!AccountFile)

            Shell "subroutn.inf" PopBillboard
            ifint $(RC) != 0
                shell "cairo.inf" MsgBox "DSMgr failed with error "$(RC)
                goto CairoSetupOuttaHere
            Endif

            ifstr(i) $(!CairoDomainName) == "\msft"
                RunProgram RC "" "" $(!STF_WINDOWSSYSPATH)"\cmd.exe" /c $(!STF_WINDOWSSYSPATH)\mountdl.cmd
            Endif

        Endif

        ; Create the global catalog

;
; SKIP creating the Global Catalog until the new summary catalog
; support catches up
;
;        Shell "subroutn.inf" PushBillboard NETSTATUSDLG "Creating global catalog..."
;
;        RunProgram RC "" "" $(!STF_WINDOWSSYSPATH)"\gcconfig.exe" -configure
;        Shell "subroutn.inf" PopBillboard
;        ifint $(RC) != 0
;            shell "cairo.inf" MsgBox "GCConfig failed with error "$(RC)
;            goto CairoSetupOuttaHere
;        Endif

   Endif

   ;
   ; setup alert system service
   ;
   shell "cairo.inf" DoAlertSystemSetup

CairoSetupOuttaHere = +

   set DoCairoSetupStatus = STATUS_SUCCESSFUL
   Return $(DoCairoSetupStatus)
;   goto $(retaddr)

CairoSetupNotDone = +

   Return $(DoCairoSetupStatus)





;
; CAIRO BUGBUG - new section for Cairo only
;
[Install-Create-Desktop]
    set STF_VITAL = ""
    CreateDir $(!STF_WINDOWSPATH)"\users"
    CreateDir $(!STF_WINDOWSPATH)"\users\"$(!STF_USERNAME)
    CreateDir $(!STF_WINDOWSPATH)"\users\"$(!STF_USERNAME)"\Desktop"
    CreateDir $(!STF_WINDOWSPATH)"\users\"$(!STF_USERNAME)"\Desktop\Stuff"
    CreateDir $(!ObjDrive)"\desktops"
    CreateDir $(!ObjDrive)"\desktops\"$(!STF_USERNAME)

[Install-Create-Cairo-Dir]
    set STF_VITAL = ""
    CreateDir $(!ObjDrive)"\cairo"






;***********************************************************************************************
;
;   File Lists
;
;
;   Network INF files must already be present on the drive when this INF is run.
;
;***********************************************************************************************
