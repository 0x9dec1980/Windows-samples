//
// A sample driver that demonstrates event logging.
//

#include "ntddk.h"

//
// The following include "simlog.h" is generated by the message compiler
// from the .mc file.
//

#include "simlog.h"

#define NUMBER_DUMP_DATA_ENTRIES 4

VOID
SimLogUnload(
    IN PDRIVER_OBJECT DriverObject
    );

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    ) {

    PDEVICE_OBJECT deviceObject = NULL;
    NTSTATUS status;
    UNICODE_STRING uniDeviceName;
    UNICODE_STRING uniErrorString ;
    PWCHAR insertionString ;
    PIO_ERROR_LOG_PACKET errorLogEntry ;
    int i ;

    KdPrint(("SimLog: DriverEntry.\n"));

    //
    // Form the name for the first device.
    //

    RtlInitUnicodeString( &uniDeviceName, L"\\Device\\SimLog001");

    //
    // Create the device object.
    //

    status = IoCreateDevice(
                 DriverObject,
                 0,
		 &uniDeviceName,
		 FILE_DEVICE_UNKNOWN,
                 0,
		 FALSE,
                 &deviceObject
                 );

    if (!NT_SUCCESS(status)) {

	KdPrint(("SimLog: failed creating device object! Status: %X\n", status));
	return status ;

    }

    //
    // Fill in the dispatch routine addresses. We don't do anything, so just the
    // unload routine.
    //

    DriverObject->DriverUnload = SimLogUnload;

    status = STATUS_SUCCESS ;

    //
    // We will do an error log here to show how it is done.
    //

    RtlInitUnicodeString (&uniErrorString, L"Hello, World.") ;

    //
    // Remember the insertion string should be NULL terminated. So we allocate
    // the extra space of WCHAR.
    //
    // The first parameter to IoAllocateErrorLogEntry can be either the driver
    // object or the device object. If it is given a device object, the name
    // of the device (used in IoCreateDevice) will show up in the place of %1
    // in the message. See the message file (.mc) for more details.
    //

    errorLogEntry = IoAllocateErrorLogEntry (deviceObject,
                    (UCHAR)
		    (sizeof (IO_ERROR_LOG_PACKET)
		    + (NUMBER_DUMP_DATA_ENTRIES - 1) * sizeof (ULONG)
		    + uniErrorString.Length
		    + sizeof (WCHAR))) ;

    if (!errorLogEntry) {

	KdPrint (("SimLog: Can not allocate error log entry.\n")) ;

    } else {

	KdPrint (("SimLog: Going to log an error entry.\n")) ;

	errorLogEntry->ErrorCode = SIMLOG_INFORMATION;
	errorLogEntry->SequenceNumber = 0;
	errorLogEntry->MajorFunctionCode = 0 ;
	errorLogEntry->RetryCount = 0;
	errorLogEntry->UniqueErrorValue = 0;
	errorLogEntry->FinalStatus = STATUS_SUCCESS ;
	errorLogEntry->DumpDataSize = NUMBER_DUMP_DATA_ENTRIES * sizeof (ULONG);
	errorLogEntry->StringOffset = sizeof (IO_ERROR_LOG_PACKET) +
				      (NUMBER_DUMP_DATA_ENTRIES - 1) * sizeof (ULONG) ;
	errorLogEntry->NumberOfStrings = 1 ;

	for (i = 0 ; i < NUMBER_DUMP_DATA_ENTRIES ; i++) {
	    errorLogEntry->DumpData[i] = 0xABCDEF00L + i ;
	}

	insertionString = (PWSTR)((PCHAR)(errorLogEntry) + errorLogEntry->StringOffset) ;
	RtlMoveMemory (insertionString, uniErrorString.Buffer, uniErrorString.Length) ;
	*(PWSTR)((PCHAR)insertionString + uniErrorString.Length) = L'\0' ;

	KdPrint (("SimLog: The insertion string: %ws\n", insertionString)) ;

	IoWriteErrorLogEntry (errorLogEntry) ;

    }

    return status ;

}

VOID
SimLogUnload(
    IN PDRIVER_OBJECT DriverObject
    ) {

    KdPrint(("SimLog: Driver unload.\n"));

    IoDeleteDevice(DriverObject->DeviceObject);

}
