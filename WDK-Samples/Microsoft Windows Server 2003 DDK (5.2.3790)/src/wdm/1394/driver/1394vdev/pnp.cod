; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.2190 

	TITLE	.\pnp.c
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT _InitializeListHead@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _RemoveHeadList@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _t1394VDev_PnpAddDevice@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _t1394VDev_Pnp@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _t1394VDev_PnpStartDevice@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _t1394VDev_PnpStopDevice@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _t1394VDev_PnpRemoveDevice@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _GUID_1394VDEV
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT _GUID_1394DIAG
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT _BUS1394_CLASS_GUID
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
sxdata	SEGMENT DWORD USE32 'SXDATA'
sxdata	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBC
INCLUDELIB OLDNAMES

PUBLIC	_BUS1394_CLASS_GUID
PUBLIC	_GUID_1394DIAG
PUBLIC	_GUID_1394VDEV
;	COMDAT _BUS1394_CLASS_GUID
CONST	SEGMENT
_BUS1394_CLASS_GUID DD 06bdd1fc1H
	DW	0810fH
	DW	011d0H
	DB	0beH
	DB	0c7H
	DB	08H
	DB	00H
	DB	02bH
	DB	0e2H
	DB	09H
	DB	02fH
CONST	ENDS
;	COMDAT _GUID_1394DIAG
CONST	SEGMENT
_GUID_1394DIAG DD 0c459df55H
	DW	0db08H
	DW	011d1H
	DB	0b0H
	DB	09H
	DB	00H
	DB	0a0H
	DB	0c9H
	DB	08H
	DB	01fH
	DB	0f6H
CONST	ENDS
;	COMDAT _GUID_1394VDEV
CONST	SEGMENT
_GUID_1394VDEV DD 0737613e5H
	DW	069eaH
	DW	04b96H
	DB	09cH
	DB	02aH
	DB	0eeH
	DB	0bcH
	DB	022H
	DB	0fH
	DB	04cH
	DB	039H
CONST	ENDS
PUBLIC	_InitializeListHead@4
; Function compile flags: /Ogsy
; File d:\srv03rtm\public\sdk\inc\wdm.h
;	COMDAT _InitializeListHead@4
_TEXT	SEGMENT
_ListHead$ = 8						; size = 4
_InitializeListHead@4 PROC NEAR				; COMDAT

; 1519 :     ListHead->Flink = ListHead->Blink = ListHead;

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _ListHead$[esp-4]
  00004	89 40 04	 mov	 DWORD PTR [eax+4], eax
  00007	89 00		 mov	 DWORD PTR [eax], eax

; 1520 : }

  00009	c2 04 00	 ret	 4
_InitializeListHead@4 ENDP
_TEXT	ENDS
PUBLIC	_RemoveHeadList@4
; Function compile flags: /Ogsy
;	COMDAT _RemoveHeadList@4
_TEXT	SEGMENT
_ListHead$ = 8						; size = 4
_RemoveHeadList@4 PROC NEAR				; COMDAT

; 1556 :     PLIST_ENTRY Flink;
; 1557 :     PLIST_ENTRY Entry;
; 1558 : 
; 1559 :     Entry = ListHead->Flink;

  00000	8b 4c 24 04	 mov	 ecx, DWORD PTR _ListHead$[esp-4]
  00004	8b 01		 mov	 eax, DWORD PTR [ecx]

; 1560 :     Flink = Entry->Flink;

  00006	8b 10		 mov	 edx, DWORD PTR [eax]

; 1561 :     ListHead->Flink = Flink;

  00008	89 11		 mov	 DWORD PTR [ecx], edx

; 1562 :     Flink->Blink = ListHead;

  0000a	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 1563 :     return Entry;
; 1564 : }

  0000d	c2 04 00	 ret	 4
_RemoveHeadList@4 ENDP
_TEXT	ENDS
PUBLIC	_t1394VDev_PnpAddDevice@8
EXTRN	__imp__IoRegisterDeviceInterface@16:NEAR
EXTRN	__imp__IoAttachDeviceToDeviceStack@8:NEAR
EXTRN	__imp__KeInitializeSpinLock@4:NEAR
EXTRN	__imp__IoCreateDevice@28:NEAR
EXTRN	__imp__IoDeleteDevice@4:NEAR
EXTRN	__imp__PoSetPowerState@12:NEAR
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:NEAR
; Function compile flags: /Ogsy
; File d:\srv03rtm\drivers\wdm\1394\tools\test\driver\1394vdev\pnp.c
;	COMDAT _t1394VDev_PnpAddDevice@8
_TEXT	SEGMENT
_DeviceObject$ = -24					; size = 4
_t1394VDevGUID$ = -20					; size = 16
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
_DriverObject$ = 8					; size = 4
_PhysicalDeviceObject$ = 12				; size = 4
_t1394VDev_PnpAddDevice@8 PROC NEAR			; COMDAT

; 30   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	56		 push	 esi
  0000c	57		 push	 edi
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 31   :     NTSTATUS                ntStatus = STATUS_SUCCESS;
; 32   :     PDEVICE_OBJECT          DeviceObject;
; 33   :     PDEVICE_EXTENSION       deviceExtension;
; 34   :     GUID                    t1394VDevGUID;
; 35   :     POWER_STATE             state;
; 36   :     PNODE_DEVICE_EXTENSION  pNodeExt;
; 37   : 
; 38   :     ENTER("t1394VDev_PnpAddDevice");
; 39   : 
; 40   :     TRACE(TL_WARNING, ("Adding 1394VDEV.SYS.\n"));
; 41   : 
; 42   :     TRACE(TL_TRACE, ("DriverObject = 0x%x\n", DriverObject));
; 43   :     TRACE(TL_TRACE, ("PhysicalDeviceObject = 0x%x\n", PhysicalDeviceObject));
; 44   : 
; 45   :     ntStatus = IoCreateDevice( DriverObject,
; 46   :                                sizeof(DEVICE_EXTENSION),
; 47   :                                NULL,
; 48   :                                FILE_DEVICE_UNKNOWN,
; 49   :                                0,
; 50   :                                FALSE,
; 51   :                                &DeviceObject
; 52   :                                );

  00010	8d 45 e8	 lea	 eax, DWORD PTR _DeviceObject$[ebp]
  00013	50		 push	 eax
  00014	33 f6		 xor	 esi, esi
  00016	56		 push	 esi
  00017	56		 push	 esi
  00018	6a 22		 push	 34			; 00000022H
  0001a	56		 push	 esi
  0001b	6a 60		 push	 96			; 00000060H
  0001d	ff 75 08	 push	 DWORD PTR _DriverObject$[ebp]
  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoCreateDevice@28
  00026	8b f8		 mov	 edi, eax

; 53   : 
; 54   :     if (!NT_SUCCESS(ntStatus))

  00028	3b fe		 cmp	 edi, esi
  0002a	0f 8c da 00 00
	00		 jl	 $Exit_PnpAddDevice$8725

; 55   : 	{
; 56   :         TRACE(TL_ERROR, ("IoCreateDevice Failed!\n"));
; 57   :         goto Exit_PnpAddDevice;
; 58   :     } // if
; 59   : 
; 60   :     TRACE(TL_TRACE, ("DeviceObject = 0x%x\n", DeviceObject));
; 61   : 
; 62   :     deviceExtension = DeviceObject->DeviceExtension;

  00030	8b 45 e8	 mov	 eax, DWORD PTR _DeviceObject$[ebp]
  00033	53		 push	 ebx
  00034	8b 58 28	 mov	 ebx, DWORD PTR [eax+40]

; 63   :     RtlZeroMemory(deviceExtension, sizeof(DEVICE_EXTENSION));

  00037	6a 18		 push	 24			; 00000018H
  00039	59		 pop	 ecx
  0003a	33 c0		 xor	 eax, eax
  0003c	8b fb		 mov	 edi, ebx
  0003e	f3 ab		 rep stosd

; 64   : 
; 65   :     TRACE(TL_TRACE, ("deviceExtension = 0x%x\n", deviceExtension));
; 66   : 
; 67   :     t1394VDevGUID = GUID_1394VDEV;

  00040	be 00 00 00 00	 mov	 esi, OFFSET FLAT:_GUID_1394VDEV
  00045	8d 7d ec	 lea	 edi, DWORD PTR _t1394VDevGUID$[ebp]
  00048	a5		 movsd
  00049	a5		 movsd
  0004a	a5		 movsd

; 68   : 
; 69   :     ntStatus = IoRegisterDeviceInterface( PhysicalDeviceObject,
; 70   :                                           &t1394VDevGUID,
; 71   :                                           NULL,
; 72   :                                           &deviceExtension->SymbolicLinkName
; 73   :                                           );

  0004b	8d 43 0c	 lea	 eax, DWORD PTR [ebx+12]
  0004e	50		 push	 eax
  0004f	6a 00		 push	 0
  00051	8d 45 ec	 lea	 eax, DWORD PTR _t1394VDevGUID$[ebp]
  00054	a5		 movsd
  00055	8b 75 0c	 mov	 esi, DWORD PTR _PhysicalDeviceObject$[ebp]
  00058	50		 push	 eax
  00059	56		 push	 esi
  0005a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoRegisterDeviceInterface@16
  00060	8b f8		 mov	 edi, eax

; 74   : 
; 75   :     if (!NT_SUCCESS(ntStatus))

  00062	85 ff		 test	 edi, edi
  00064	7d 13		 jge	 SHORT $L8729
$L8939:

; 76   : 	{
; 77   :         TRACE(TL_ERROR, ("IoRegisterDeviceInterface Failed!\n"));
; 78   :         IoDeleteDevice(DeviceObject);

  00066	ff 75 e8	 push	 DWORD PTR _DeviceObject$[ebp]
  00069	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoDeleteDevice@4

; 79   :         ntStatus = STATUS_NO_SUCH_DEVICE;

  0006f	bf 0e 00 00 c0	 mov	 edi, -1073741810	; c000000eH

; 80   :         goto Exit_PnpAddDevice;

  00074	e9 90 00 00 00	 jmp	 $L8937
$L8729:

; 81   :     }
; 82   : 
; 83   :     deviceExtension->StackDeviceObject =
; 84   :         IoAttachDeviceToDeviceStack(DeviceObject, PhysicalDeviceObject);

  00079	56		 push	 esi
  0007a	ff 75 e8	 push	 DWORD PTR _DeviceObject$[ebp]
  0007d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoAttachDeviceToDeviceStack@8

; 85   : 
; 86   :     if (!deviceExtension->StackDeviceObject)

  00083	85 c0		 test	 eax, eax
  00085	89 03		 mov	 DWORD PTR [ebx], eax

; 87   : 	{
; 88   :         TRACE(TL_ERROR, ("IoAttachDeviceToDeviceStack Failed!\n"));
; 89   :         IoDeleteDevice(DeviceObject);
; 90   :         ntStatus = STATUS_NO_SUCH_DEVICE;
; 91   :         goto Exit_PnpAddDevice;

  00087	74 dd		 je	 SHORT $L8939

; 92   :     } // if
; 93   :     
; 94   :     TRACE(TL_TRACE, ("StackDeviceObject = 0x%x\n", deviceExtension->StackDeviceObject));
; 95   : 
; 96   :     // save the device object we created as our physical device object
; 97   :     deviceExtension->PhysicalDeviceObject = DeviceObject;

  00089	8b 45 e8	 mov	 eax, DWORD PTR _DeviceObject$[ebp]
  0008c	89 43 08	 mov	 DWORD PTR [ebx+8], eax

; 98   :     TRACE(TL_TRACE, ("PhysicalDeviceObject = 0x%x\n", deviceExtension->PhysicalDeviceObject));
; 99   : 
; 100  :     // get the port device object from the passed in PhysicalDeviceObject created by the 1394 stack for us
; 101  : 	// Note: we can't use the top of the stack and get its device extension in case there is a filter driver
; 102  : 	// between us and our PDO
; 103  :     pNodeExt = PhysicalDeviceObject->DeviceExtension;
; 104  :     deviceExtension->PortDeviceObject = pNodeExt->PortDeviceObject;

  0008f	8b 46 28	 mov	 eax, DWORD PTR [esi+40]
  00092	8b 40 50	 mov	 eax, DWORD PTR [eax+80]
  00095	89 43 04	 mov	 DWORD PTR [ebx+4], eax

; 105  : 
; 106  :     // initialize power states
; 107  :     deviceExtension->CurrentDevicePowerState    = PowerDeviceD0;

  00098	33 c0		 xor	 eax, eax
  0009a	40		 inc	 eax

; 108  :     deviceExtension->CurrentSystemPowerState    = PowerSystemWorking;
; 109  : 
; 110  :     state.DeviceState = deviceExtension->CurrentDevicePowerState;
; 111  :     PoSetPowerState(DeviceObject, DevicePowerState, state);

  0009b	50		 push	 eax
  0009c	50		 push	 eax
  0009d	89 43 2c	 mov	 DWORD PTR [ebx+44], eax
  000a0	89 43 30	 mov	 DWORD PTR [ebx+48], eax
  000a3	ff 75 e8	 push	 DWORD PTR _DeviceObject$[ebp]
  000a6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PoSetPowerState@12

; 112  : 
; 113  :     TRACE(TL_TRACE, ("PortDeviceObject = 0x%x\n", deviceExtension->PortDeviceObject));
; 114  : 
; 115  :     // initialize the spinlock/list to store the bus reset irps...
; 116  :     KeInitializeSpinLock(&deviceExtension->ResetSpinLock);

  000ac	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__KeInitializeSpinLock@4
  000b2	8d 43 14	 lea	 eax, DWORD PTR [ebx+20]
  000b5	50		 push	 eax
  000b6	ff d6		 call	 esi

; 117  :     KeInitializeSpinLock(&deviceExtension->CromSpinLock);

  000b8	8d 43 18	 lea	 eax, DWORD PTR [ebx+24]
  000bb	50		 push	 eax
  000bc	ff d6		 call	 esi

; 118  :     KeInitializeSpinLock(&deviceExtension->AsyncSpinLock);

  000be	8d 43 1c	 lea	 eax, DWORD PTR [ebx+28]
  000c1	50		 push	 eax
  000c2	ff d6		 call	 esi

; 119  :     KeInitializeSpinLock(&deviceExtension->IsochSpinLock);

  000c4	8d 43 20	 lea	 eax, DWORD PTR [ebx+32]
  000c7	50		 push	 eax
  000c8	ff d6		 call	 esi

; 120  :     KeInitializeSpinLock(&deviceExtension->IsochResourceSpinLock);

  000ca	8d 43 24	 lea	 eax, DWORD PTR [ebx+36]
  000cd	50		 push	 eax
  000ce	ff d6		 call	 esi

; 121  :     InitializeListHead(&deviceExtension->BusResetIrps);

  000d0	8d 43 38	 lea	 eax, DWORD PTR [ebx+56]
  000d3	89 40 04	 mov	 DWORD PTR [eax+4], eax
  000d6	89 00		 mov	 DWORD PTR [eax], eax

; 122  :     InitializeListHead(&deviceExtension->CromData);

  000d8	8d 43 40	 lea	 eax, DWORD PTR [ebx+64]
  000db	89 40 04	 mov	 DWORD PTR [eax+4], eax
  000de	89 00		 mov	 DWORD PTR [eax], eax

; 123  :     InitializeListHead(&deviceExtension->AsyncAddressData);

  000e0	8d 43 48	 lea	 eax, DWORD PTR [ebx+72]
  000e3	89 40 04	 mov	 DWORD PTR [eax+4], eax
  000e6	89 00		 mov	 DWORD PTR [eax], eax

; 124  :     InitializeListHead(&deviceExtension->IsochDetachData);

  000e8	8d 43 50	 lea	 eax, DWORD PTR [ebx+80]
  000eb	89 40 04	 mov	 DWORD PTR [eax+4], eax
  000ee	89 00		 mov	 DWORD PTR [eax], eax

; 125  :     InitializeListHead(&deviceExtension->IsochResourceData);

  000f0	8d 43 58	 lea	 eax, DWORD PTR [ebx+88]
  000f3	89 40 04	 mov	 DWORD PTR [eax+4], eax
  000f6	89 00		 mov	 DWORD PTR [eax], eax

; 126  : 
; 127  :     DeviceObject->Flags &= DO_POWER_PAGABLE;

  000f8	8b 45 e8	 mov	 eax, DWORD PTR _DeviceObject$[ebp]
  000fb	81 60 1c 00 20
	00 00		 and	 DWORD PTR [eax+28], 8192 ; 00002000H

; 128  :     DeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

  00102	8b 45 e8	 mov	 eax, DWORD PTR _DeviceObject$[ebp]
  00105	80 60 1c 7f	 and	 BYTE PTR [eax+28], 127	; 0000007fH
$L8937:
  00109	5b		 pop	 ebx
$Exit_PnpAddDevice$8725:

; 129  : 
; 130  : Exit_PnpAddDevice:
; 131  : 
; 132  :     EXIT("t1394VDev_PnpAddDevice", ntStatus);
; 133  :     return(ntStatus);
; 134  : } // t1394VDev_PnpAddDevice

  0010a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0010d	8b c7		 mov	 eax, edi
  0010f	5f		 pop	 edi
  00110	5e		 pop	 esi
  00111	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00116	c9		 leave
  00117	c2 08 00	 ret	 8
_t1394VDev_PnpAddDevice@8 ENDP
_TEXT	ENDS
PUBLIC	_t1394VDev_PnpStartDevice@8
EXTRN	_t1394_BusResetNotification@12:NEAR
EXTRN	__imp__IoSetDeviceInterfaceState@8:NEAR
EXTRN	_t1394_UpdateGenerationCount@8:NEAR
; Function compile flags: /Ogsy
;	COMDAT _t1394VDev_PnpStartDevice@8
_TEXT	SEGMENT
_DeviceObject$ = 8					; size = 4
_Irp$ = 12						; size = 4
_t1394VDev_PnpStartDevice@8 PROC NEAR			; COMDAT

; 271  : {

  00000	56		 push	 esi
  00001	57		 push	 edi

; 272  :     NTSTATUS                ntStatus = STATUS_SUCCESS;
; 273  :     PDEVICE_EXTENSION       deviceExtension = DeviceObject->DeviceExtension;

  00002	8b 7c 24 0c	 mov	 edi, DWORD PTR _DeviceObject$[esp+4]
  00006	8b 77 28	 mov	 esi, DWORD PTR [edi+40]

; 274  : 
; 275  :     ENTER("t1394VDev_PnpStartDevice");
; 276  : 
; 277  :     deviceExtension->bShutdown = FALSE;
; 278  : 
; 279  :     ntStatus = t1394_BusResetNotification( DeviceObject,
; 280  :                                                Irp,
; 281  :                                                REGISTER_NOTIFICATION_ROUTINE
; 282  :                                                );

  00009	6a 01		 push	 1
  0000b	ff 74 24 14	 push	 DWORD PTR _Irp$[esp+8]
  0000f	c6 46 28 00	 mov	 BYTE PTR [esi+40], 0
  00013	57		 push	 edi
  00014	e8 00 00 00 00	 call	 _t1394_BusResetNotification@12

; 283  : 
; 284  :     // update the generation count
; 285  :     t1394_UpdateGenerationCount(DeviceObject, NULL);

  00019	6a 00		 push	 0
  0001b	57		 push	 edi
  0001c	e8 00 00 00 00	 call	 _t1394_UpdateGenerationCount@8

; 286  : 
; 287  :     // activate the interface...
; 288  :     ntStatus = IoSetDeviceInterfaceState(&deviceExtension->SymbolicLinkName, TRUE);

  00021	6a 01		 push	 1
  00023	83 c6 0c	 add	 esi, 12			; 0000000cH
  00026	56		 push	 esi
  00027	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoSetDeviceInterfaceState@8
  0002d	5f		 pop	 edi
  0002e	5e		 pop	 esi

; 289  : 
; 290  :     if (!NT_SUCCESS(ntStatus)) {
; 291  : 
; 292  :         TRACE(TL_ERROR, ("Failed to activate interface!\n"));
; 293  :     }
; 294  : 
; 295  :     EXIT("t1394VDev_PnpStartDevice", ntStatus);
; 296  :     return(ntStatus);
; 297  : } // t1394VDev_PnpStartDevice

  0002f	c2 08 00	 ret	 8
_t1394VDev_PnpStartDevice@8 ENDP
_TEXT	ENDS
PUBLIC	_t1394VDev_PnpStopDevice@8
; Function compile flags: /Ogsy
;	COMDAT _t1394VDev_PnpStopDevice@8
_TEXT	SEGMENT
_DeviceObject$ = 8					; size = 4
_Irp$ = 12						; size = 4
_t1394VDev_PnpStopDevice@8 PROC NEAR			; COMDAT

; 305  :     NTSTATUS            ntStatus = STATUS_SUCCESS;
; 306  :     PDEVICE_EXTENSION   deviceExtension = DeviceObject->DeviceExtension;
; 307  :     
; 308  :     ENTER("t1394VDev_PnpStopDevice");
; 309  : 
; 310  :     deviceExtension->bShutdown = TRUE;

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _DeviceObject$[esp-4]
  00004	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]

; 311  : 
; 312  :     ntStatus = t1394_BusResetNotification( DeviceObject,
; 313  :                                                Irp,
; 314  :                                                DEREGISTER_NOTIFICATION_ROUTINE
; 315  :                                                );

  00007	6a 02		 push	 2
  00009	ff 74 24 0c	 push	 DWORD PTR _Irp$[esp]
  0000d	c6 41 28 01	 mov	 BYTE PTR [ecx+40], 1
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 _t1394_BusResetNotification@12

; 316  : 
; 317  :     EXIT("t1394VDev_PnpStopDevice", ntStatus);
; 318  :     return(ntStatus);
; 319  : } // t1394VDev_PnpStopDevice

  00017	c2 08 00	 ret	 8
_t1394VDev_PnpStopDevice@8 ENDP
_TEXT	ENDS
PUBLIC	_t1394VDev_PnpRemoveDevice@8
EXTRN	__imp__IoAllocateIrp@8:NEAR
EXTRN	_t1394_IsochCleanup@4:NEAR
EXTRN	__imp__KeCancelTimer@4:NEAR
EXTRN	_t1394_SubmitIrpSynch@12:NEAR
EXTRN	__imp_@KfAcquireSpinLock@4:NEAR
EXTRN	__imp_@IofCompleteRequest@8:NEAR
EXTRN	__imp_@KfReleaseSpinLock@8:NEAR
EXTRN	__imp__IoFreeIrp@4:NEAR
EXTRN	__imp__IoFreeMdl@4:NEAR
EXTRN	__imp__ExAllocatePoolWithTag@12:NEAR
EXTRN	__imp__ExFreePool@4:NEAR
EXTRN	__imp_@InterlockedExchange@8:NEAR
EXTRN	__imp__RtlFreeUnicodeString@4:NEAR
; Function compile flags: /Ogsy
;	COMDAT _t1394VDev_PnpRemoveDevice@8
_TEXT	SEGMENT
_ntStatus$ = -16					; size = 4
_Entry$8969 = -12					; size = 4
_pIrb$8838 = -8						; size = 4
tv327 = -4						; size = 4
_ResourceIrp$8839 = 8					; size = 4
_Irql$ = 8						; size = 1
_DeviceObject$ = 8					; size = 4
_StackSize$8840 = 12					; size = 1
_Entry$8957 = 12					; size = 4
_Irp$ = 12						; size = 4
_t1394VDev_PnpRemoveDevice@8 PROC NEAR			; COMDAT

; 327  :     NTSTATUS            ntStatus = STATUS_SUCCESS;
; 328  :     PDEVICE_EXTENSION   deviceExtension = DeviceObject->DeviceExtension;

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _DeviceObject$[esp-4]
  00004	83 ec 10	 sub	 esp, 16			; 00000010H
  00007	53		 push	 ebx
  00008	55		 push	 ebp
  00009	56		 push	 esi
  0000a	8b 70 28	 mov	 esi, DWORD PTR [eax+40]

; 329  :     KIRQL               Irql;
; 330  : 
; 331  :     ENTER("t1394VDev_PnpRemoveDevice");
; 332  : 
; 333  :     TRACE(TL_WARNING, ("Removing 1394VDEV.SYS.\n"));
; 334  : 
; 335  :     if (!deviceExtension->bShutdown) {

  0000d	80 7e 28 00	 cmp	 BYTE PTR [esi+40], 0
  00011	57		 push	 edi
  00012	75 0a		 jne	 SHORT $L8802

; 336  : 
; 337  :         // haven't stopped yet, lets do so
; 338  :         ntStatus = t1394VDev_PnpStopDevice(DeviceObject, Irp);

  00014	ff 74 24 28	 push	 DWORD PTR _Irp$[esp+28]
  00018	50		 push	 eax
  00019	e8 00 00 00 00	 call	 _t1394VDev_PnpStopDevice@8
$L8802:

; 339  :     }
; 340  : 
; 341  :     // deactivate the interface...
; 342  :     ntStatus = IoSetDeviceInterfaceState(&deviceExtension->SymbolicLinkName, FALSE);

  0001e	8d 46 0c	 lea	 eax, DWORD PTR [esi+12]
  00021	6a 00		 push	 0
  00023	50		 push	 eax
  00024	89 44 24 24	 mov	 DWORD PTR tv327[esp+40], eax
  00028	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoSetDeviceInterfaceState@8

; 343  : 
; 344  :     if (!NT_SUCCESS(ntStatus)) {
; 345  : 
; 346  :         TRACE(TL_ERROR, ("Failed to deactivate interface!\n"));
; 347  :     }
; 348  : 
; 349  :     // lets free up any crom data structs we've allocated...
; 350  :     KeAcquireSpinLock(&deviceExtension->CromSpinLock, &Irql);

  0002e	8b 2d 00 00 00
	00		 mov	 ebp, DWORD PTR __imp_@KfAcquireSpinLock@4
  00034	8d 4e 18	 lea	 ecx, DWORD PTR [esi+24]
  00037	89 44 24 10	 mov	 DWORD PTR _ntStatus$[esp+32], eax
  0003b	ff d5		 call	 ebp
  0003d	88 44 24 24	 mov	 BYTE PTR _Irql$[esp+28], al

; 351  : 
; 352  :     while (!IsListEmpty(&deviceExtension->CromData)) {

  00041	8d 7e 40	 lea	 edi, DWORD PTR [esi+64]
  00044	eb 2c		 jmp	 SHORT $L8987
$L8806:

; 353  : 
; 354  :         PCROM_DATA      CromData;
; 355  : 
; 356  :         // get struct off list
; 357  :         CromData = (PCROM_DATA) RemoveHeadList(&deviceExtension->CromData);

  00046	8b 1f		 mov	 ebx, DWORD PTR [edi]
  00048	8b 03		 mov	 eax, DWORD PTR [ebx]
  0004a	89 07		 mov	 DWORD PTR [edi], eax
  0004c	89 78 04	 mov	 DWORD PTR [eax+4], edi

; 358  : 
; 359  :         // need to free up everything associated with this allocate...        
; 360  :         if (CromData)
; 361  :         {
; 362  :             if (CromData->Buffer)

  0004f	8b 43 0c	 mov	 eax, DWORD PTR [ebx+12]
  00052	85 c0		 test	 eax, eax
  00054	74 07		 je	 SHORT $L8984

; 363  :                 ExFreePool(CromData->Buffer);

  00056	50		 push	 eax
  00057	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePool@4
$L8984:

; 364  :     
; 365  :             if (CromData->pMdl)

  0005d	8b 43 10	 mov	 eax, DWORD PTR [ebx+16]
  00060	85 c0		 test	 eax, eax
  00062	74 07		 je	 SHORT $L8812

; 366  :                 IoFreeMdl(CromData->pMdl);

  00064	50		 push	 eax
  00065	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoFreeMdl@4
$L8812:

; 367  :     
; 368  :             // we already checked CromData
; 369  :             ExFreePool(CromData);

  0006b	53		 push	 ebx
  0006c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePool@4
$L8987:

; 351  : 
; 352  :     while (!IsListEmpty(&deviceExtension->CromData)) {

  00072	39 3f		 cmp	 DWORD PTR [edi], edi
  00074	75 d0		 jne	 SHORT $L8806

; 370  :         }
; 371  :     }
; 372  : 
; 373  :     KeReleaseSpinLock(&deviceExtension->CromSpinLock, Irql);

  00076	8a 54 24 24	 mov	 dl, BYTE PTR _Irql$[esp+28]
  0007a	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp_@KfReleaseSpinLock@8
  00080	8d 4e 18	 lea	 ecx, DWORD PTR [esi+24]
  00083	ff d3		 call	 ebx

; 374  : 
; 375  :     // lets free up any allocated addresses and deallocate all
; 376  :     // memory associated with them...
; 377  :     KeAcquireSpinLock(&deviceExtension->AsyncSpinLock, &Irql);

  00085	8d 4e 1c	 lea	 ecx, DWORD PTR [esi+28]
  00088	ff d5		 call	 ebp
  0008a	88 44 24 24	 mov	 BYTE PTR _Irql$[esp+28], al

; 378  : 
; 379  :     while (!IsListEmpty(&deviceExtension->AsyncAddressData)) {

  0008e	8d 7e 48	 lea	 edi, DWORD PTR [esi+72]
  00091	eb 4a		 jmp	 SHORT $L8988
$L8814:

; 380  : 
; 381  :         PASYNC_ADDRESS_DATA     AsyncAddressData;
; 382  : 
; 383  :         // get struct off list
; 384  :         AsyncAddressData = (PASYNC_ADDRESS_DATA) RemoveHeadList(&deviceExtension->AsyncAddressData);

  00093	8b 07		 mov	 eax, DWORD PTR [edi]
  00095	8b 08		 mov	 ecx, DWORD PTR [eax]
  00097	89 0f		 mov	 DWORD PTR [edi], ecx
  00099	89 79 04	 mov	 DWORD PTR [ecx+4], edi

; 385  : 
; 386  :         // need to free up everything associated with this allocate...
; 387  :         if (AsyncAddressData->pMdl)

  0009c	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  0009f	85 c9		 test	 ecx, ecx
  000a1	89 44 24 28	 mov	 DWORD PTR _Entry$8957[esp+28], eax
  000a5	74 0b		 je	 SHORT $L8818

; 388  :             IoFreeMdl(AsyncAddressData->pMdl);

  000a7	51		 push	 ecx
  000a8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoFreeMdl@4
  000ae	8b 44 24 28	 mov	 eax, DWORD PTR _Entry$8957[esp+28]
$L8818:

; 389  : 
; 390  :         if (AsyncAddressData->Buffer)

  000b2	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  000b5	85 c9		 test	 ecx, ecx
  000b7	74 0b		 je	 SHORT $L8985

; 391  :             ExFreePool(AsyncAddressData->Buffer);

  000b9	51		 push	 ecx
  000ba	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePool@4
  000c0	8b 44 24 28	 mov	 eax, DWORD PTR _Entry$8957[esp+28]
$L8985:

; 392  : 
; 393  :         if (AsyncAddressData->AddressRange)

  000c4	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  000c7	85 c9		 test	 ecx, ecx
  000c9	74 0b		 je	 SHORT $L8820

; 394  :             ExFreePool(AsyncAddressData->AddressRange);

  000cb	51		 push	 ecx
  000cc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePool@4
  000d2	8b 44 24 28	 mov	 eax, DWORD PTR _Entry$8957[esp+28]
$L8820:

; 395  : 
; 396  :         if (AsyncAddressData)
; 397  :             ExFreePool(AsyncAddressData);

  000d6	50		 push	 eax
  000d7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePool@4
$L8988:

; 378  : 
; 379  :     while (!IsListEmpty(&deviceExtension->AsyncAddressData)) {

  000dd	39 3f		 cmp	 DWORD PTR [edi], edi
  000df	75 b2		 jne	 SHORT $L8814

; 398  :     }
; 399  : 
; 400  :     KeReleaseSpinLock(&deviceExtension->AsyncSpinLock, Irql);

  000e1	8a 54 24 24	 mov	 dl, BYTE PTR _Irql$[esp+28]
  000e5	8d 4e 1c	 lea	 ecx, DWORD PTR [esi+28]
  000e8	ff d3		 call	 ebx

; 401  : 
; 402  :     // free up any attached isoch buffers
; 403  :     while (TRUE) {
; 404  : 
; 405  :         KeAcquireSpinLock(&deviceExtension->IsochSpinLock, &Irql);

  000ea	8d 4e 20	 lea	 ecx, DWORD PTR [esi+32]
  000ed	ff d5		 call	 ebp

; 406  : 
; 407  :         if (!IsListEmpty(&deviceExtension->IsochDetachData)) {

  000ef	8d 7e 50	 lea	 edi, DWORD PTR [esi+80]
  000f2	39 3f		 cmp	 DWORD PTR [edi], edi
  000f4	88 44 24 24	 mov	 BYTE PTR _Irql$[esp+28], al
  000f8	74 45		 je	 SHORT $L8825
$L8823:

; 408  : 
; 409  :             PISOCH_DETACH_DATA      IsochDetachData;
; 410  :             ULONG                   i;
; 411  : 
; 412  :             IsochDetachData = (PISOCH_DETACH_DATA)RemoveHeadList(&deviceExtension->IsochDetachData);

  000fa	8b 2f		 mov	 ebp, DWORD PTR [edi]
  000fc	8b 45 00	 mov	 eax, DWORD PTR [ebp]
  000ff	89 07		 mov	 DWORD PTR [edi], eax
  00101	89 78 04	 mov	 DWORD PTR [eax+4], edi

; 413  : 
; 414  :             TRACE(TL_TRACE, ("Surprise Removal: IsochDetachData = 0x%x\n", IsochDetachData));
; 415  : 
; 416  :             KeCancelTimer(&IsochDetachData->Timer);

  00104	8d 45 28	 lea	 eax, DWORD PTR [ebp+40]
  00107	50		 push	 eax
  00108	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeCancelTimer@4

; 417  :             KeReleaseSpinLock(&deviceExtension->IsochSpinLock, Irql);

  0010e	8a 54 24 24	 mov	 dl, BYTE PTR _Irql$[esp+28]
  00112	8d 4e 20	 lea	 ecx, DWORD PTR [esi+32]
  00115	ff d3		 call	 ebx

; 418  : 
; 419  :             TRACE(TL_TRACE, ("Surprise Removal: IsochDetachData->Irp = 0x%x\n", IsochDetachData->Irp));
; 420  : 
; 421  :             // need to save the status of the attach
; 422  :             // we'll clean up in the same spot for success's and timeout's
; 423  :             IsochDetachData->AttachStatus = STATUS_SUCCESS;

  00117	83 65 20 00	 and	 DWORD PTR [ebp+32], 0

; 424  : 
; 425  :             // detach no matter what...
; 426  :             IsochDetachData->bDetach = TRUE;
; 427  : 
; 428  :             t1394_IsochCleanup(IsochDetachData);

  0011b	55		 push	 ebp
  0011c	c7 45 7c 01 00
	00 00		 mov	 DWORD PTR [ebp+124], 1
  00123	e8 00 00 00 00	 call	 _t1394_IsochCleanup@4
  00128	8d 4e 20	 lea	 ecx, DWORD PTR [esi+32]
  0012b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@KfAcquireSpinLock@4
  00131	39 3f		 cmp	 DWORD PTR [edi], edi
  00133	88 44 24 24	 mov	 BYTE PTR _Irql$[esp+28], al
  00137	75 c1		 jne	 SHORT $L8823

; 406  : 
; 407  :         if (!IsListEmpty(&deviceExtension->IsochDetachData)) {

  00139	8b 2d 00 00 00
	00		 mov	 ebp, DWORD PTR __imp_@KfAcquireSpinLock@4
$L8825:

; 429  :         }
; 430  :         else {
; 431  : 
; 432  :             KeReleaseSpinLock(&deviceExtension->IsochSpinLock, Irql);

  0013f	8a 54 24 24	 mov	 dl, BYTE PTR _Irql$[esp+28]
  00143	8d 4e 20	 lea	 ecx, DWORD PTR [esi+32]
  00146	ff d3		 call	 ebx

; 433  :             break;
; 434  :         }
; 435  :     }
; 436  : 
; 437  :     // remove any isoch resource data
; 438  :     while (TRUE) {
; 439  : 
; 440  :         KeAcquireSpinLock(&deviceExtension->IsochResourceSpinLock, &Irql);

  00148	8d 7e 24	 lea	 edi, DWORD PTR [esi+36]
  0014b	8b cf		 mov	 ecx, edi
  0014d	ff d5		 call	 ebp

; 441  : 
; 442  :         if (!IsListEmpty(&deviceExtension->IsochResourceData)) {

  0014f	8d 6e 58	 lea	 ebp, DWORD PTR [esi+88]
  00152	e9 9c 00 00 00	 jmp	 $L8989
$L8832:

; 443  : 
; 444  :             PISOCH_RESOURCE_DATA    IsochResourceData;
; 445  : 
; 446  :             IsochResourceData = (PISOCH_RESOURCE_DATA)RemoveHeadList(&deviceExtension->IsochResourceData);

  00157	8b 4d 00	 mov	 ecx, DWORD PTR [ebp]
  0015a	89 4c 24 14	 mov	 DWORD PTR _Entry$8969[esp+32], ecx
  0015e	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00160	89 4d 00	 mov	 DWORD PTR [ebp], ecx
  00163	89 69 04	 mov	 DWORD PTR [ecx+4], ebp

; 447  : 
; 448  :             KeReleaseSpinLock(&deviceExtension->IsochResourceSpinLock, Irql);

  00166	8b cf		 mov	 ecx, edi
  00168	ff d3		 call	 ebx

; 449  : 
; 450  :             TRACE(TL_TRACE, ("Surprise Removal: IsochResourceData = 0x%x\n", IsochResourceData));
; 451  : 
; 452  :             if (IsochResourceData) {
; 453  : 
; 454  :                 PIRB                pIrb;
; 455  :                 PIRP                ResourceIrp;
; 456  :                 CCHAR               StackSize;
; 457  : 
; 458  :                 TRACE(TL_TRACE, ("Surprise Removal: Freeing hResource = 0x%x\n", IsochResourceData->hResource));
; 459  : 
; 460  :                 StackSize = deviceExtension->StackDeviceObject->StackSize;

  0016a	8b 06		 mov	 eax, DWORD PTR [esi]
  0016c	8a 40 30	 mov	 al, BYTE PTR [eax+48]
  0016f	88 44 24 28	 mov	 BYTE PTR _StackSize$8840[esp+28], al

; 461  :                 ResourceIrp = IoAllocateIrp(StackSize, FALSE);

  00173	6a 00		 push	 0
  00175	ff 74 24 2c	 push	 DWORD PTR _StackSize$8840[esp+32]
  00179	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoAllocateIrp@8
  0017f	8b f8		 mov	 edi, eax

; 462  : 
; 463  :                 if (ResourceIrp == NULL) {

  00181	85 ff		 test	 edi, edi
  00183	89 7c 24 24	 mov	 DWORD PTR _ResourceIrp$8839[esp+28], edi
  00187	74 5f		 je	 SHORT $L8846

; 464  : 
; 465  :                     TRACE(TL_ERROR, ("Failed to allocate ResourceIrp!\n"));
; 466  :                 }
; 467  :                 else {
; 468  : 
; 469  :                     pIrb = ExAllocatePool(NonPagedPool, sizeof(IRB));

  00189	68 57 64 6d 20	 push	 544040023		; 206d6457H
  0018e	68 58 01 00 00	 push	 344			; 00000158H
  00193	6a 00		 push	 0
  00195	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExAllocatePoolWithTag@12
  0019b	8b d0		 mov	 edx, eax

; 470  : 
; 471  :                     if (!pIrb) {

  0019d	85 d2		 test	 edx, edx
  0019f	89 54 24 18	 mov	 DWORD PTR _pIrb$8838[esp+32], edx
  001a3	75 03		 jne	 SHORT $L8845

; 472  : 
; 473  :                         IoFreeIrp(ResourceIrp);

  001a5	57		 push	 edi

; 474  : 
; 475  :                         TRACE(TL_ERROR, ("Failed to allocate pIrb!\n"));
; 476  :                     }
; 477  :                     else {

  001a6	eb 3a		 jmp	 SHORT $L8990
$L8845:

; 478  : 
; 479  :                         RtlZeroMemory (pIrb, sizeof (IRB));

  001a8	6a 56		 push	 86			; 00000056H
  001aa	59		 pop	 ecx
  001ab	33 c0		 xor	 eax, eax
  001ad	8b fa		 mov	 edi, edx
  001af	f3 ab		 rep stosd

; 480  :                         pIrb->FunctionNumber = REQUEST_ISOCH_FREE_RESOURCES;
; 481  :                         pIrb->Flags = 0;

  001b1	21 42 04	 and	 DWORD PTR [edx+4], eax

; 482  :                         pIrb->u.IsochFreeResources.hResource = IsochResourceData->hResource;

  001b4	8b 44 24 14	 mov	 eax, DWORD PTR _Entry$8969[esp+32]

; 483  : 
; 484  :                         ntStatus = t1394_SubmitIrpSynch(deviceExtension->StackDeviceObject, ResourceIrp, pIrb);

  001b8	52		 push	 edx
  001b9	ff 74 24 28	 push	 DWORD PTR _ResourceIrp$8839[esp+32]
  001bd	c7 02 0a 00 00
	00		 mov	 DWORD PTR [edx], 10	; 0000000aH
  001c3	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  001c6	89 42 48	 mov	 DWORD PTR [edx+72], eax
  001c9	ff 36		 push	 DWORD PTR [esi]
  001cb	e8 00 00 00 00	 call	 _t1394_SubmitIrpSynch@12

; 485  : 
; 486  :                         if (!NT_SUCCESS(ntStatus)) {
; 487  : 
; 488  :                             TRACE(TL_ERROR, ("SubmitIrpSync failed = 0x%x\n", ntStatus));
; 489  :                         }
; 490  : 
; 491  :                         ExFreePool(pIrb);

  001d0	ff 74 24 18	 push	 DWORD PTR _pIrb$8838[esp+32]
  001d4	89 44 24 14	 mov	 DWORD PTR _ntStatus$[esp+36], eax
  001d8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePool@4

; 492  :                         IoFreeIrp(ResourceIrp);

  001de	ff 74 24 24	 push	 DWORD PTR _ResourceIrp$8839[esp+28]
$L8990:
  001e2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoFreeIrp@4
$L8846:

; 433  :             break;
; 434  :         }
; 435  :     }
; 436  : 
; 437  :     // remove any isoch resource data
; 438  :     while (TRUE) {
; 439  : 
; 440  :         KeAcquireSpinLock(&deviceExtension->IsochResourceSpinLock, &Irql);

  001e8	8d 7e 24	 lea	 edi, DWORD PTR [esi+36]
  001eb	8b cf		 mov	 ecx, edi
  001ed	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@KfAcquireSpinLock@4
$L8989:

; 441  : 
; 442  :         if (!IsListEmpty(&deviceExtension->IsochResourceData)) {

  001f3	39 6d 00	 cmp	 DWORD PTR [ebp], ebp

; 493  :                     }
; 494  :                 }
; 495  :             }
; 496  :         }
; 497  :         else {
; 498  : 
; 499  :             KeReleaseSpinLock(&deviceExtension->IsochResourceSpinLock, Irql);

  001f6	8a d0		 mov	 dl, al
  001f8	0f 85 59 ff ff
	ff		 jne	 $L8832
  001fe	8b cf		 mov	 ecx, edi
  00200	ff d3		 call	 ebx

; 500  :             break;
; 501  :         }
; 502  :     }
; 503  : 
; 504  :     // get rid of any pending bus reset notify requests
; 505  :     KeAcquireSpinLock(&deviceExtension->ResetSpinLock, &Irql);

  00202	8d 6e 14	 lea	 ebp, DWORD PTR [esi+20]
  00205	8b cd		 mov	 ecx, ebp
  00207	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@KfAcquireSpinLock@4
  0020d	88 44 24 24	 mov	 BYTE PTR _Irql$[esp+28], al

; 506  : 
; 507  :     while (!IsListEmpty(&deviceExtension->BusResetIrps)) {

  00211	83 c6 38	 add	 esi, 56			; 00000038H
  00214	eb 30		 jmp	 SHORT $L8991
$L8852:

; 508  : 
; 509  :         PBUS_RESET_IRP  BusResetIrp;
; 510  :         PDRIVER_CANCEL  prevCancel = NULL;
; 511  : 
; 512  :         // get the irp off of the list
; 513  :         BusResetIrp = (PBUS_RESET_IRP)RemoveHeadList(&deviceExtension->BusResetIrps);

  00216	8b 3e		 mov	 edi, DWORD PTR [esi]
  00218	8b 07		 mov	 eax, DWORD PTR [edi]
  0021a	89 06		 mov	 DWORD PTR [esi], eax
  0021c	89 70 04	 mov	 DWORD PTR [eax+4], esi

; 514  : 
; 515  :         TRACE(TL_TRACE, ("BusResetIrp = 0x%x\n", BusResetIrp));
; 516  : 
; 517  :         // make this irp non-cancelable...
; 518  :         prevCancel = IoSetCancelRoutine(BusResetIrp->Irp, NULL);

  0021f	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  00222	83 c1 38	 add	 ecx, 56			; 00000038H
  00225	33 d2		 xor	 edx, edx
  00227	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@InterlockedExchange@8

; 519  : 
; 520  :         TRACE(TL_TRACE, ("Surprise Removal: BusResetIrp->Irp = 0x%x\n", BusResetIrp->Irp));
; 521  : 
; 522  :         // and complete it...
; 523  :         BusResetIrp->Irp->IoStatus.Status = STATUS_SUCCESS;

  0022d	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  00230	83 60 18 00	 and	 DWORD PTR [eax+24], 0

; 524  :         IoCompleteRequest(BusResetIrp->Irp, IO_NO_INCREMENT);

  00234	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  00237	32 d2		 xor	 dl, dl
  00239	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@IofCompleteRequest@8

; 525  : 
; 526  :         ExFreePool(BusResetIrp);

  0023f	57		 push	 edi
  00240	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePool@4
$L8991:

; 506  : 
; 507  :     while (!IsListEmpty(&deviceExtension->BusResetIrps)) {

  00246	39 36		 cmp	 DWORD PTR [esi], esi
  00248	75 cc		 jne	 SHORT $L8852

; 527  :     }
; 528  : 
; 529  :     KeReleaseSpinLock(&deviceExtension->ResetSpinLock, Irql);

  0024a	8a 54 24 24	 mov	 dl, BYTE PTR _Irql$[esp+28]
  0024e	8b cd		 mov	 ecx, ebp
  00250	ff d3		 call	 ebx

; 530  : 
; 531  :     // free up the symbolic link
; 532  :     RtlFreeUnicodeString(&deviceExtension->SymbolicLinkName);

  00252	ff 74 24 1c	 push	 DWORD PTR tv327[esp+32]
  00256	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlFreeUnicodeString@4

; 533  : 
; 534  :     EXIT("t1394VDev_PnpRemoveDevice", ntStatus);
; 535  :     return(ntStatus);

  0025c	8b 44 24 10	 mov	 eax, DWORD PTR _ntStatus$[esp+32]
  00260	5f		 pop	 edi
  00261	5e		 pop	 esi
  00262	5d		 pop	 ebp
  00263	5b		 pop	 ebx

; 536  : } // t1394VDev_PnpRemoveDevice

  00264	83 c4 10	 add	 esp, 16			; 00000010H
  00267	c2 08 00	 ret	 8
_t1394VDev_PnpRemoveDevice@8 ENDP
_TEXT	ENDS
PUBLIC	_t1394VDev_Pnp@8
EXTRN	_t1394_SubmitIrpAsync@12:NEAR
EXTRN	__imp__IoDetachDevice@4:NEAR
; Function compile flags: /Ogsy
;	COMDAT _t1394VDev_Pnp@8
_TEXT	SEGMENT
_DeviceObject$ = 8					; size = 4
_Irp$ = 12						; size = 4
_t1394VDev_Pnp@8 PROC NEAR				; COMDAT

; 142  :     NTSTATUS                ntStatus = STATUS_SUCCESS;
; 143  :     PIO_STACK_LOCATION      IrpSp;
; 144  :     PDEVICE_EXTENSION       deviceExtension = DeviceObject->DeviceExtension;

  00000	8b 54 24 04	 mov	 edx, DWORD PTR _DeviceObject$[esp-4]
  00004	53		 push	 ebx
  00005	56		 push	 esi
  00006	8b 72 28	 mov	 esi, DWORD PTR [edx+40]
  00009	57		 push	 edi

; 145  : 
; 146  :     PDEVICE_CAPABILITIES    DeviceCapabilities;
; 147  : 
; 148  :     ENTER("t1394VDev_Pnp");
; 149  :     
; 150  :     TRACE(TL_TRACE, ("DeviceObject = 0x%x\n", DeviceObject));
; 151  :     TRACE(TL_TRACE, ("Irp = 0x%x\n", Irp));
; 152  : 
; 153  :     IrpSp = IoGetCurrentIrpStackLocation(Irp);

  0000a	8b 7c 24 14	 mov	 edi, DWORD PTR _Irp$[esp+8]
  0000e	8b 47 60	 mov	 eax, DWORD PTR [edi+96]

; 154  : 
; 155  :     switch (IrpSp->MinorFunction) {

  00011	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]
  00015	83 f9 04	 cmp	 ecx, 4
  00018	7f 72		 jg	 SHORT $L8995
  0001a	74 67		 je	 SHORT $L8754
  0001c	33 db		 xor	 ebx, ebx
  0001e	2b cb		 sub	 ecx, ebx
  00020	74 37		 je	 SHORT $L8747
  00022	49		 dec	 ecx
  00023	74 2f		 je	 SHORT $L8759
  00025	49		 dec	 ecx
  00026	74 03		 je	 SHORT $L8765
  00028	49		 dec	 ecx

; 236  : 
; 237  :         case IRP_MN_CANCEL_REMOVE_DEVICE:
; 238  :             TRACE(TL_TRACE, ("t1394VDev_Pnp: IRP_MN_CANCEL_REMOVE_DEVICE\n"));
; 239  : 
; 240  :             // pass down to layer below us first.
; 241  :             ntStatus = t1394_SubmitIrpAsync(deviceExtension->StackDeviceObject, Irp, NULL);
; 242  :             break;

  00029	eb 75		 jmp	 SHORT $L8772
$L8765:

; 222  : 
; 223  :         case IRP_MN_REMOVE_DEVICE:
; 224  :             TRACE(TL_TRACE, ("t1394VDev_Pnp: IRP_MN_REMOVE_DEVICE\n"));
; 225  : 
; 226  :             ntStatus = t1394VDev_PnpRemoveDevice(DeviceObject, Irp);

  0002b	57		 push	 edi
  0002c	52		 push	 edx
  0002d	e8 00 00 00 00	 call	 _t1394VDev_PnpRemoveDevice@8

; 227  :             
; 228  :             // pass down to layer below us...
; 229  :             Irp->IoStatus.Status = STATUS_SUCCESS;
; 230  :             ntStatus = t1394_SubmitIrpAsync(deviceExtension->StackDeviceObject, Irp, NULL);

  00032	53		 push	 ebx
  00033	57		 push	 edi
  00034	89 5f 18	 mov	 DWORD PTR [edi+24], ebx
  00037	ff 36		 push	 DWORD PTR [esi]
  00039	e8 00 00 00 00	 call	 _t1394_SubmitIrpAsync@12

; 231  :             
; 232  :             // delete our device, we have to do this after we send the request down
; 233  :             IoDetachDevice(deviceExtension->StackDeviceObject);

  0003e	ff 36		 push	 DWORD PTR [esi]
  00040	8b d8		 mov	 ebx, eax
  00042	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoDetachDevice@4

; 234  :             IoDeleteDevice(DeviceObject);                                          

  00048	ff 74 24 10	 push	 DWORD PTR _DeviceObject$[esp+8]
  0004c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoDeleteDevice@4

; 235  :             break;

  00052	eb 6f		 jmp	 SHORT $L8744
$L8759:

; 195  : 
; 196  :         case IRP_MN_CANCEL_STOP_DEVICE:
; 197  :             TRACE(TL_TRACE, ("t1394VDev_Pnp: IRP_MN_CANCEL_STOP_DEVICE\n"));
; 198  : 
; 199  :             // pass down to layer below us first.
; 200  :             ntStatus = t1394_SubmitIrpAsync(deviceExtension->StackDeviceObject, Irp, NULL);
; 201  :             break;
; 202  : 
; 203  :         case IRP_MN_QUERY_REMOVE_DEVICE:
; 204  :             TRACE(TL_TRACE, ("t1394VDev_Pnp: IRP_MN_QUERY_REMOVE_DEVICE\n"));
; 205  : 
; 206  :             Irp->IoStatus.Status = STATUS_SUCCESS;

  00054	89 5f 18	 mov	 DWORD PTR [edi+24], ebx

; 207  : 
; 208  :             // pass down to layer below us...
; 209  :             ntStatus = t1394_SubmitIrpAsync(deviceExtension->StackDeviceObject, Irp, NULL);
; 210  :             break;

  00057	eb 47		 jmp	 SHORT $L8772
$L8747:

; 156  : 
; 157  :         case IRP_MN_START_DEVICE:
; 158  :             TRACE(TL_TRACE, ("t1394VDev_Pnp: IRP_MN_START_DEVICE\n"));
; 159  : 
; 160  :             // pass down to layer below us first.
; 161  :             ntStatus = t1394_SubmitIrpSynch(deviceExtension->StackDeviceObject, Irp, NULL);

  00059	53		 push	 ebx
  0005a	57		 push	 edi
  0005b	ff 36		 push	 DWORD PTR [esi]
  0005d	e8 00 00 00 00	 call	 _t1394_SubmitIrpSynch@12
  00062	8b d8		 mov	 ebx, eax

; 162  : 
; 163  :             if (!NT_SUCCESS(ntStatus)) {

  00064	85 db		 test	 ebx, ebx
  00066	7c 0c		 jl	 SHORT $L8751

; 164  : 
; 165  :                 TRACE(TL_ERROR, ("Error submitting Irp!\n"))
; 166  :             }
; 167  :             else {
; 168  :             
; 169  :                 ntStatus = t1394VDev_PnpStartDevice(DeviceObject, Irp);

  00068	57		 push	 edi
  00069	ff 74 24 14	 push	 DWORD PTR _DeviceObject$[esp+12]
  0006d	e8 00 00 00 00	 call	 _t1394VDev_PnpStartDevice@8
  00072	8b d8		 mov	 ebx, eax
$L8751:

; 170  :             }
; 171  :             
; 172  :             Irp->IoStatus.Status = ntStatus;
; 173  :             IoCompleteRequest(Irp, IO_NO_INCREMENT);

  00074	32 d2		 xor	 dl, dl
  00076	8b cf		 mov	 ecx, edi
  00078	89 5f 18	 mov	 DWORD PTR [edi+24], ebx
  0007b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@IofCompleteRequest@8

; 174  :             break;

  00081	eb 40		 jmp	 SHORT $L8744
$L8754:

; 181  :             break;
; 182  : 
; 183  :         case IRP_MN_STOP_DEVICE:
; 184  :             TRACE(TL_TRACE, ("t1394VDev_Pnp: IRP_MN_STOP_DEVICE\n"));
; 185  : 
; 186  :             ntStatus = t1394VDev_PnpStopDevice(DeviceObject, Irp);

  00083	57		 push	 edi
  00084	52		 push	 edx
  00085	e8 00 00 00 00	 call	 _t1394VDev_PnpStopDevice@8

; 187  : 
; 188  :             // i'm not allowed to fail here. if i needed to fail, i should have done it
; 189  :             // at the query_stop_device request.
; 190  :             Irp->IoStatus.Status = STATUS_SUCCESS;
; 191  : 
; 192  :             // pass down to layer below us...
; 193  :             ntStatus = t1394_SubmitIrpAsync(deviceExtension->StackDeviceObject, Irp, NULL);
; 194  :             break;

  0008a	eb 1e		 jmp	 SHORT $L8997
$L8995:

; 154  : 
; 155  :     switch (IrpSp->MinorFunction) {

  0008c	83 e9 05	 sub	 ecx, 5
  0008f	74 26		 je	 SHORT $L8752
  00091	49		 dec	 ecx
  00092	74 23		 je	 SHORT $L8752
  00094	83 e9 03	 sub	 ecx, 3
  00097	74 17		 je	 SHORT $L8770
  00099	83 e9 0e	 sub	 ecx, 14			; 0000000eH
  0009c	74 05		 je	 SHORT $L8762
  0009e	33 db		 xor	 ebx, ebx
$L8772:

; 249  : 
; 250  :             ntStatus = t1394_SubmitIrpAsync(deviceExtension->StackDeviceObject, Irp, NULL);
; 251  :             break;
; 252  : 
; 253  :         default:
; 254  :             TRACE(TL_TRACE, ("Unsupported Pnp Function = 0x%x\n", IrpSp->MinorFunction));
; 255  : 
; 256  :             // pass down to layer below us...
; 257  :             ntStatus = t1394_SubmitIrpAsync (deviceExtension->StackDeviceObject, Irp, NULL);

  000a0	53		 push	 ebx

; 258  :             break;

  000a1	eb 16		 jmp	 SHORT $L8996
$L8762:

; 211  : 
; 212  :         case IRP_MN_SURPRISE_REMOVAL:
; 213  : 
; 214  :             TRACE(TL_TRACE, ("t1394VDev_Pnp: IRP_MN_SURPRISE_REMOVAL\n"));
; 215  :              
; 216  :             ntStatus = t1394VDev_PnpRemoveDevice(DeviceObject, Irp);

  000a3	57		 push	 edi
  000a4	52		 push	 edx
  000a5	e8 00 00 00 00	 call	 _t1394VDev_PnpRemoveDevice@8
$L8997:

; 217  :              
; 218  :             // pass the request down
; 219  :             Irp->IoStatus.Status = STATUS_SUCCESS;

  000aa	83 67 18 00	 and	 DWORD PTR [edi+24], 0

; 220  :             ntStatus = t1394_SubmitIrpAsync(deviceExtension->StackDeviceObject, Irp, NULL);
; 221  :             break;

  000ae	eb 07		 jmp	 SHORT $L8752
$L8770:

; 243  : 
; 244  :         case IRP_MN_QUERY_CAPABILITIES:
; 245  :             TRACE(TL_TRACE, ("t1394VDev_Pnp: IRP_MN_QUERY_CAPABILITIES\n"));
; 246  : 
; 247  :             DeviceCapabilities = IrpSp->Parameters.DeviceCapabilities.Capabilities;

  000b0	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 248  :             DeviceCapabilities->SurpriseRemovalOK = TRUE;

  000b3	80 48 05 02	 or	 BYTE PTR [eax+5], 2
$L8752:

; 175  : 
; 176  :         case IRP_MN_QUERY_STOP_DEVICE:
; 177  :             TRACE(TL_TRACE, ("t1394VDev_Pnp: IRP_MN_QUERY_STOP_DEVICE\n"));
; 178  : 
; 179  :             // pass down to layer below us...
; 180  :             ntStatus = t1394_SubmitIrpAsync(deviceExtension->StackDeviceObject, Irp, NULL);

  000b7	6a 00		 push	 0
$L8996:
  000b9	57		 push	 edi
  000ba	ff 36		 push	 DWORD PTR [esi]
  000bc	e8 00 00 00 00	 call	 _t1394_SubmitIrpAsync@12
  000c1	8b d8		 mov	 ebx, eax
$L8744:
  000c3	5f		 pop	 edi
  000c4	5e		 pop	 esi

; 259  : 
; 260  :     } // switch
; 261  : 
; 262  :     EXIT("t1394VDev_Pnp", ntStatus);
; 263  :     return(ntStatus);

  000c5	8b c3		 mov	 eax, ebx
  000c7	5b		 pop	 ebx

; 264  : } // t1394Vdev_Pnp

  000c8	c2 08 00	 ret	 8
_t1394VDev_Pnp@8 ENDP
_TEXT	ENDS
END

