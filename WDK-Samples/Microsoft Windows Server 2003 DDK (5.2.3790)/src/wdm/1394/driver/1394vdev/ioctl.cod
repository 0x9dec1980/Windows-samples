; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.2190 

	TITLE	.\ioctl.c
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT _RemoveEntryList@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _InsertHeadList@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _t1394VDev_IoControl@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _GUID_1394VDEV
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT _GUID_1394DIAG
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT _BUS1394_CLASS_GUID
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
sxdata	SEGMENT DWORD USE32 'SXDATA'
sxdata	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBC
INCLUDELIB OLDNAMES

PUBLIC	_BUS1394_CLASS_GUID
PUBLIC	_GUID_1394DIAG
PUBLIC	_GUID_1394VDEV
;	COMDAT _BUS1394_CLASS_GUID
CONST	SEGMENT
_BUS1394_CLASS_GUID DD 06bdd1fc1H
	DW	0810fH
	DW	011d0H
	DB	0beH
	DB	0c7H
	DB	08H
	DB	00H
	DB	02bH
	DB	0e2H
	DB	09H
	DB	02fH
CONST	ENDS
;	COMDAT _GUID_1394DIAG
CONST	SEGMENT
_GUID_1394DIAG DD 0c459df55H
	DW	0db08H
	DW	011d1H
	DB	0b0H
	DB	09H
	DB	00H
	DB	0a0H
	DB	0c9H
	DB	08H
	DB	01fH
	DB	0f6H
CONST	ENDS
;	COMDAT _GUID_1394VDEV
CONST	SEGMENT
_GUID_1394VDEV DD 0737613e5H
	DW	069eaH
	DW	04b96H
	DB	09cH
	DB	02aH
	DB	0eeH
	DB	0bcH
	DB	022H
	DB	0fH
	DB	04cH
	DB	039H
CONST	ENDS
PUBLIC	_RemoveEntryList@4
; Function compile flags: /Ogsy
; File d:\srv03rtm\public\sdk\inc\wdm.h
;	COMDAT _RemoveEntryList@4
_TEXT	SEGMENT
_Entry$ = 8						; size = 4
_RemoveEntryList@4 PROC NEAR				; COMDAT

; 1540 :     PLIST_ENTRY Blink;
; 1541 :     PLIST_ENTRY Flink;
; 1542 : 
; 1543 :     Flink = Entry->Flink;

  00000	8b 4c 24 04	 mov	 ecx, DWORD PTR _Entry$[esp-4]
  00004	8b 01		 mov	 eax, DWORD PTR [ecx]

; 1544 :     Blink = Entry->Blink;

  00006	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]

; 1545 :     Blink->Flink = Flink;

  00009	89 01		 mov	 DWORD PTR [ecx], eax

; 1546 :     Flink->Blink = Blink;
; 1547 :     return (BOOLEAN)(Flink == Blink);

  0000b	3b c1		 cmp	 eax, ecx
  0000d	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00010	0f 94 c0	 sete	 al

; 1548 : }

  00013	c2 04 00	 ret	 4
_RemoveEntryList@4 ENDP
_TEXT	ENDS
PUBLIC	_InsertHeadList@8
; Function compile flags: /Ogsy
;	COMDAT _InsertHeadList@8
_TEXT	SEGMENT
_ListHead$ = 8						; size = 4
_Entry$ = 12						; size = 4
_InsertHeadList@8 PROC NEAR				; COMDAT

; 1609 :     PLIST_ENTRY Flink;
; 1610 : 
; 1611 :     Flink = ListHead->Flink;

  00000	8b 4c 24 04	 mov	 ecx, DWORD PTR _ListHead$[esp-4]
  00004	8b 11		 mov	 edx, DWORD PTR [ecx]

; 1612 :     Entry->Flink = Flink;

  00006	8b 44 24 08	 mov	 eax, DWORD PTR _Entry$[esp-4]
  0000a	89 10		 mov	 DWORD PTR [eax], edx

; 1613 :     Entry->Blink = ListHead;

  0000c	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 1614 :     Flink->Blink = Entry;

  0000f	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 1615 :     ListHead->Flink = Entry;

  00012	89 01		 mov	 DWORD PTR [ecx], eax

; 1616 : }

  00014	c2 08 00	 ret	 8
_InsertHeadList@8 ENDP
_TEXT	ENDS
PUBLIC	_t1394VDev_IoControl@8
EXTRN	_t1394_Control@8:NEAR
EXTRN	_t1394_GetMaxSpeedBetweenDevices@24:NEAR
EXTRN	_t1394_SetDeviceXmitProperties@16:NEAR
EXTRN	_t1394_GetConfigurationInformation@8:NEAR
EXTRN	_t1394_BusReset@12:NEAR
EXTRN	_t1394_GetGenerationCount@12:NEAR
EXTRN	_t1394_SendPhyConfigurationPacket@16:NEAR
EXTRN	_t1394_BusResetNotification@12:NEAR
EXTRN	_t1394_SetLocalHostProperties@16:NEAR
EXTRN	_t1394_AllocateAddressRange@44:NEAR
EXTRN	_t1394_FreeAddressRange@12:NEAR
EXTRN	_t1394_SetAddressData@24:NEAR
EXTRN	_t1394_GetAddressData@24:NEAR
EXTRN	_t1394_AsyncRead@48:NEAR
EXTRN	_t1394_AsyncWrite@48:NEAR
EXTRN	_t1394_AsyncLock@60:NEAR
EXTRN	_t1394_AsyncStream@36:NEAR
EXTRN	_t1394_IsochAllocateBandwidth@28:NEAR
EXTRN	_t1394_IsochAllocateChannel@20:NEAR
EXTRN	_t1394_IsochAllocateResources@40:NEAR
EXTRN	_t1394_IsochAttachBuffers@28:NEAR
EXTRN	_t1394_IsochDetachBuffers@20:NEAR
EXTRN	_t1394_IsochFreeBandwidth@12:NEAR
EXTRN	_t1394_IsochFreeChannel@12:NEAR
EXTRN	_t1394_IsochFreeResources@12:NEAR
EXTRN	_t1394_IsochListen@20:NEAR
EXTRN	_t1394_IsochQueryCurrentCycleTime@12:NEAR
EXTRN	_t1394_IsochQueryResources@20:NEAR
EXTRN	_t1394_IsochSetChannelBandwidth@16:NEAR
EXTRN	_t1394_IsochModifyStreamProperties@24:NEAR
EXTRN	_t1394_IsochStop@16:NEAR
EXTRN	_t1394_IsochTalk@20:NEAR
EXTRN	_t1394_SubmitIrpAsync@12:NEAR
EXTRN	_t1394VDev_CancelIrp@8:NEAR
EXTRN	__imp_@KfAcquireSpinLock@4:NEAR
EXTRN	__imp_@IofCompleteRequest@8:NEAR
EXTRN	__imp_@KfReleaseSpinLock@8:NEAR
EXTRN	__imp__ExAllocatePoolWithTag@12:NEAR
EXTRN	__imp_@InterlockedExchange@8:NEAR
EXTRN	_t1394_GetLocalHostInformation@20:NEAR
EXTRN	_t1394_Get1394AddressFromDeviceObject@16:NEAR
; Function compile flags: /Ogsy
; File d:\srv03rtm\drivers\wdm\1394\tools\test\driver\1394vdev\ioctl.c
;	COMDAT _t1394VDev_IoControl@8
_TEXT	SEGMENT
_outputBufferLength$ = -12				; size = 4
_i$8846 = -8						; size = 4
_deviceExtension$ = -8					; size = 4
_ulBuffSize$8845 = -4					; size = 4
_DeviceObject$ = 8					; size = 4
_Irql$9068 = 11						; size = 1
tv1113 = 12						; size = 4
_inputBufferLength$ = 12				; size = 4
_Irp$ = 12						; size = 4
_t1394VDev_IoControl@8 PROC NEAR			; COMDAT

; 29   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 30   :     NTSTATUS                ntStatus = STATUS_SUCCESS;
; 31   :     PIO_STACK_LOCATION      IrpSp;
; 32   :     PDEVICE_EXTENSION       deviceExtension;
; 33   :     PVOID                   ioBuffer;
; 34   :     ULONG                   inputBufferLength;
; 35   :     ULONG                   outputBufferLength;
; 36   :     ULONG                   ioControlCode;
; 37   :     
; 38   :     ENTER("t1394VDev_IoControl");
; 39   : 
; 40   :     // Get a pointer to the current location in the Irp. This is where
; 41   :     // the function codes and parameters are located.
; 42   :     IrpSp = IoGetCurrentIrpStackLocation(Irp);
; 43   : 
; 44   :     // Get a pointer to the device extension
; 45   :     deviceExtension = DeviceObject->DeviceExtension;

  00006	8b 45 08	 mov	 eax, DWORD PTR _DeviceObject$[ebp]
  00009	8b 50 28	 mov	 edx, DWORD PTR [eax+40]
  0000c	53		 push	 ebx
  0000d	8b 5d 0c	 mov	 ebx, DWORD PTR _Irp$[ebp]
  00010	8b 4b 60	 mov	 ecx, DWORD PTR [ebx+96]

; 46   : 
; 47   :     // Get the pointer to the input/output buffer and it's length
; 48   :     ioBuffer           = Irp->AssociatedIrp.SystemBuffer;

  00013	8b 43 0c	 mov	 eax, DWORD PTR [ebx+12]
  00016	56		 push	 esi
  00017	57		 push	 edi

; 49   :     inputBufferLength  = IrpSp->Parameters.DeviceIoControl.InputBufferLength;

  00018	8b 79 08	 mov	 edi, DWORD PTR [ecx+8]
  0001b	89 7d 0c	 mov	 DWORD PTR _inputBufferLength$[ebp], edi

; 50   :     outputBufferLength = IrpSp->Parameters.DeviceIoControl.OutputBufferLength;

  0001e	8b 79 04	 mov	 edi, DWORD PTR [ecx+4]
  00021	33 f6		 xor	 esi, esi

; 51   : 
; 52   :     // make sure our device isn't in shutdown mode...
; 53   :     if (deviceExtension->bShutdown) {

  00023	80 7a 28 00	 cmp	 BYTE PTR [edx+40], 0
  00027	89 55 f8	 mov	 DWORD PTR _deviceExtension$[ebp], edx
  0002a	89 7d f4	 mov	 DWORD PTR _outputBufferLength$[ebp], edi
  0002d	74 0a		 je	 SHORT $L8722

; 54   : 
; 55   :         Irp->IoStatus.Status = STATUS_NO_SUCH_DEVICE;

  0002f	be 0e 00 00 c0	 mov	 esi, -1073741810	; c000000eH

; 56   :         IoCompleteRequest(Irp, IO_NO_INCREMENT);
; 57   :         ntStatus = STATUS_NO_SUCH_DEVICE;
; 58   :         return(ntStatus);

  00034	e9 fc 07 00 00	 jmp	 $L9159
$L8722:

; 59   :     }
; 60   : 
; 61   :     TRACE(TL_TRACE, ("Irp = 0x%x\n", Irp));
; 62   : 
; 63   :     switch (IrpSp->MajorFunction) {

  00039	80 39 0e	 cmp	 BYTE PTR [ecx], 14	; 0000000eH
  0003c	74 0f		 je	 SHORT $L8729

; 1064 : 
; 1065 :             } // switch
; 1066 : 
; 1067 :             break; // IRP_MJ_DEVICE_CONTROL
; 1068 : 
; 1069 :         default:
; 1070 :             TRACE(TL_TRACE, ("Unknown IrpSp->MajorFunction = 0x%x\n", IrpSp->MajorFunction));
; 1071 : 
; 1072 :             // submit this to the driver below us
; 1073 :             ntStatus = t1394_SubmitIrpAsync (deviceExtension->StackDeviceObject, Irp, NULL);

  0003e	6a 00		 push	 0
  00040	53		 push	 ebx
  00041	ff 32		 push	 DWORD PTR [edx]
  00043	e8 00 00 00 00	 call	 _t1394_SubmitIrpAsync@12

; 1074 :             return (ntStatus);

  00048	e9 f7 07 00 00	 jmp	 $L8713
$L8729:

; 64   : 
; 65   :         case IRP_MJ_DEVICE_CONTROL:
; 66   :             TRACE(TL_TRACE, ("t1394VDev_IoControl: IRP_MJ_DEVICE_CONTROL\n"));
; 67   : 
; 68   :             ioControlCode = IrpSp->Parameters.DeviceIoControl.IoControlCode;

  0004d	8b 49 0c	 mov	 ecx, DWORD PTR [ecx+12]

; 69   : 
; 70   :             switch (ioControlCode) {

  00050	ba 48 20 22 00	 mov	 edx, 2236488		; 00222048H
  00055	3b ca		 cmp	 ecx, edx
  00057	0f 87 38 04 00
	00		 ja	 $L9138
  0005d	0f 84 12 04 00
	00		 je	 $L8945
  00063	83 c2 dc	 add	 edx, -36		; ffffffdcH
  00066	3b ca		 cmp	 ecx, edx
  00068	0f 87 d9 02 00
	00		 ja	 $L9139
  0006e	0f 84 b3 02 00
	00		 je	 $L8872
  00074	ba 10 20 22 00	 mov	 edx, 2236432		; 00222010H
  00079	3b ca		 cmp	 ecx, edx
  0007b	0f 87 6f 01 00
	00		 ja	 $L9140
  00081	0f 84 0d 01 00
	00		 je	 $L8780
  00087	81 e9 00 20 22
	00		 sub	 ecx, 2236416		; 00222000H
  0008d	0f 84 c3 00 00
	00		 je	 $L8734
  00093	6a 04		 push	 4
  00095	5a		 pop	 edx
  00096	2b ca		 sub	 ecx, edx
  00098	0f 84 9f 00 00
	00		 je	 $L8746
  0009e	2b ca		 sub	 ecx, edx
  000a0	74 4e		 je	 SHORT $L8752
  000a2	2b ca		 sub	 ecx, edx
  000a4	0f 85 87 06 00
	00		 jne	 $L9104

; 157  :                             }
; 158  :                         }
; 159  :                     }
; 160  :                     break; // IOCTL_ASYNC_READ
; 161  : 
; 162  :                 case IOCTL_ASYNC_WRITE:
; 163  :                     {
; 164  :                         PASYNC_WRITE    AsyncWrite;
; 165  : 
; 166  :                         TRACE(TL_TRACE, ("IOCTL_ASYNC_WRITE\n"));
; 167  : 
; 168  :                         if (inputBufferLength < sizeof(ASYNC_WRITE)) {

  000aa	8b 55 0c	 mov	 edx, DWORD PTR _inputBufferLength$[ebp]
  000ad	83 fa 28	 cmp	 edx, 40			; 00000028H

; 169  : 
; 170  :                             ntStatus = STATUS_BUFFER_TOO_SMALL;
; 171  :                         }
; 172  :                         else {

  000b0	0f 82 af 06 00
	00		 jb	 $L9167

; 173  : 
; 174  :                             AsyncWrite = (PASYNC_WRITE)ioBuffer;
; 175  : 
; 176  :                             if (inputBufferLength-sizeof(ASYNC_WRITE) < AsyncWrite->nNumberOfBytesToWrite) {

  000b6	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  000b9	83 c2 d8	 add	 edx, -40		; ffffffd8H
  000bc	3b d1		 cmp	 edx, ecx

; 177  : 
; 178  :                                 ntStatus = STATUS_BUFFER_TOO_SMALL;
; 179  :                             }
; 180  :                             else {

  000be	0f 82 a1 06 00
	00		 jb	 $L9167

; 181  : 
; 182  :                                 ntStatus = t1394_AsyncWrite( DeviceObject,
; 183  :                                                                  Irp,
; 184  :                                                                  AsyncWrite->bRawMode,
; 185  :                                                                  AsyncWrite->bGetGeneration,
; 186  :                                                                  AsyncWrite->DestinationAddress,
; 187  :                                                                  AsyncWrite->nNumberOfBytesToWrite,
; 188  :                                                                  AsyncWrite->nBlockSize,
; 189  :                                                                  AsyncWrite->fulFlags,
; 190  :                                                                  AsyncWrite->ulGeneration,
; 191  :                                                                  (PULONG)&AsyncWrite->Data
; 192  :                                                                  );

  000c4	8d 50 24	 lea	 edx, DWORD PTR [eax+36]
  000c7	52		 push	 edx
  000c8	ff 70 20	 push	 DWORD PTR [eax+32]
  000cb	8d 70 08	 lea	 esi, DWORD PTR [eax+8]
  000ce	ff 70 1c	 push	 DWORD PTR [eax+28]
  000d1	ff 70 18	 push	 DWORD PTR [eax+24]
  000d4	51		 push	 ecx
  000d5	83 ec 0c	 sub	 esp, 12			; 0000000cH
  000d8	8b fc		 mov	 edi, esp
  000da	ff 70 04	 push	 DWORD PTR [eax+4]
  000dd	a5		 movsd
  000de	ff 30		 push	 DWORD PTR [eax]
  000e0	a5		 movsd
  000e1	53		 push	 ebx
  000e2	ff 75 08	 push	 DWORD PTR _DeviceObject$[ebp]
  000e5	a5		 movsd
  000e6	e8 00 00 00 00	 call	 _t1394_AsyncWrite@48

; 193  :                             }
; 194  :                         }
; 195  :                     }
; 196  :                     break; // IOCTL_ASYNC_WRITE

  000eb	e9 5e 05 00 00	 jmp	 $L9164
$L8752:

; 121  : 
; 122  :                 case IOCTL_ASYNC_READ:
; 123  :                     {
; 124  :                         PASYNC_READ     AsyncRead;
; 125  : 
; 126  :                         TRACE(TL_TRACE, ("IOCTL_ASYNC_READ\n"));
; 127  : 
; 128  :                         if (inputBufferLength < sizeof(ASYNC_READ)) {

  000f0	83 7d 0c 28	 cmp	 DWORD PTR _inputBufferLength$[ebp], 40 ; 00000028H

; 129  : 
; 130  :                             ntStatus = STATUS_BUFFER_TOO_SMALL;
; 131  :                         }
; 132  :                         else {

  000f4	0f 82 6b 06 00
	00		 jb	 $L9167

; 133  : 
; 134  :                             AsyncRead = (PASYNC_READ)ioBuffer;
; 135  : 
; 136  :                             if ((outputBufferLength < sizeof(ASYNC_READ)) || 
; 137  :                                 (outputBufferLength-sizeof(ASYNC_READ) < AsyncRead->nNumberOfBytesToRead)) {

  000fa	83 ff 28	 cmp	 edi, 40			; 00000028H
  000fd	0f 82 11 06 00
	00		 jb	 $L9053
  00103	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00106	83 c7 d8	 add	 edi, -40		; ffffffd8H
  00109	3b f9		 cmp	 edi, ecx
  0010b	0f 82 03 06 00
	00		 jb	 $L9053

; 138  : 
; 139  :                                 ntStatus = STATUS_BUFFER_TOO_SMALL;
; 140  :                             }
; 141  :                             else {
; 142  : 
; 143  :                                 ntStatus = t1394_AsyncRead( DeviceObject,
; 144  :                                                                 Irp,
; 145  :                                                                 AsyncRead->bRawMode,
; 146  :                                                                 AsyncRead->bGetGeneration,
; 147  :                                                                 AsyncRead->DestinationAddress,
; 148  :                                                                 AsyncRead->nNumberOfBytesToRead,
; 149  :                                                                 AsyncRead->nBlockSize,
; 150  :                                                                 AsyncRead->fulFlags,
; 151  :                                                                 AsyncRead->ulGeneration,
; 152  :                                                                 (PULONG)&AsyncRead->Data
; 153  :                                                                 );

  00111	8d 50 24	 lea	 edx, DWORD PTR [eax+36]
  00114	52		 push	 edx
  00115	ff 70 20	 push	 DWORD PTR [eax+32]
  00118	8d 70 08	 lea	 esi, DWORD PTR [eax+8]
  0011b	ff 70 1c	 push	 DWORD PTR [eax+28]
  0011e	ff 70 18	 push	 DWORD PTR [eax+24]
  00121	51		 push	 ecx
  00122	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00125	8b fc		 mov	 edi, esp
  00127	ff 70 04	 push	 DWORD PTR [eax+4]
  0012a	a5		 movsd
  0012b	ff 30		 push	 DWORD PTR [eax]
  0012d	a5		 movsd
  0012e	53		 push	 ebx
  0012f	ff 75 08	 push	 DWORD PTR _DeviceObject$[ebp]
  00132	a5		 movsd
  00133	e8 00 00 00 00	 call	 _t1394_AsyncRead@48

; 154  : 
; 155  :                                 if (NT_SUCCESS(ntStatus))
; 156  :                                     Irp->IoStatus.Information = outputBufferLength;

  00138	e9 9e 00 00 00	 jmp	 $L9163
$L8746:

; 102  :                         }
; 103  :                     }
; 104  :                     break; // IOCTL_ALLOCATE_ADDRESS_RANGE
; 105  : 
; 106  :                 case IOCTL_FREE_ADDRESS_RANGE:
; 107  :                     TRACE(TL_TRACE, ("IOCTL_FREE_ADDRESS_RANGE\n"));
; 108  : 
; 109  :                     if (inputBufferLength < sizeof(HANDLE)) {

  0013d	39 55 0c	 cmp	 DWORD PTR _inputBufferLength$[ebp], edx

; 110  : 
; 111  :                         ntStatus = STATUS_BUFFER_TOO_SMALL;
; 112  :                     }
; 113  :                     else {

  00140	0f 82 1f 06 00
	00		 jb	 $L9167

; 114  : 
; 115  :                         ntStatus = t1394_FreeAddressRange( DeviceObject,
; 116  :                                                                Irp,
; 117  :                                                                *(PHANDLE)ioBuffer
; 118  :                                                                );

  00146	ff 30		 push	 DWORD PTR [eax]
  00148	53		 push	 ebx
  00149	ff 75 08	 push	 DWORD PTR _DeviceObject$[ebp]
  0014c	e8 00 00 00 00	 call	 _t1394_FreeAddressRange@12

; 119  :                     }
; 120  :                     break; // IOCTL_FREE_ADDRESS_RANGE

  00151	e9 f8 04 00 00	 jmp	 $L9164
$L8734:

; 71   : 
; 72   :                 case IOCTL_ALLOCATE_ADDRESS_RANGE:
; 73   :                     {
; 74   :                         PALLOCATE_ADDRESS_RANGE     AllocateAddressRange;
; 75   : 
; 76   :                         TRACE(TL_TRACE, ("IOCTL_ALLOCATE_ADDRESS_RANGE\n"));
; 77   : 
; 78   :                         if ((inputBufferLength < sizeof(ALLOCATE_ADDRESS_RANGE)) ||
; 79   :                             (outputBufferLength < sizeof(ALLOCATE_ADDRESS_RANGE))) {

  00156	83 7d 0c 28	 cmp	 DWORD PTR _inputBufferLength$[ebp], 40 ; 00000028H
  0015a	0f 82 b4 05 00
	00		 jb	 $L9053
  00160	83 ff 28	 cmp	 edi, 40			; 00000028H
  00163	0f 82 ab 05 00
	00		 jb	 $L9053

; 80   : 
; 81   :                             ntStatus = STATUS_BUFFER_TOO_SMALL;
; 82   :                         }
; 83   :                         else {
; 84   : 
; 85   :                             AllocateAddressRange = (PALLOCATE_ADDRESS_RANGE)ioBuffer;
; 86   : 
; 87   :                             ntStatus = t1394_AllocateAddressRange( DeviceObject,
; 88   :                                                                        Irp,
; 89   :                                                                        AllocateAddressRange->fulAllocateFlags,
; 90   :                                                                        AllocateAddressRange->fulFlags,
; 91   :                                                                        AllocateAddressRange->nLength,
; 92   :                                                                        AllocateAddressRange->MaxSegmentSize,
; 93   :                                                                        AllocateAddressRange->fulAccessType,
; 94   :                                                                        AllocateAddressRange->fulNotificationOptions,
; 95   :                                                                        &AllocateAddressRange->Required1394Offset,
; 96   :                                                                        &AllocateAddressRange->hAddressRange,
; 97   :                                                                        (PULONG)&AllocateAddressRange->Data
; 98   :                                                                        );

  00169	8d 48 24	 lea	 ecx, DWORD PTR [eax+36]
  0016c	51		 push	 ecx
  0016d	8d 48 20	 lea	 ecx, DWORD PTR [eax+32]
  00170	51		 push	 ecx
  00171	8d 48 18	 lea	 ecx, DWORD PTR [eax+24]
  00174	51		 push	 ecx
  00175	ff 70 14	 push	 DWORD PTR [eax+20]
  00178	ff 70 10	 push	 DWORD PTR [eax+16]
  0017b	ff 70 0c	 push	 DWORD PTR [eax+12]
  0017e	ff 70 08	 push	 DWORD PTR [eax+8]
  00181	ff 70 04	 push	 DWORD PTR [eax+4]
  00184	ff 30		 push	 DWORD PTR [eax]
  00186	53		 push	 ebx
  00187	ff 75 08	 push	 DWORD PTR _DeviceObject$[ebp]
  0018a	e8 00 00 00 00	 call	 _t1394_AllocateAddressRange@44

; 99   : 
; 100  :                             if (NT_SUCCESS(ntStatus))
; 101  :                                 Irp->IoStatus.Information = outputBufferLength;

  0018f	e9 6e 05 00 00	 jmp	 $L9162
$L8780:

; 197  : 
; 198  :                 case IOCTL_ASYNC_LOCK:
; 199  :                     {
; 200  :                         PASYNC_LOCK     AsyncLock;
; 201  : 
; 202  :                         TRACE(TL_TRACE, ("IOCTL_ASYNC_LOCK\n"));
; 203  : 
; 204  :                         if ((inputBufferLength < sizeof(ASYNC_LOCK)) ||
; 205  :                             (outputBufferLength < sizeof(ASYNC_LOCK))) {

  00194	83 7d 0c 40	 cmp	 DWORD PTR _inputBufferLength$[ebp], 64 ; 00000040H
  00198	0f 82 76 05 00
	00		 jb	 $L9053
  0019e	83 ff 40	 cmp	 edi, 64			; 00000040H
  001a1	0f 82 6d 05 00
	00		 jb	 $L9053

; 206  : 
; 207  :                             ntStatus = STATUS_BUFFER_TOO_SMALL;
; 208  :                         }
; 209  :                         else {
; 210  : 
; 211  :                             AsyncLock = (PASYNC_LOCK)ioBuffer;
; 212  : 
; 213  :                             ntStatus = t1394_AsyncLock( DeviceObject,
; 214  :                                                             Irp,
; 215  :                                                             AsyncLock->bRawMode,
; 216  :                                                             AsyncLock->bGetGeneration,
; 217  :                                                             AsyncLock->DestinationAddress,
; 218  :                                                             AsyncLock->nNumberOfArgBytes,
; 219  :                                                             AsyncLock->nNumberOfDataBytes,
; 220  :                                                             AsyncLock->fulTransactionType,
; 221  :                                                             AsyncLock->fulFlags,
; 222  :                                                             AsyncLock->Arguments,
; 223  :                                                             AsyncLock->DataValues,
; 224  :                                                             AsyncLock->ulGeneration,
; 225  :                                                             (PVOID)&AsyncLock->Buffer
; 226  :                                                             );

  001a7	8d 48 38	 lea	 ecx, DWORD PTR [eax+56]
  001aa	51		 push	 ecx
  001ab	ff 70 34	 push	 DWORD PTR [eax+52]
  001ae	8d 48 2c	 lea	 ecx, DWORD PTR [eax+44]
  001b1	51		 push	 ecx
  001b2	8d 48 24	 lea	 ecx, DWORD PTR [eax+36]
  001b5	51		 push	 ecx
  001b6	ff 70 20	 push	 DWORD PTR [eax+32]
  001b9	8d 70 08	 lea	 esi, DWORD PTR [eax+8]
  001bc	ff 70 1c	 push	 DWORD PTR [eax+28]
  001bf	ff 70 18	 push	 DWORD PTR [eax+24]
  001c2	ff 70 14	 push	 DWORD PTR [eax+20]
  001c5	83 ec 0c	 sub	 esp, 12			; 0000000cH
  001c8	8b fc		 mov	 edi, esp
  001ca	ff 70 04	 push	 DWORD PTR [eax+4]
  001cd	a5		 movsd
  001ce	ff 30		 push	 DWORD PTR [eax]
  001d0	a5		 movsd
  001d1	53		 push	 ebx
  001d2	ff 75 08	 push	 DWORD PTR _DeviceObject$[ebp]
  001d5	a5		 movsd
  001d6	e8 00 00 00 00	 call	 _t1394_AsyncLock@60
$L9163:
  001db	8b f0		 mov	 esi, eax

; 227  : 
; 228  :                             if (NT_SUCCESS(ntStatus))

  001dd	85 f6		 test	 esi, esi
  001df	0f 8c 48 06 00
	00		 jl	 $t1394VDev_ExitGetDiagVersion$9103

; 229  :                                 Irp->IoStatus.Information = outputBufferLength;

  001e5	8b 45 f4	 mov	 eax, DWORD PTR _outputBufferLength$[ebp]
  001e8	89 43 1c	 mov	 DWORD PTR [ebx+28], eax
  001eb	e9 3d 06 00 00	 jmp	 $t1394VDev_ExitGetDiagVersion$9103
$L9140:

; 69   : 
; 70   :             switch (ioControlCode) {

  001f0	81 e9 14 20 22
	00		 sub	 ecx, 2236436		; 00222014H
  001f6	0f 84 f9 00 00
	00		 je	 $L8807
  001fc	6a 04		 push	 4
  001fe	5a		 pop	 edx
  001ff	2b ca		 sub	 ecx, edx
  00201	0f 84 c3 00 00
	00		 je	 $L8818
  00207	2b ca		 sub	 ecx, edx
  00209	0f 84 82 00 00
	00		 je	 $L8829
  0020f	2b ca		 sub	 ecx, edx
  00211	0f 85 1a 05 00
	00		 jne	 $L9104

; 359  :                         }
; 360  :                     }
; 361  :                     break; // IOCTL_ISOCH_ALLOCATE_RESOURCES
; 362  : 
; 363  :                 case IOCTL_ISOCH_ATTACH_BUFFERS:
; 364  :                     {
; 365  :                         PISOCH_ATTACH_BUFFERS       IsochAttachBuffers	= NULL;
; 366  : 						PRING3_ISOCH_DESCRIPTOR		pTempR3Desc			= NULL;
; 367  : 						ULONG						ulBuffSize			= 0;
; 368  : 						ULONG						i					= 0;
; 369  : 
; 370  :                         TRACE(TL_TRACE, ("IOCTL_ISOCH_ATTACH_BUFFERS\n"));
; 371  : 
; 372  :                         if (inputBufferLength < (sizeof(ISOCH_ATTACH_BUFFERS))) {

  00217	83 7d 0c 34	 cmp	 DWORD PTR _inputBufferLength$[ebp], 52 ; 00000034H

; 373  : 
; 374  :                             ntStatus = STATUS_BUFFER_TOO_SMALL;
; 375  :                         }
; 376  :                         else {

  0021b	0f 82 44 05 00
	00		 jb	 $L9167

; 377  :                       
; 378  : 							// verify the passed in buffer is large enough to hold each r3 descriptor
; 379  : 							// plus the data portion
; 380  : 							IsochAttachBuffers  = (PISOCH_ATTACH_BUFFERS)ioBuffer;
; 381  : 							pTempR3Desc			= &(IsochAttachBuffers->R3_IsochDescriptor[0]);
; 382  : 							ulBuffSize			= sizeof (ISOCH_ATTACH_BUFFERS) - sizeof (RING3_ISOCH_DESCRIPTOR);
; 383  : 							
; 384  : 							for (i = 0; i < IsochAttachBuffers->nNumberOfDescriptors; i++)

  00221	83 65 f8 00	 and	 DWORD PTR _i$8846[ebp], 0
  00225	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00229	8d 70 10	 lea	 esi, DWORD PTR [eax+16]
  0022c	8b ce		 mov	 ecx, esi
  0022e	c7 45 fc 10 00
	00 00		 mov	 DWORD PTR _ulBuffSize$8845[ebp], 16 ; 00000010H
  00235	76 34		 jbe	 SHORT $L9160
$L9161:

; 385  : 							{
; 386  : 								// verify the buffer is large enough to hold this R3 Isoch Descriptor
; 387  : 								ulBuffSize += sizeof (RING3_ISOCH_DESCRIPTOR);

  00237	83 45 fc 24	 add	 DWORD PTR _ulBuffSize$8845[ebp], 36 ; 00000024H

; 388  : 								if (inputBufferLength < ulBuffSize)

  0023b	8b 55 0c	 mov	 edx, DWORD PTR _inputBufferLength$[ebp]
  0023e	3b 55 fc	 cmp	 edx, DWORD PTR _ulBuffSize$8845[ebp]
  00241	0f 82 1e 05 00
	00		 jb	 $L9167

; 389  : 								{
; 390  : 									TRACE(TL_WARNING, ("Isoch Attach buffer request too small\n"));
; 391  : 									ntStatus = STATUS_BUFFER_TOO_SMALL;
; 392  : 									break;
; 393  : 								}
; 394  : 
; 395  : 								// now verify the buffer is large enough to hold the data indicated
; 396  : 								// by the last R3 Isoch Descriptor
; 397  : 								ulBuffSize += pTempR3Desc->ulLength;

  00247	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0024a	01 55 fc	 add	 DWORD PTR _ulBuffSize$8845[ebp], edx

; 398  : 								if (inputBufferLength < ulBuffSize)

  0024d	8b 7d 0c	 mov	 edi, DWORD PTR _inputBufferLength$[ebp]
  00250	3b 7d fc	 cmp	 edi, DWORD PTR _ulBuffSize$8845[ebp]
  00253	0f 82 0c 05 00
	00		 jb	 $L9167
  00259	ff 45 f8	 inc	 DWORD PTR _i$8846[ebp]

; 399  : 								{
; 400  : 									TRACE(TL_WARNING, ("Isoch Attach buffer request too small\n"));
; 401  : 									ntStatus = STATUS_BUFFER_TOO_SMALL;
; 402  : 									break;
; 403  : 								}
; 404  : 
; 405  : 								// now increment our temp R3 descriptor so the next time through this for loop
; 406  : 								// we are pointing at the correct data
; 407  : 								pTempR3Desc = (PRING3_ISOCH_DESCRIPTOR)((ULONG_PTR)pTempR3Desc +
; 408  : 																		pTempR3Desc->ulLength +
; 409  : 																		sizeof(RING3_ISOCH_DESCRIPTOR));

  0025c	8d 4c 11 24	 lea	 ecx, DWORD PTR [ecx+edx+36]
  00260	8b 55 f8	 mov	 edx, DWORD PTR _i$8846[ebp]
  00263	3b 50 04	 cmp	 edx, DWORD PTR [eax+4]
  00266	72 cf		 jb	 SHORT $L9161

; 398  : 								if (inputBufferLength < ulBuffSize)

  00268	8b 7d f4	 mov	 edi, DWORD PTR _outputBufferLength$[ebp]
$L9160:

; 410  : 							}
; 411  : 
; 412  : 							// make sure we didn't fail up above
; 413  :                             if (NT_SUCCESS(ntStatus))
; 414  : 							{
; 415  :                                 ntStatus = t1394_IsochAttachBuffers( DeviceObject,
; 416  :                                                                          Irp,
; 417  :                                                                          outputBufferLength,
; 418  :                                                                          IsochAttachBuffers->hResource,
; 419  :                                                                          IsochAttachBuffers->nNumberOfDescriptors,
; 420  :                                                                          (PISOCH_DESCRIPTOR)IsochAttachBuffers->pIsochDescriptor,
; 421  :                                                                          (PRING3_ISOCH_DESCRIPTOR)&IsochAttachBuffers->R3_IsochDescriptor
; 422  :                                                                          );

  0026b	56		 push	 esi
  0026c	ff 70 0c	 push	 DWORD PTR [eax+12]
  0026f	ff 70 04	 push	 DWORD PTR [eax+4]
  00272	ff 30		 push	 DWORD PTR [eax]
  00274	57		 push	 edi
  00275	53		 push	 ebx
  00276	ff 75 08	 push	 DWORD PTR _DeviceObject$[ebp]
  00279	e8 00 00 00 00	 call	 _t1394_IsochAttachBuffers@28
  0027e	8b f0		 mov	 esi, eax
$L9165:

; 423  : 
; 424  :                                 if (STATUS_PENDING == ntStatus)

  00280	81 fe 03 01 00
	00		 cmp	 esi, 259		; 00000103H
  00286	0f 84 b6 05 00
	00		 je	 $t1394VDev_IoControlExit$8871

; 425  : 								{
; 426  :                                     goto t1394VDev_IoControlExit;
; 427  : 								}
; 428  :                             }
; 429  :                         }
; 430  :                     }
; 431  :                     break; // IOCTL_ISOCH_ATTACH_BUFFERS

  0028c	e9 9c 05 00 00	 jmp	 $t1394VDev_ExitGetDiagVersion$9103
$L8829:

; 326  :                         }
; 327  :                     }
; 328  :                     break; // IOCTL_ISOCH_ALLOCATE_CHANNEL
; 329  : 
; 330  :                 case IOCTL_ISOCH_ALLOCATE_RESOURCES:
; 331  :                     {
; 332  :                         PISOCH_ALLOCATE_RESOURCES   IsochAllocateResources;
; 333  : 
; 334  :                         TRACE(TL_TRACE, ("IOCTL_ISOCH_ALLOCATE_RESOURCES\n"));
; 335  : 
; 336  :                         if ((inputBufferLength < sizeof(ISOCH_ALLOCATE_RESOURCES)) ||
; 337  :                             (outputBufferLength < sizeof(ISOCH_ALLOCATE_RESOURCES))) {

  00291	83 7d 0c 20	 cmp	 DWORD PTR _inputBufferLength$[ebp], 32 ; 00000020H
  00295	0f 82 79 04 00
	00		 jb	 $L9053
  0029b	83 ff 20	 cmp	 edi, 32			; 00000020H
  0029e	0f 82 70 04 00
	00		 jb	 $L9053

; 338  : 
; 339  :                             ntStatus = STATUS_BUFFER_TOO_SMALL;
; 340  :                         }
; 341  :                         else {
; 342  : 
; 343  :                             IsochAllocateResources = (PISOCH_ALLOCATE_RESOURCES)ioBuffer;
; 344  : 
; 345  :                             ntStatus = t1394_IsochAllocateResources( DeviceObject,
; 346  :                                                                          Irp,
; 347  :                                                                          IsochAllocateResources->fulSpeed,
; 348  :                                                                          IsochAllocateResources->fulFlags,
; 349  :                                                                          IsochAllocateResources->nChannel,
; 350  :                                                                          IsochAllocateResources->nMaxBytesPerFrame,
; 351  :                                                                          IsochAllocateResources->nNumberOfBuffers,
; 352  :                                                                          IsochAllocateResources->nMaxBufferSize,
; 353  :                                                                          IsochAllocateResources->nQuadletsToStrip,
; 354  :                                                                          &IsochAllocateResources->hResource
; 355  :                                                                          );

  002a4	8d 48 1c	 lea	 ecx, DWORD PTR [eax+28]
  002a7	51		 push	 ecx
  002a8	ff 70 18	 push	 DWORD PTR [eax+24]
  002ab	ff 70 14	 push	 DWORD PTR [eax+20]
  002ae	ff 70 10	 push	 DWORD PTR [eax+16]
  002b1	ff 70 0c	 push	 DWORD PTR [eax+12]
  002b4	ff 70 08	 push	 DWORD PTR [eax+8]
  002b7	ff 70 04	 push	 DWORD PTR [eax+4]
  002ba	ff 30		 push	 DWORD PTR [eax]
  002bc	53		 push	 ebx
  002bd	ff 75 08	 push	 DWORD PTR _DeviceObject$[ebp]
  002c0	e8 00 00 00 00	 call	 _t1394_IsochAllocateResources@40

; 356  : 
; 357  :                             if (NT_SUCCESS(ntStatus))
; 358  :                                 Irp->IoStatus.Information = outputBufferLength;

  002c5	e9 38 04 00 00	 jmp	 $L9162
$L8818:

; 298  :                         }
; 299  :                     }
; 300  :                     break; // IOCTL_ISOCH_ALLOCATE_BANDWIDTH
; 301  : 
; 302  :                 case IOCTL_ISOCH_ALLOCATE_CHANNEL:
; 303  :                     {
; 304  :                         PISOCH_ALLOCATE_CHANNEL     IsochAllocateChannel;
; 305  : 
; 306  :                         TRACE(TL_TRACE, ("IOCTL_ISOCH_ALLOCATE_CHANNEL\n"));
; 307  : 
; 308  :                         if ((inputBufferLength < sizeof(ISOCH_ALLOCATE_CHANNEL)) ||
; 309  :                             (outputBufferLength < sizeof(ISOCH_ALLOCATE_CHANNEL))) {

  002ca	83 7d 0c 10	 cmp	 DWORD PTR _inputBufferLength$[ebp], 16 ; 00000010H
  002ce	0f 82 40 04 00
	00		 jb	 $L9053
  002d4	83 ff 10	 cmp	 edi, 16			; 00000010H
  002d7	0f 82 37 04 00
	00		 jb	 $L9053

; 310  : 
; 311  :                             ntStatus = STATUS_BUFFER_TOO_SMALL;
; 312  :                         }
; 313  :                         else {
; 314  : 
; 315  :                             IsochAllocateChannel = (PISOCH_ALLOCATE_CHANNEL)ioBuffer;
; 316  : 
; 317  :                             ntStatus = t1394_IsochAllocateChannel( DeviceObject,
; 318  :                                                                        Irp,
; 319  :                                                                        IsochAllocateChannel->nRequestedChannel,
; 320  :                                                                        &IsochAllocateChannel->Channel,
; 321  :                                                                        &IsochAllocateChannel->ChannelsAvailable
; 322  :                                                                        );

  002dd	8d 48 08	 lea	 ecx, DWORD PTR [eax+8]
  002e0	51		 push	 ecx
  002e1	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
  002e4	51		 push	 ecx
  002e5	ff 30		 push	 DWORD PTR [eax]
  002e7	53		 push	 ebx
  002e8	ff 75 08	 push	 DWORD PTR _DeviceObject$[ebp]
  002eb	e8 00 00 00 00	 call	 _t1394_IsochAllocateChannel@20

; 323  : 
; 324  :                         if (NT_SUCCESS(ntStatus))
; 325  :                             Irp->IoStatus.Information = outputBufferLength;

  002f0	e9 0d 04 00 00	 jmp	 $L9162
$L8807:

; 271  : 
; 272  :                 case IOCTL_ISOCH_ALLOCATE_BANDWIDTH:
; 273  :                     {
; 274  :                         PISOCH_ALLOCATE_BANDWIDTH   IsochAllocateBandwidth;
; 275  : 
; 276  :                         TRACE(TL_TRACE, ("IOCTL_ISOCH_ALLOCATE_BANDWIDTH\n"));
; 277  : 
; 278  :                         if ((inputBufferLength < sizeof(ISOCH_ALLOCATE_BANDWIDTH)) ||
; 279  :                             (outputBufferLength < sizeof(ISOCH_ALLOCATE_BANDWIDTH))) {

  002f5	83 7d 0c 14	 cmp	 DWORD PTR _inputBufferLength$[ebp], 20 ; 00000014H
  002f9	0f 82 15 04 00
	00		 jb	 $L9053
  002ff	83 ff 14	 cmp	 edi, 20			; 00000014H
  00302	0f 82 0c 04 00
	00		 jb	 $L9053

; 280  : 
; 281  :                             ntStatus = STATUS_BUFFER_TOO_SMALL;
; 282  :                         }
; 283  :                         else {
; 284  : 
; 285  :                             IsochAllocateBandwidth = (PISOCH_ALLOCATE_BANDWIDTH)ioBuffer;
; 286  : 
; 287  :                             ntStatus = t1394_IsochAllocateBandwidth( DeviceObject,
; 288  :                                                                          Irp,
; 289  :                                                                          IsochAllocateBandwidth->nMaxBytesPerFrameRequested,
; 290  :                                                                          IsochAllocateBandwidth->fulSpeed,
; 291  :                                                                          &IsochAllocateBandwidth->hBandwidth,
; 292  :                                                                          &IsochAllocateBandwidth->BytesPerFrameAvailable,
; 293  :                                                                          &IsochAllocateBandwidth->SpeedSelected
; 294  :                                                                          );

  00308	8d 48 10	 lea	 ecx, DWORD PTR [eax+16]
  0030b	51		 push	 ecx
  0030c	8d 48 0c	 lea	 ecx, DWORD PTR [eax+12]
  0030f	51		 push	 ecx
  00310	8d 48 08	 lea	 ecx, DWORD PTR [eax+8]
  00313	51		 push	 ecx
  00314	ff 70 04	 push	 DWORD PTR [eax+4]
  00317	ff 30		 push	 DWORD PTR [eax]
  00319	53		 push	 ebx
  0031a	ff 75 08	 push	 DWORD PTR _DeviceObject$[ebp]
  0031d	e8 00 00 00 00	 call	 _t1394_IsochAllocateBandwidth@28

; 295  : 
; 296  :                             if (NT_SUCCESS(ntStatus))
; 297  :                                 Irp->IoStatus.Information = outputBufferLength;

  00322	e9 db 03 00 00	 jmp	 $L9162
$L8872:

; 432  : 
; 433  :                 case IOCTL_ISOCH_DETACH_BUFFERS:
; 434  :                     {
; 435  :                         PISOCH_DETACH_BUFFERS       IsochDetachBuffers;
; 436  : 
; 437  :                         TRACE(TL_TRACE, ("IOCTL_ISOCH_DETACH_BUFFERS\n"));
; 438  : 
; 439  :                         if (inputBufferLength < sizeof(ISOCH_DETACH_BUFFERS)) {

  00327	83 7d 0c 0c	 cmp	 DWORD PTR _inputBufferLength$[ebp], 12 ; 0000000cH

; 440  : 
; 441  :                             ntStatus = STATUS_BUFFER_TOO_SMALL;
; 442  :                         }
; 443  :                         else {

  0032b	0f 82 34 04 00
	00		 jb	 $L9167

; 444  : 
; 445  :                             IsochDetachBuffers = (PISOCH_DETACH_BUFFERS)ioBuffer;
; 446  : 
; 447  :                             ntStatus = t1394_IsochDetachBuffers( DeviceObject,
; 448  :                                                                      Irp,
; 449  :                                                                      IsochDetachBuffers->hResource,
; 450  :                                                                      IsochDetachBuffers->nNumberOfDescriptors,
; 451  :                                                                      (PISOCH_DESCRIPTOR)IsochDetachBuffers->pIsochDescriptor
; 452  :                                                                      );

  00331	ff 70 08	 push	 DWORD PTR [eax+8]
  00334	ff 70 04	 push	 DWORD PTR [eax+4]
  00337	ff 30		 push	 DWORD PTR [eax]
  00339	53		 push	 ebx
  0033a	ff 75 08	 push	 DWORD PTR _DeviceObject$[ebp]
  0033d	e8 00 00 00 00	 call	 _t1394_IsochDetachBuffers@20

; 453  :                         }
; 454  :                     }
; 455  : 
; 456  :                     break; // IOCTL_ISOCH_DETACH_BUFFERS

  00342	e9 07 03 00 00	 jmp	 $L9164
$L9139:

; 69   : 
; 70   :             switch (ioControlCode) {

  00347	ba 38 20 22 00	 mov	 edx, 2236472		; 00222038H
  0034c	3b ca		 cmp	 ecx, edx
  0034e	0f 87 a5 00 00
	00		 ja	 $L9141
  00354	0f 84 87 00 00
	00		 je	 $L8905
  0035a	81 e9 28 20 22
	00		 sub	 ecx, 2236456		; 00222028H
  00360	74 65		 je	 SHORT $L8880
  00362	6a 04		 push	 4
  00364	5a		 pop	 edx
  00365	2b ca		 sub	 ecx, edx
  00367	74 45		 je	 SHORT $L8886
  00369	2b ca		 sub	 ecx, edx
  0036b	74 28		 je	 SHORT $L8892
  0036d	2b ca		 sub	 ecx, edx
  0036f	0f 85 bc 03 00
	00		 jne	 $L9104

; 511  : 
; 512  :                 case IOCTL_ISOCH_LISTEN:
; 513  :                     {
; 514  :                         PISOCH_LISTEN       IsochListen;
; 515  : 
; 516  :                         TRACE(TL_TRACE, ("IOCTL_ISOCH_LISTEN\n"));
; 517  : 
; 518  :                         if (inputBufferLength < sizeof(ISOCH_LISTEN)) {

  00375	83 7d 0c 0c	 cmp	 DWORD PTR _inputBufferLength$[ebp], 12 ; 0000000cH

; 519  : 
; 520  :                             ntStatus = STATUS_BUFFER_TOO_SMALL;
; 521  :                         }
; 522  :                         else {

  00379	0f 82 e6 03 00
	00		 jb	 $L9167

; 523  : 
; 524  :                             IsochListen = (PISOCH_LISTEN)ioBuffer;
; 525  : 
; 526  :                             ntStatus = t1394_IsochListen( DeviceObject,
; 527  :                                                               Irp,
; 528  :                                                               IsochListen->hResource,
; 529  :                                                               IsochListen->fulFlags,
; 530  :                                                               IsochListen->StartTime
; 531  :                                                               );

  0037f	ff 70 08	 push	 DWORD PTR [eax+8]
  00382	ff 70 04	 push	 DWORD PTR [eax+4]
  00385	ff 30		 push	 DWORD PTR [eax]
  00387	53		 push	 ebx
  00388	ff 75 08	 push	 DWORD PTR _DeviceObject$[ebp]
  0038b	e8 00 00 00 00	 call	 _t1394_IsochListen@20

; 532  :                         }
; 533  :                     }
; 534  :                     break; // IOCTL_ISOCH_LISTEN

  00390	e9 b9 02 00 00	 jmp	 $L9164
$L8892:

; 493  :   
; 494  :                 case IOCTL_ISOCH_FREE_RESOURCES:
; 495  :                     {
; 496  :                         TRACE(TL_TRACE, ("IOCTL_ISOCH_FREE_RESOURCES\n"));
; 497  : 
; 498  :                         if (inputBufferLength < sizeof(HANDLE)) {

  00395	39 55 0c	 cmp	 DWORD PTR _inputBufferLength$[ebp], edx

; 499  : 
; 500  :                             ntStatus = STATUS_BUFFER_TOO_SMALL;
; 501  :                         }
; 502  :                         else {

  00398	0f 82 c7 03 00
	00		 jb	 $L9167

; 503  : 
; 504  :                             ntStatus = t1394_IsochFreeResources( DeviceObject,
; 505  :                                                                      Irp,
; 506  :                                                                      *(PHANDLE)ioBuffer
; 507  :                                                                      );

  0039e	ff 30		 push	 DWORD PTR [eax]
  003a0	53		 push	 ebx
  003a1	ff 75 08	 push	 DWORD PTR _DeviceObject$[ebp]
  003a4	e8 00 00 00 00	 call	 _t1394_IsochFreeResources@12

; 508  :                         }
; 509  :                     }
; 510  :                     break; // IOCTL_ISOCH_FREE_RESOURCES

  003a9	e9 a0 02 00 00	 jmp	 $L9164
$L8886:

; 475  :   
; 476  :                 case IOCTL_ISOCH_FREE_CHANNEL:
; 477  :                     {
; 478  :                         TRACE(TL_TRACE, ("IOCTL_ISOCH_FREE_CHANNEL\n"));
; 479  : 
; 480  :                         if (inputBufferLength < sizeof(ULONG)) {

  003ae	39 55 0c	 cmp	 DWORD PTR _inputBufferLength$[ebp], edx

; 481  : 
; 482  :                             ntStatus = STATUS_BUFFER_TOO_SMALL;
; 483  :                         }
; 484  :                         else {

  003b1	0f 82 ae 03 00
	00		 jb	 $L9167

; 485  : 
; 486  :                             ntStatus = t1394_IsochFreeChannel( DeviceObject,
; 487  :                                                                    Irp,
; 488  :                                                                    *(PULONG)ioBuffer
; 489  :                                                                    );

  003b7	ff 30		 push	 DWORD PTR [eax]
  003b9	53		 push	 ebx
  003ba	ff 75 08	 push	 DWORD PTR _DeviceObject$[ebp]
  003bd	e8 00 00 00 00	 call	 _t1394_IsochFreeChannel@12

; 490  :                         }
; 491  :                     }
; 492  :                     break; // IOCTL_ISOCH_FREE_CHANNEL

  003c2	e9 87 02 00 00	 jmp	 $L9164
$L8880:

; 457  : 
; 458  :                 case IOCTL_ISOCH_FREE_BANDWIDTH:
; 459  :                     {
; 460  :                         TRACE(TL_TRACE, ("IOCTL_ISOCH_FREE_BANDWIDTH\n"));
; 461  : 
; 462  :                         if (inputBufferLength < sizeof(HANDLE)) {

  003c7	83 7d 0c 04	 cmp	 DWORD PTR _inputBufferLength$[ebp], 4

; 463  : 
; 464  :                             ntStatus = STATUS_BUFFER_TOO_SMALL;
; 465  :                         }
; 466  :                         else {

  003cb	0f 82 94 03 00
	00		 jb	 $L9167

; 467  : 
; 468  :                             ntStatus = t1394_IsochFreeBandwidth( DeviceObject,
; 469  :                                                                      Irp,
; 470  :                                                                      *(PHANDLE)ioBuffer
; 471  :                                                                      );

  003d1	ff 30		 push	 DWORD PTR [eax]
  003d3	53		 push	 ebx
  003d4	ff 75 08	 push	 DWORD PTR _DeviceObject$[ebp]
  003d7	e8 00 00 00 00	 call	 _t1394_IsochFreeBandwidth@12

; 472  :                         }
; 473  :                     }
; 474  :                     break; // IOCTL_ISOCH_FREE_BANDWIDTH

  003dc	e9 6d 02 00 00	 jmp	 $L9164
$L8905:

; 535  : 
; 536  :                 case IOCTL_ISOCH_QUERY_CURRENT_CYCLE_TIME:
; 537  :                     {
; 538  :                         TRACE(TL_TRACE, ("IOCTL_ISOCH_QUERY_CURRENT_CYCLE_TIME\n"));
; 539  : 
; 540  :                         if (outputBufferLength < sizeof(CYCLE_TIME)) {

  003e1	83 ff 04	 cmp	 edi, 4

; 541  : 
; 542  :                             ntStatus = STATUS_BUFFER_TOO_SMALL;
; 543  :                         }
; 544  :                         else {

  003e4	0f 82 7b 03 00
	00		 jb	 $L9167

; 545  : 
; 546  :                             ntStatus = t1394_IsochQueryCurrentCycleTime( DeviceObject,
; 547  :                                                                              Irp,
; 548  :                                                                              (PCYCLE_TIME)ioBuffer
; 549  :                                                                              );

  003ea	50		 push	 eax
  003eb	53		 push	 ebx
  003ec	ff 75 08	 push	 DWORD PTR _DeviceObject$[ebp]
  003ef	e8 00 00 00 00	 call	 _t1394_IsochQueryCurrentCycleTime@12

; 550  : 
; 551  :                             if (NT_SUCCESS(ntStatus))
; 552  :                                 Irp->IoStatus.Information = outputBufferLength;
; 553  :                         }
; 554  :                     }
; 555  :                     break; // IOCTL_ISOCH_QUERY_CURRENT_CYCLE_TIME

  003f4	e9 09 03 00 00	 jmp	 $L9162
$L9141:

; 69   : 
; 70   :             switch (ioControlCode) {

  003f9	81 e9 3c 20 22
	00		 sub	 ecx, 2236476		; 0022203cH
  003ff	74 49		 je	 SHORT $L8913
  00401	6a 04		 push	 4
  00403	5a		 pop	 edx
  00404	2b ca		 sub	 ecx, edx
  00406	74 25		 je	 SHORT $L8924
  00408	2b ca		 sub	 ecx, edx
  0040a	0f 85 21 03 00
	00		 jne	 $L9104

; 632  : 
; 633  :                 case IOCTL_ISOCH_STOP:
; 634  :                     {
; 635  :                         PISOCH_STOP     IsochStop;
; 636  : 
; 637  :                         TRACE(TL_TRACE, ("IOCTL_ISOCH_STOP\n"));
; 638  : 
; 639  :                         if (inputBufferLength < sizeof(ISOCH_STOP)) {

  00410	83 7d 0c 08	 cmp	 DWORD PTR _inputBufferLength$[ebp], 8

; 640  : 
; 641  :                             ntStatus = STATUS_BUFFER_TOO_SMALL;
; 642  :                         }
; 643  :                         else {

  00414	0f 82 4b 03 00
	00		 jb	 $L9167

; 644  : 
; 645  :                             IsochStop = (PISOCH_STOP)ioBuffer;
; 646  : 
; 647  :                             ntStatus = t1394_IsochStop( DeviceObject,
; 648  :                                                             Irp,
; 649  :                                                             IsochStop->hResource,
; 650  :                                                             IsochStop->fulFlags
; 651  :                                                             );

  0041a	ff 70 04	 push	 DWORD PTR [eax+4]
  0041d	ff 30		 push	 DWORD PTR [eax]
  0041f	53		 push	 ebx
  00420	ff 75 08	 push	 DWORD PTR _DeviceObject$[ebp]
  00423	e8 00 00 00 00	 call	 _t1394_IsochStop@16

; 652  :                         }
; 653  :                     }
; 654  :                     break; // IOCTL_ISOCH_STOP

  00428	e9 21 02 00 00	 jmp	 $L9164
$L8924:

; 581  :                         }
; 582  :                     }
; 583  :                     break; // IOCTL_ISOCH_QUERY_RESOURCES
; 584  : 
; 585  :                 case IOCTL_ISOCH_SET_CHANNEL_BANDWIDTH:
; 586  :                     {
; 587  :                         PISOCH_SET_CHANNEL_BANDWIDTH    IsochSetChannelBandwidth;
; 588  : 
; 589  :                         TRACE(TL_TRACE, ("IOCTL_ISOCH_SET_CHANNEL_BANDWIDTH\n"));
; 590  : 
; 591  :                         if (inputBufferLength < sizeof(ISOCH_SET_CHANNEL_BANDWIDTH)) {

  0042d	83 7d 0c 08	 cmp	 DWORD PTR _inputBufferLength$[ebp], 8

; 592  : 
; 593  :                             ntStatus = STATUS_BUFFER_TOO_SMALL;
; 594  :                         }
; 595  :                         else {

  00431	0f 82 2e 03 00
	00		 jb	 $L9167

; 596  : 
; 597  :                             IsochSetChannelBandwidth = (PISOCH_SET_CHANNEL_BANDWIDTH)ioBuffer;
; 598  : 
; 599  :                             ntStatus = t1394_IsochSetChannelBandwidth( DeviceObject,
; 600  :                                                                            Irp,
; 601  :                                                                            IsochSetChannelBandwidth->hBandwidth,
; 602  :                                                                            IsochSetChannelBandwidth->nMaxBytesPerFrame
; 603  :                                                                            );

  00437	ff 70 04	 push	 DWORD PTR [eax+4]
  0043a	ff 30		 push	 DWORD PTR [eax]
  0043c	53		 push	 ebx
  0043d	ff 75 08	 push	 DWORD PTR _DeviceObject$[ebp]
  00440	e8 00 00 00 00	 call	 _t1394_IsochSetChannelBandwidth@16

; 604  :                         }
; 605  :                     }
; 606  :                     break; // IOCTL_ISOCH_SET_CHANNEL_BANDWIDTH

  00445	e9 04 02 00 00	 jmp	 $L9164
$L8913:

; 556  : 
; 557  :                 case IOCTL_ISOCH_QUERY_RESOURCES:
; 558  :                     {
; 559  :                         PISOCH_QUERY_RESOURCES      IsochQueryResources;
; 560  : 
; 561  :                         TRACE(TL_TRACE, ("IOCTL_ISOCH_QUERY_RESOURCES\n"));
; 562  : 
; 563  :                         if ((inputBufferLength < sizeof(ISOCH_QUERY_RESOURCES)) ||
; 564  :                             (outputBufferLength < sizeof(ISOCH_QUERY_RESOURCES))) {

  0044a	83 7d 0c 10	 cmp	 DWORD PTR _inputBufferLength$[ebp], 16 ; 00000010H
  0044e	0f 82 c0 02 00
	00		 jb	 $L9053
  00454	83 ff 10	 cmp	 edi, 16			; 00000010H
  00457	0f 82 b7 02 00
	00		 jb	 $L9053

; 565  : 
; 566  :                             ntStatus = STATUS_BUFFER_TOO_SMALL;
; 567  :                         }
; 568  :                         else {
; 569  : 
; 570  :                             IsochQueryResources = (PISOCH_QUERY_RESOURCES)ioBuffer;
; 571  : 
; 572  :                             ntStatus = t1394_IsochQueryResources( DeviceObject,
; 573  :                                                                       Irp,
; 574  :                                                                       IsochQueryResources->fulSpeed,
; 575  :                                                                       &IsochQueryResources->BytesPerFrameAvailable,
; 576  :                                                                       &IsochQueryResources->ChannelsAvailable
; 577  :                                                                       );

  0045d	8d 48 08	 lea	 ecx, DWORD PTR [eax+8]
  00460	51		 push	 ecx
  00461	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
  00464	51		 push	 ecx
  00465	ff 30		 push	 DWORD PTR [eax]
  00467	53		 push	 ebx
  00468	ff 75 08	 push	 DWORD PTR _DeviceObject$[ebp]
  0046b	e8 00 00 00 00	 call	 _t1394_IsochQueryResources@20

; 578  : 
; 579  :                             if (NT_SUCCESS(ntStatus))
; 580  :                                 Irp->IoStatus.Information = outputBufferLength;

  00470	e9 8d 02 00 00	 jmp	 $L9162
$L8945:

; 655  : 
; 656  :                 case IOCTL_ISOCH_TALK:
; 657  :                     {
; 658  :                         PISOCH_TALK     IsochTalk;
; 659  : 
; 660  :                         TRACE(TL_TRACE, ("IOCTL_ISOCH_TALK\n"));
; 661  : 
; 662  :                         if (inputBufferLength < sizeof(ISOCH_TALK)) {

  00475	83 7d 0c 0c	 cmp	 DWORD PTR _inputBufferLength$[ebp], 12 ; 0000000cH

; 663  : 
; 664  :                             ntStatus = STATUS_BUFFER_TOO_SMALL;
; 665  :                         }
; 666  :                         else {

  00479	0f 82 e6 02 00
	00		 jb	 $L9167

; 667  : 
; 668  :                             IsochTalk = (PISOCH_TALK)ioBuffer;
; 669  : 
; 670  :                             ntStatus = t1394_IsochTalk( DeviceObject,
; 671  :                                                             Irp,
; 672  :                                                             IsochTalk->hResource,
; 673  :                                                             IsochTalk->fulFlags,
; 674  :                                                             IsochTalk->StartTime
; 675  :                                                             );

  0047f	ff 70 08	 push	 DWORD PTR [eax+8]
  00482	ff 70 04	 push	 DWORD PTR [eax+4]
  00485	ff 30		 push	 DWORD PTR [eax]
  00487	53		 push	 ebx
  00488	ff 75 08	 push	 DWORD PTR _DeviceObject$[ebp]
  0048b	e8 00 00 00 00	 call	 _t1394_IsochTalk@20

; 676  :                         }
; 677  :                     }
; 678  :                     break; // IOCTL_ISOCH_TALK

  00490	e9 b9 01 00 00	 jmp	 $L9164
$L9138:

; 69   : 
; 70   :             switch (ioControlCode) {

  00495	ba 6c 20 22 00	 mov	 edx, 2236524		; 0022206cH
  0049a	3b ca		 cmp	 ecx, edx
  0049c	0f 87 4d 01 00
	00		 ja	 $L9142
  004a2	0f 84 2d 01 00
	00		 je	 $L9010
  004a8	83 c2 f0	 add	 edx, -16		; fffffff0H
  004ab	3b ca		 cmp	 ecx, edx
  004ad	0f 87 d0 00 00
	00		 ja	 $L9143
  004b3	0f 84 ad 00 00
	00		 je	 $L8988
  004b9	81 e9 4c 20 22
	00		 sub	 ecx, 2236492		; 0022204cH
  004bf	74 7c		 je	 SHORT $L8952
  004c1	6a 04		 push	 4
  004c3	5a		 pop	 edx
  004c4	2b ca		 sub	 ecx, edx
  004c6	74 4e		 je	 SHORT $L8964
  004c8	2b ca		 sub	 ecx, edx
  004ca	74 3c		 je	 SHORT $L8975
  004cc	2b ca		 sub	 ecx, edx
  004ce	0f 85 5d 02 00
	00		 jne	 $L9104

; 743  : 
; 744  :                 case IOCTL_GET_MAX_SPEED_BETWEEN_DEVICES:
; 745  :                     {
; 746  :                         PGET_MAX_SPEED_BETWEEN_DEVICES  MaxSpeedBetweenDevices;
; 747  : 
; 748  :                         TRACE(TL_TRACE, ("IOCTL_GET_MAX_SPEED_BETWEEN_DEVICES\n"));
; 749  : 
; 750  :                         if ((inputBufferLength < sizeof(GET_MAX_SPEED_BETWEEN_DEVICES)) ||
; 751  :                             (outputBufferLength < sizeof(GET_MAX_SPEED_BETWEEN_DEVICES))) {

  004d4	b9 0c 01 00 00	 mov	 ecx, 268		; 0000010cH
  004d9	39 4d 0c	 cmp	 DWORD PTR _inputBufferLength$[ebp], ecx
  004dc	0f 82 32 02 00
	00		 jb	 $L9053
  004e2	3b f9		 cmp	 edi, ecx
  004e4	0f 82 2a 02 00
	00		 jb	 $L9053

; 752  : 
; 753  :                             ntStatus = STATUS_BUFFER_TOO_SMALL;
; 754  :                         }
; 755  :                         else {
; 756  : 
; 757  :                             MaxSpeedBetweenDevices = (PGET_MAX_SPEED_BETWEEN_DEVICES)ioBuffer;
; 758  : 
; 759  :                             ntStatus = t1394_GetMaxSpeedBetweenDevices( DeviceObject,
; 760  :                                                                             Irp,
; 761  :                                                                             MaxSpeedBetweenDevices->fulFlags,
; 762  :                                                                             MaxSpeedBetweenDevices->ulNumberOfDestinations,
; 763  :                                                                             (PDEVICE_OBJECT *)&MaxSpeedBetweenDevices->hDestinationDeviceObjects[0],
; 764  :                                                                             &MaxSpeedBetweenDevices->fulSpeed
; 765  :                                                                             );

  004ea	8d 88 08 01 00
	00		 lea	 ecx, DWORD PTR [eax+264]
  004f0	51		 push	 ecx
  004f1	8d 48 08	 lea	 ecx, DWORD PTR [eax+8]
  004f4	51		 push	 ecx
  004f5	ff 70 04	 push	 DWORD PTR [eax+4]
  004f8	ff 30		 push	 DWORD PTR [eax]
  004fa	53		 push	 ebx
  004fb	ff 75 08	 push	 DWORD PTR _DeviceObject$[ebp]
  004fe	e8 00 00 00 00	 call	 _t1394_GetMaxSpeedBetweenDevices@24

; 766  : 
; 767  :                             if (NT_SUCCESS(ntStatus))
; 768  :                                 Irp->IoStatus.Information = outputBufferLength;

  00503	e9 fa 01 00 00	 jmp	 $L9162
$L8975:

; 731  :                         }
; 732  :                     }
; 733  :                     break; // IOCTL_GET_1394_ADDRESS_FROM_DEVICE_OBJECT
; 734  : 
; 735  :                 case IOCTL_CONTROL:
; 736  :                     TRACE(TL_TRACE, ("IOCTL_CONTROL\n"));
; 737  : 
; 738  :                     ntStatus = t1394_Control( DeviceObject,
; 739  :                                                   Irp
; 740  :                                                   );

  00508	53		 push	 ebx
  00509	ff 75 08	 push	 DWORD PTR _DeviceObject$[ebp]
  0050c	e8 00 00 00 00	 call	 _t1394_Control@8

; 741  : 
; 742  :                     break; // IOCTL_CONTROL

  00511	e9 38 01 00 00	 jmp	 $L9164
$L8964:

; 704  :                         }
; 705  :                     }
; 706  :                     break; // IOCTL_GET_LOCAL_HOST_INFORMATION
; 707  : 
; 708  :                 case IOCTL_GET_1394_ADDRESS_FROM_DEVICE_OBJECT:
; 709  :                     {
; 710  :                         PGET_1394_ADDRESS   Get1394Address;
; 711  : 
; 712  :                         TRACE(TL_TRACE, ("IOCTL_GET_1394_ADDRESS_FROM_DEVICE_OBJECT\n"));
; 713  : 
; 714  :                         if ((inputBufferLength < sizeof(GET_1394_ADDRESS)) ||
; 715  :                             (outputBufferLength < sizeof(GET_1394_ADDRESS))) {

  00516	83 7d 0c 08	 cmp	 DWORD PTR _inputBufferLength$[ebp], 8
  0051a	0f 82 f4 01 00
	00		 jb	 $L9053
  00520	83 ff 08	 cmp	 edi, 8
  00523	0f 82 eb 01 00
	00		 jb	 $L9053

; 716  : 
; 717  :                             ntStatus = STATUS_BUFFER_TOO_SMALL;
; 718  :                         }
; 719  :                         else {
; 720  : 
; 721  :                             Get1394Address = (PGET_1394_ADDRESS)ioBuffer;
; 722  : 
; 723  :                             ntStatus = t1394_Get1394AddressFromDeviceObject( DeviceObject,
; 724  :                                                                                  Irp,
; 725  :                                                                                  Get1394Address->fulFlags,
; 726  :                                                                                  &Get1394Address->NodeAddress
; 727  :                                                                                  );

  00529	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
  0052c	51		 push	 ecx
  0052d	ff 30		 push	 DWORD PTR [eax]
  0052f	53		 push	 ebx
  00530	ff 75 08	 push	 DWORD PTR _DeviceObject$[ebp]
  00533	e8 00 00 00 00	 call	 _t1394_Get1394AddressFromDeviceObject@16

; 728  : 
; 729  :                             if (NT_SUCCESS(ntStatus))
; 730  :                                 Irp->IoStatus.Information = outputBufferLength;

  00538	e9 c5 01 00 00	 jmp	 $L9162
$L8952:

; 679  : 
; 680  :                 case IOCTL_GET_LOCAL_HOST_INFORMATION:
; 681  :                     {
; 682  :                         PGET_LOCAL_HOST_INFORMATION     GetLocalHostInformation;
; 683  : 
; 684  :                         TRACE(TL_TRACE, ("IOCTL_GET_LOCAL_HOST_INFORMATION\n"));
; 685  : 
; 686  :                         if ((inputBufferLength < sizeof(GET_LOCAL_HOST_INFORMATION)) ||
; 687  :                             (outputBufferLength < sizeof(GET_LOCAL_HOST_INFORMATION))) {

  0053d	83 7d 0c 10	 cmp	 DWORD PTR _inputBufferLength$[ebp], 16 ; 00000010H
  00541	0f 82 cd 01 00
	00		 jb	 $L9053
  00547	83 ff 10	 cmp	 edi, 16			; 00000010H
  0054a	0f 82 c4 01 00
	00		 jb	 $L9053

; 688  : 
; 689  :                             ntStatus = STATUS_BUFFER_TOO_SMALL;
; 690  :                         }
; 691  :                         else {
; 692  : 
; 693  :                             GetLocalHostInformation = (PGET_LOCAL_HOST_INFORMATION)ioBuffer;
; 694  : 
; 695  :                             ntStatus = t1394_GetLocalHostInformation( DeviceObject,
; 696  :                                                                           Irp,
; 697  :                                                                           GetLocalHostInformation->nLevel,
; 698  :                                                                           &GetLocalHostInformation->Status,
; 699  :                                                                           (PVOID)GetLocalHostInformation->Information
; 700  :                                                                           );

  00550	8d 48 0c	 lea	 ecx, DWORD PTR [eax+12]
  00553	51		 push	 ecx
  00554	50		 push	 eax
  00555	ff 70 04	 push	 DWORD PTR [eax+4]
  00558	53		 push	 ebx
  00559	ff 75 08	 push	 DWORD PTR _DeviceObject$[ebp]
  0055c	e8 00 00 00 00	 call	 _t1394_GetLocalHostInformation@20

; 701  : 
; 702  :                             if (NT_SUCCESS(ntStatus))
; 703  :                                 Irp->IoStatus.Information = outputBufferLength;

  00561	e9 9c 01 00 00	 jmp	 $L9162
$L8988:

; 769  :                         }
; 770  :                     }                    
; 771  :                     break; // IOCTL_GET_MAX_SPEED_BETWEEN_DEVICES
; 772  : 
; 773  :                 case IOCTL_SET_DEVICE_XMIT_PROPERTIES:
; 774  :                     {
; 775  :                         PDEVICE_XMIT_PROPERTIES     DeviceXmitProperties;
; 776  : 
; 777  :                         TRACE(TL_TRACE, ("IOCTL_SET_DEVICE_XMIT_PROPERTIES\n"));
; 778  : 
; 779  :                         if (inputBufferLength < sizeof(DEVICE_XMIT_PROPERTIES)) {

  00566	83 7d 0c 08	 cmp	 DWORD PTR _inputBufferLength$[ebp], 8

; 780  : 
; 781  :                             ntStatus = STATUS_BUFFER_TOO_SMALL;
; 782  :                         }
; 783  :                         else {

  0056a	0f 82 f5 01 00
	00		 jb	 $L9167

; 784  : 
; 785  :                             DeviceXmitProperties = (PDEVICE_XMIT_PROPERTIES)ioBuffer;
; 786  : 
; 787  :                             ntStatus = t1394_SetDeviceXmitProperties( DeviceObject,
; 788  :                                                                           Irp,
; 789  :                                                                           DeviceXmitProperties->fulSpeed,
; 790  :                                                                           DeviceXmitProperties->fulPriority
; 791  :                                                                           );

  00570	ff 70 04	 push	 DWORD PTR [eax+4]
  00573	ff 30		 push	 DWORD PTR [eax]
  00575	53		 push	 ebx
  00576	ff 75 08	 push	 DWORD PTR _DeviceObject$[ebp]
  00579	e8 00 00 00 00	 call	 _t1394_SetDeviceXmitProperties@16

; 792  :                         }
; 793  :                     }
; 794  :                     break; // IOCTL_SET_DEVICE_XMIT_PROPERTIES

  0057e	e9 cb 00 00 00	 jmp	 $L9164
$L9143:

; 69   : 
; 70   :             switch (ioControlCode) {

  00583	81 e9 60 20 22
	00		 sub	 ecx, 2236512		; 00222060H
  00589	74 3f		 je	 SHORT $L8995
  0058b	6a 04		 push	 4
  0058d	5a		 pop	 edx
  0058e	2b ca		 sub	 ecx, edx
  00590	74 1f		 je	 SHORT $L8996
  00592	2b ca		 sub	 ecx, edx
  00594	0f 85 97 01 00
	00		 jne	 $L9104

; 822  : 
; 823  :                 case IOCTL_GET_GENERATION_COUNT:
; 824  :                     {
; 825  :                         TRACE(TL_TRACE, ("IOCTL_GET_GENERATION_COUNT\n"));
; 826  : 
; 827  :                         if (outputBufferLength < sizeof(ULONG)) {

  0059a	3b fa		 cmp	 edi, edx

; 828  : 
; 829  :                             ntStatus = STATUS_BUFFER_TOO_SMALL;
; 830  :                         }
; 831  :                         else {

  0059c	0f 82 c3 01 00
	00		 jb	 $L9167

; 832  : 
; 833  :                             ntStatus = t1394_GetGenerationCount( DeviceObject,
; 834  :                                                                      Irp,
; 835  :                                                                      (PULONG)ioBuffer
; 836  :                                                                      );

  005a2	50		 push	 eax
  005a3	53		 push	 ebx
  005a4	ff 75 08	 push	 DWORD PTR _DeviceObject$[ebp]
  005a7	e8 00 00 00 00	 call	 _t1394_GetGenerationCount@12

; 837  : 
; 838  :                             if (NT_SUCCESS(ntStatus))
; 839  :                                 Irp->IoStatus.Information = outputBufferLength;
; 840  :                         }
; 841  :                     }
; 842  :                     break; // IOCTL_GET_GENERATION_COUNT

  005ac	e9 51 01 00 00	 jmp	 $L9162
$L8996:

; 804  : 
; 805  :                 case IOCTL_BUS_RESET:
; 806  :                     {
; 807  :                         TRACE(TL_TRACE, ("IOCTL_BUS_RESET\n"));
; 808  : 
; 809  :                         if (inputBufferLength < sizeof(ULONG)) {

  005b1	39 55 0c	 cmp	 DWORD PTR _inputBufferLength$[ebp], edx

; 810  : 
; 811  :                             ntStatus = STATUS_BUFFER_TOO_SMALL;
; 812  :                         }
; 813  :                         else {

  005b4	0f 82 ab 01 00
	00		 jb	 $L9167

; 814  : 
; 815  :                             ntStatus = t1394_BusReset( DeviceObject,
; 816  :                                                            Irp,
; 817  :                                                            *((PULONG)ioBuffer)
; 818  :                                                            );

  005ba	ff 30		 push	 DWORD PTR [eax]
  005bc	53		 push	 ebx
  005bd	ff 75 08	 push	 DWORD PTR _DeviceObject$[ebp]
  005c0	e8 00 00 00 00	 call	 _t1394_BusReset@12

; 819  :                         }
; 820  :                     }
; 821  :                     break; // IOCTL_BUS_RESET

  005c5	e9 84 00 00 00	 jmp	 $L9164
$L8995:

; 795  : 
; 796  :                 case IOCTL_GET_CONFIGURATION_INFORMATION:
; 797  :                     TRACE(TL_TRACE, ("IOCTL_GET_CONFIGURATION_INFORMATION\n"));
; 798  : 
; 799  :                     ntStatus = t1394_GetConfigurationInformation( DeviceObject,
; 800  :                                                                       Irp
; 801  :                                                                       );

  005ca	53		 push	 ebx
  005cb	ff 75 08	 push	 DWORD PTR _DeviceObject$[ebp]
  005ce	e8 00 00 00 00	 call	 _t1394_GetConfigurationInformation@8

; 802  : 
; 803  :                     break; // IOCTL_GET_CONFIGURATION_INFORMATION

  005d3	eb 79		 jmp	 SHORT $L9164
$L9010:

; 843  : 
; 844  :                 case IOCTL_SEND_PHY_CONFIGURATION_PACKET:
; 845  :                     {
; 846  :                         TRACE(TL_TRACE, ("IOCTL_SEND_PHY_CONFIGURATION_PACKET\n"));
; 847  : 
; 848  :                         if (inputBufferLength < sizeof(PHY_CONFIGURATION_PACKET)) {

  005d5	83 7d 0c 08	 cmp	 DWORD PTR _inputBufferLength$[ebp], 8

; 849  : 
; 850  :                             ntStatus = STATUS_BUFFER_TOO_SMALL;
; 851  :                         }
; 852  :                         else {

  005d9	0f 82 86 01 00
	00		 jb	 $L9167

; 853  : 
; 854  :                             ntStatus = t1394_SendPhyConfigurationPacket( DeviceObject,
; 855  :                                                                              Irp,
; 856  :                                                                              *(PPHY_CONFIGURATION_PACKET)ioBuffer
; 857  :                                                                              );

  005df	ff 70 04	 push	 DWORD PTR [eax+4]
  005e2	ff 30		 push	 DWORD PTR [eax]
  005e4	53		 push	 ebx
  005e5	ff 75 08	 push	 DWORD PTR _DeviceObject$[ebp]
  005e8	e8 00 00 00 00	 call	 _t1394_SendPhyConfigurationPacket@16

; 858  :                         }
; 859  :                     }
; 860  :                     break; // IOCTL_SEND_PHY_CONFIGURATION_PACKET

  005ed	eb 5f		 jmp	 SHORT $L9164
$L9142:

; 69   : 
; 70   :             switch (ioControlCode) {

  005ef	ba a4 20 22 00	 mov	 edx, 2236580		; 002220a4H
  005f4	3b ca		 cmp	 ecx, edx
  005f6	0f 87 22 01 00
	00		 ja	 $L9144
  005fc	0f 84 d3 00 00
	00		 je	 $L9048
  00602	81 e9 70 20 22
	00		 sub	 ecx, 2236528		; 00222070H
  00608	0f 84 ad 00 00
	00		 je	 $L9016
  0060e	6a 04		 push	 4
  00610	5a		 pop	 edx
  00611	2b ca		 sub	 ecx, edx
  00613	74 6d		 je	 SHORT $L8792
  00615	2b ca		 sub	 ecx, edx
  00617	74 3c		 je	 SHORT $L9022
  00619	83 e9 28	 sub	 ecx, 40			; 00000028H
  0061c	0f 85 0f 01 00
	00		 jne	 $L9104

; 913  : 
; 914  :                 case IOCTL_SET_ADDRESS_DATA:
; 915  :                     {
; 916  :                         PSET_ADDRESS_DATA   SetAddressData;
; 917  : 
; 918  :                         TRACE(TL_TRACE, ("IOCTL_SET_ADDRESS_DATA\n"));
; 919  : 
; 920  :                         if (inputBufferLength < sizeof(SET_ADDRESS_DATA)) {

  00622	83 7d 0c 10	 cmp	 DWORD PTR _inputBufferLength$[ebp], 16 ; 00000010H

; 921  : 
; 922  :                             ntStatus = STATUS_BUFFER_TOO_SMALL;
; 923  :                         }
; 924  :                         else {

  00626	0f 82 39 01 00
	00		 jb	 $L9167

; 925  : 
; 926  :                             SetAddressData = (PSET_ADDRESS_DATA)ioBuffer;
; 927  : 
; 928  :                             if (inputBufferLength < (sizeof(SET_ADDRESS_DATA)+SetAddressData->nLength)) {

  0062c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0062f	8d 51 10	 lea	 edx, DWORD PTR [ecx+16]
  00632	39 55 0c	 cmp	 DWORD PTR _inputBufferLength$[ebp], edx

; 929  : 
; 930  :                                 ntStatus = STATUS_BUFFER_TOO_SMALL;
; 931  :                             }
; 932  :                             else {

  00635	0f 82 2a 01 00
	00		 jb	 $L9167

; 933  : 
; 934  :                                 ntStatus = t1394_SetAddressData( DeviceObject,
; 935  :                                                                      Irp,
; 936  :                                                                      SetAddressData->hAddressRange,
; 937  :                                                                      SetAddressData->nLength,
; 938  :                                                                      SetAddressData->ulOffset,
; 939  :                                                                      (PVOID)SetAddressData->Data
; 940  :                                                                      );

  0063b	8d 50 0c	 lea	 edx, DWORD PTR [eax+12]
  0063e	52		 push	 edx
  0063f	ff 70 08	 push	 DWORD PTR [eax+8]
  00642	51		 push	 ecx
  00643	ff 30		 push	 DWORD PTR [eax]
  00645	53		 push	 ebx
  00646	ff 75 08	 push	 DWORD PTR _DeviceObject$[ebp]
  00649	e8 00 00 00 00	 call	 _t1394_SetAddressData@24
$L9164:
  0064e	8b f0		 mov	 esi, eax

; 941  :                             }
; 942  :                         }
; 943  :                     }
; 944  :                     break; // IOCTL_SET_ADDRESS_DATA

  00650	e9 d8 01 00 00	 jmp	 $t1394VDev_ExitGetDiagVersion$9103
$L9022:

; 879  : 
; 880  :                 case IOCTL_SET_LOCAL_HOST_INFORMATION:
; 881  :                     {
; 882  :                         PSET_LOCAL_HOST_INFORMATION     SetLocalHostInformation;
; 883  : 
; 884  :                         TRACE(TL_TRACE, ("IOCTL_SET_LOCAL_HOST_INFORMATION\n"));
; 885  : 
; 886  :                         if (inputBufferLength < sizeof(SET_LOCAL_HOST_INFORMATION)) {

  00655	83 7d 0c 0c	 cmp	 DWORD PTR _inputBufferLength$[ebp], 12 ; 0000000cH

; 887  : 
; 888  :                             ntStatus = STATUS_BUFFER_TOO_SMALL;
; 889  :                         }
; 890  :                         else {

  00659	0f 82 06 01 00
	00		 jb	 $L9167

; 891  : 
; 892  :                             SetLocalHostInformation = (PSET_LOCAL_HOST_INFORMATION)ioBuffer;
; 893  : 
; 894  :                             if (inputBufferLength < (sizeof(SET_LOCAL_HOST_INFORMATION) +
; 895  :                                                      SetLocalHostInformation->ulBufferSize)) {

  0065f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00662	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00665	39 4d 0c	 cmp	 DWORD PTR _inputBufferLength$[ebp], ecx

; 896  : 
; 897  :                                 ntStatus = STATUS_BUFFER_TOO_SMALL;
; 898  :                             }
; 899  :                             else {

  00668	0f 82 f7 00 00
	00		 jb	 $L9167

; 900  : 
; 901  :                                 ntStatus = t1394_SetLocalHostProperties( DeviceObject,
; 902  :                                                                              Irp,
; 903  :                                                                              SetLocalHostInformation->nLevel,
; 904  :                                                                              (PVOID)&SetLocalHostInformation->Information
; 905  :                                                                              );

  0066e	8d 48 08	 lea	 ecx, DWORD PTR [eax+8]
  00671	51		 push	 ecx
  00672	ff 30		 push	 DWORD PTR [eax]
  00674	53		 push	 ebx
  00675	ff 75 08	 push	 DWORD PTR _DeviceObject$[ebp]
  00678	e8 00 00 00 00	 call	 _t1394_SetLocalHostProperties@16

; 906  : 
; 907  :                                 if (NT_SUCCESS(ntStatus))
; 908  :                                     Irp->IoStatus.Information = outputBufferLength;
; 909  :                             }
; 910  :                         }
; 911  :                     }
; 912  :                     break; // IOCTL_SET_LOCAL_HOST_INFORMATION

  0067d	e9 80 00 00 00	 jmp	 $L9162
$L8792:

; 230  :                         }
; 231  :                     }
; 232  :                     break; // IOCTL_ASYNC_LOCK
; 233  : 
; 234  :                 case IOCTL_ASYNC_STREAM:
; 235  :                     {
; 236  :                         PASYNC_STREAM   AsyncStream;
; 237  : 
; 238  :                         TRACE(TL_TRACE, ("IOCTL_ASYNC_STREAM\n"));
; 239  : 
; 240  :                         if (inputBufferLength < sizeof(ASYNC_STREAM)) {

  00682	83 7d 0c 1c	 cmp	 DWORD PTR _inputBufferLength$[ebp], 28 ; 0000001cH

; 241  : 
; 242  :                             ntStatus = STATUS_BUFFER_TOO_SMALL;
; 243  :                         }
; 244  :                         else {

  00686	0f 82 d9 00 00
	00		 jb	 $L9167

; 245  : 
; 246  :                             AsyncStream = (PASYNC_STREAM)ioBuffer;
; 247  : 
; 248  :                             if (outputBufferLength < sizeof(ASYNC_STREAM)+AsyncStream->nNumberOfBytesToStream) {

  0068c	8b 30		 mov	 esi, DWORD PTR [eax]
  0068e	8d 4e 1c	 lea	 ecx, DWORD PTR [esi+28]
  00691	3b f9		 cmp	 edi, ecx

; 249  : 
; 250  :                                 ntStatus = STATUS_BUFFER_TOO_SMALL;
; 251  :                             }
; 252  :                             else {

  00693	0f 82 cc 00 00
	00		 jb	 $L9167

; 253  : 
; 254  :                                 ntStatus = t1394_AsyncStream( DeviceObject,
; 255  :                                                                   Irp,
; 256  :                                                                   AsyncStream->nNumberOfBytesToStream,
; 257  :                                                                   AsyncStream->fulFlags,
; 258  :                                                                   AsyncStream->ulTag,
; 259  :                                                                   AsyncStream->nChannel,
; 260  :                                                                   AsyncStream->ulSynch,
; 261  :                                                                   (UCHAR)AsyncStream->nSpeed,
; 262  :                                                                   (PULONG)&AsyncStream->Data
; 263  :                                                                   );

  00699	8d 48 18	 lea	 ecx, DWORD PTR [eax+24]
  0069c	51		 push	 ecx
  0069d	33 c9		 xor	 ecx, ecx
  0069f	8a 48 14	 mov	 cl, BYTE PTR [eax+20]
  006a2	51		 push	 ecx
  006a3	ff 70 10	 push	 DWORD PTR [eax+16]
  006a6	ff 70 0c	 push	 DWORD PTR [eax+12]
  006a9	ff 70 08	 push	 DWORD PTR [eax+8]
  006ac	ff 70 04	 push	 DWORD PTR [eax+4]
  006af	56		 push	 esi
  006b0	53		 push	 ebx
  006b1	ff 75 08	 push	 DWORD PTR _DeviceObject$[ebp]
  006b4	e8 00 00 00 00	 call	 _t1394_AsyncStream@36

; 264  : 
; 265  :                                 if (NT_SUCCESS(ntStatus))
; 266  :                                     Irp->IoStatus.Information = outputBufferLength;
; 267  :                             }
; 268  :                         }
; 269  :                     }
; 270  :                     break; // IOCTL_ASYNC_STREAM

  006b9	eb 47		 jmp	 SHORT $L9162
$L9016:

; 861  : 
; 862  :                 case IOCTL_BUS_RESET_NOTIFICATION:
; 863  :                     {
; 864  :                         TRACE(TL_TRACE, ("IOCTL_BUS_RESET_NOTIFICATION\n"));
; 865  : 
; 866  :                         if (inputBufferLength < sizeof(ULONG)) {

  006bb	83 7d 0c 04	 cmp	 DWORD PTR _inputBufferLength$[ebp], 4

; 867  : 
; 868  :                             ntStatus = STATUS_BUFFER_TOO_SMALL;
; 869  :                         }
; 870  :                         else {

  006bf	0f 82 a0 00 00
	00		 jb	 $L9167

; 871  : 
; 872  :                             ntStatus = t1394_BusResetNotification( DeviceObject,
; 873  :                                                                        Irp,
; 874  :                                                                        *((PULONG)ioBuffer)
; 875  :                                                                        );

  006c5	ff 30		 push	 DWORD PTR [eax]
  006c7	53		 push	 ebx
  006c8	ff 75 08	 push	 DWORD PTR _DeviceObject$[ebp]
  006cb	e8 00 00 00 00	 call	 _t1394_BusResetNotification@12

; 876  :                         }
; 877  :                     }
; 878  :                     break; // IOCTL_BUS_RESET_NOTIFICATION

  006d0	e9 79 ff ff ff	 jmp	 $L9164
$L9048:

; 945  : 
; 946  :                 case IOCTL_GET_ADDRESS_DATA:
; 947  :                     {
; 948  :                         PGET_ADDRESS_DATA   GetAddressData;
; 949  : 
; 950  :                         TRACE(TL_TRACE, ("IOCTL_GET_ADDRESS_DATA\n"));
; 951  : 
; 952  :                         if ((inputBufferLength < sizeof(GET_ADDRESS_DATA)) || 
; 953  :                             (outputBufferLength < sizeof(GET_ADDRESS_DATA))) {

  006d5	83 7d 0c 10	 cmp	 DWORD PTR _inputBufferLength$[ebp], 16 ; 00000010H
  006d9	72 39		 jb	 SHORT $L9053
  006db	83 ff 10	 cmp	 edi, 16			; 00000010H
  006de	72 34		 jb	 SHORT $L9053

; 956  :                         }
; 957  :                         else {
; 958  : 
; 959  :                             GetAddressData = (PGET_ADDRESS_DATA)ioBuffer;
; 960  : 
; 961  :                             if ((inputBufferLength < (sizeof(GET_ADDRESS_DATA)+GetAddressData->nLength)) ||
; 962  :                                 (outputBufferLength < sizeof (GET_ADDRESS_DATA)+GetAddressData->nLength)) {

  006e0	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  006e3	8d 51 10	 lea	 edx, DWORD PTR [ecx+16]
  006e6	39 55 0c	 cmp	 DWORD PTR _inputBufferLength$[ebp], edx
  006e9	72 7a		 jb	 SHORT $L9167
  006eb	3b fa		 cmp	 edi, edx
  006ed	72 76		 jb	 SHORT $L9167

; 963  : 
; 964  :                                 ntStatus = STATUS_BUFFER_TOO_SMALL;
; 965  :                             }
; 966  :                             else {
; 967  :                                 
; 968  :                                 ntStatus = t1394_GetAddressData( DeviceObject,
; 969  :                                                                      Irp,
; 970  :                                                                      GetAddressData->hAddressRange,
; 971  :                                                                      GetAddressData->nLength,
; 972  :                                                                      GetAddressData->ulOffset,
; 973  :                                                                      (PVOID)GetAddressData->Data
; 974  :                                                                      );

  006ef	8d 50 0c	 lea	 edx, DWORD PTR [eax+12]
  006f2	52		 push	 edx
  006f3	ff 70 08	 push	 DWORD PTR [eax+8]
  006f6	51		 push	 ecx
  006f7	ff 30		 push	 DWORD PTR [eax]
  006f9	53		 push	 ebx
  006fa	ff 75 08	 push	 DWORD PTR _DeviceObject$[ebp]
  006fd	e8 00 00 00 00	 call	 _t1394_GetAddressData@24
$L9162:
  00702	8b f0		 mov	 esi, eax

; 975  :                             
; 976  :                             
; 977  :                                 if (NT_SUCCESS(ntStatus))

  00704	85 f6		 test	 esi, esi
  00706	0f 8c 21 01 00
	00		 jl	 $t1394VDev_ExitGetDiagVersion$9103

; 978  :                                     Irp->IoStatus.Information = outputBufferLength;

  0070c	89 7b 1c	 mov	 DWORD PTR [ebx+28], edi
  0070f	e9 19 01 00 00	 jmp	 $t1394VDev_ExitGetDiagVersion$9103
$L9053:

; 954  : 
; 955  :                             ntStatus = STATUS_BUFFER_TOO_SMALL;

  00714	be 23 00 00 c0	 mov	 esi, -1073741789	; c0000023H

; 979  :                             }
; 980  :                         }
; 981  :                     }
; 982  :                     break; // IOCTL_GET_ADDRESS_DATA

  00719	e9 0f 01 00 00	 jmp	 $t1394VDev_ExitGetDiagVersion$9103
$L9144:

; 69   : 
; 70   :             switch (ioControlCode) {

  0071e	81 e9 c8 20 22
	00		 sub	 ecx, 2236616		; 002220c8H
  00724	74 71		 je	 SHORT $L9066
  00726	6a 04		 push	 4
  00728	5a		 pop	 edx
  00729	2b ca		 sub	 ecx, edx
  0072b	74 2d		 je	 SHORT $L9094
  0072d	2b ca		 sub	 ecx, edx
  0072f	74 0a		 je	 SHORT $L8931
$L9104:

; 1059 : 
; 1060 :                 default:
; 1061 :                     TRACE(TL_ERROR, ("Invalid ioControlCode = 0x%x\n", ioControlCode));
; 1062 :                     ntStatus = STATUS_INVALID_PARAMETER;

  00731	be 0d 00 00 c0	 mov	 esi, -1073741811	; c000000dH

; 1063 :                     break; // default

  00736	e9 fa 00 00 00	 jmp	 $L9159
$L8931:

; 607  : 
; 608  : 
; 609  :                 case IOCTL_ISOCH_MODIFY_STREAM_PROPERTIES:
; 610  :                     {
; 611  :                         PISOCH_MODIFY_STREAM_PROPERTIES     IsochModifyStreamProperties;
; 612  : 
; 613  :                         TRACE(TL_TRACE, ("IOCTL_ISOCH_MODIFY_STREAM_PROPERTIES\n"));
; 614  : 
; 615  :                         if (inputBufferLength < sizeof (ISOCH_MODIFY_STREAM_PROPERTIES)) {

  0073b	83 7d 0c 18	 cmp	 DWORD PTR _inputBufferLength$[ebp], 24 ; 00000018H

; 616  : 
; 617  :                             ntStatus = STATUS_BUFFER_TOO_SMALL;
; 618  :                         }
; 619  :                         else {

  0073f	72 24		 jb	 SHORT $L9167

; 620  : 
; 621  :                             IsochModifyStreamProperties = (PISOCH_MODIFY_STREAM_PROPERTIES)ioBuffer;
; 622  : 
; 623  :                             ntStatus = t1394_IsochModifyStreamProperties( DeviceObject,
; 624  :                                                                             Irp, 
; 625  :                                                                             IsochModifyStreamProperties->hResource,
; 626  :                                                                             IsochModifyStreamProperties->ChannelMask,
; 627  :                                                                             IsochModifyStreamProperties->fulSpeed
; 628  :                                                                             );

  00741	ff 70 10	 push	 DWORD PTR [eax+16]
  00744	ff 70 0c	 push	 DWORD PTR [eax+12]
  00747	ff 70 08	 push	 DWORD PTR [eax+8]
  0074a	ff 30		 push	 DWORD PTR [eax]
  0074c	53		 push	 ebx
  0074d	ff 75 08	 push	 DWORD PTR _DeviceObject$[ebp]
  00750	e8 00 00 00 00	 call	 _t1394_IsochModifyStreamProperties@24

; 629  :                         }
; 630  :                     }
; 631  :                     break; // IOCTL_ISOCH_MODIFY_STREAM_PROPERTIES

  00755	e9 f4 fe ff ff	 jmp	 $L9164
$L9094:

; 1024 :                     }
; 1025 :                     break; // IOCTL_BUS_RESET_NOTIFY
; 1026 : 
; 1027 :                 case IOCTL_GET_DIAG_VERSION:
; 1028 :                     {
; 1029 :                         PVERSION_DATA   Version;
; 1030 : 
; 1031 :                         TRACE(TL_TRACE, ("IOCTL_GET_DIAG_VERSION\n"));
; 1032 : 
; 1033 :                         if ((inputBufferLength < sizeof(VERSION_DATA)) &&
; 1034 :                             (outputBufferLength < sizeof(VERSION_DATA))) {

  0075a	83 7d 0c 08	 cmp	 DWORD PTR _inputBufferLength$[ebp], 8
  0075e	73 0f		 jae	 SHORT $L9098
  00760	83 ff 08	 cmp	 edi, 8
  00763	73 0a		 jae	 SHORT $L9098
$L9167:

; 1035 : 
; 1036 :                                 ntStatus = STATUS_BUFFER_TOO_SMALL;

  00765	be 23 00 00 c0	 mov	 esi, -1073741789	; c0000023H

; 1037 :                         }
; 1038 :                         else {

  0076a	e9 c6 00 00 00	 jmp	 $L9159
$L9098:

; 1039 : 
; 1040 :                             Version = (PVERSION_DATA)ioBuffer;
; 1052 :                             Version->ulVersion = DIAGNOSTIC_VERSION;

  00787	33 c9		 xor	 ecx, ecx
  00789	41		 inc	 ecx

; 1053 :                             Version->ulSubVersion = DIAGNOSTIC_SUB_VERSION;

  0078a	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$L9168:
  0078d	89 08		 mov	 DWORD PTR [eax], ecx

; 1054 : 
; 1055 :                             Irp->IoStatus.Information = outputBufferLength;                            

  0078f	89 7b 1c	 mov	 DWORD PTR [ebx+28], edi

; 1056 :                         }
; 1057 :                     }
; 1058 :                     break; // IOCTL_GET_DIAG_VERSION

  00792	e9 9e 00 00 00	 jmp	 $L9159
$L9066:

; 983  : 
; 984  :                 case IOCTL_BUS_RESET_NOTIFY: {
; 985  : 
; 986  :                     PBUS_RESET_IRP  BusResetIrp;
; 987  :                     KIRQL           Irql;
; 988  :                     
; 989  :                     TRACE(TL_TRACE, ("IOCTL_BUS_RESET_NOTIFY\n"));
; 990  : 
; 991  :                     BusResetIrp = ExAllocatePool(NonPagedPool, sizeof(BUS_RESET_IRP));

  00797	68 57 64 6d 20	 push	 544040023		; 206d6457H
  0079c	6a 0c		 push	 12			; 0000000cH
  0079e	6a 00		 push	 0
  007a0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExAllocatePoolWithTag@12
  007a6	8b f8		 mov	 edi, eax

; 992  : 
; 993  :                     if (BusResetIrp) {

  007a8	85 ff		 test	 edi, edi
  007aa	74 7c		 je	 SHORT $L9070

; 994  : 
; 995  :                         // mark it pending
; 996  :                         IoMarkIrpPending(Irp);

  007ac	8b 43 60	 mov	 eax, DWORD PTR [ebx+96]
  007af	80 48 03 01	 or	 BYTE PTR [eax+3], 1

; 997  :                         ntStatus = Irp->IoStatus.Status = STATUS_PENDING;
; 998  :                         BusResetIrp->Irp = Irp;
; 999  : 
; 1000 :                         TRACE(TL_TRACE, ("Adding BusResetIrp->Irp = 0x%x\n", BusResetIrp->Irp));
; 1001 : 
; 1002 :                         // add the irp to the list...
; 1003 :                         KeAcquireSpinLock(&deviceExtension->ResetSpinLock, &Irql);

  007b3	8b 4d f8	 mov	 ecx, DWORD PTR _deviceExtension$[ebp]
  007b6	be 03 01 00 00	 mov	 esi, 259		; 00000103H
  007bb	83 c1 14	 add	 ecx, 20			; 00000014H
  007be	89 73 18	 mov	 DWORD PTR [ebx+24], esi
  007c1	89 5f 08	 mov	 DWORD PTR [edi+8], ebx
  007c4	89 4d 0c	 mov	 DWORD PTR tv1113[ebp], ecx
  007c7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@KfAcquireSpinLock@4
  007cd	88 45 0b	 mov	 BYTE PTR _Irql$9068[ebp], al

; 1004 : 
; 1005 :                         InsertHeadList(&deviceExtension->BusResetIrps, &BusResetIrp->BusResetIrpList);

  007d0	8b 45 f8	 mov	 eax, DWORD PTR _deviceExtension$[ebp]
  007d3	83 c0 38	 add	 eax, 56			; 00000038H
  007d6	8b 08		 mov	 ecx, DWORD PTR [eax]
  007d8	89 0f		 mov	 DWORD PTR [edi], ecx
  007da	89 47 04	 mov	 DWORD PTR [edi+4], eax
  007dd	89 79 04	 mov	 DWORD PTR [ecx+4], edi

; 1006 : 
; 1007 :                         // set the cancel routine for the irp
; 1008 :                         IoSetCancelRoutine(Irp, t1394VDev_CancelIrp);

  007e0	8d 4b 38	 lea	 ecx, DWORD PTR [ebx+56]
  007e3	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:_t1394VDev_CancelIrp@8
  007e8	89 38		 mov	 DWORD PTR [eax], edi
  007ea	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@InterlockedExchange@8

; 1009 : 
; 1010 :                         if (Irp->Cancel && IoSetCancelRoutine(Irp, t1394VDev_CancelIrp)) {

  007f0	80 7b 24 00	 cmp	 BYTE PTR [ebx+36], 0
  007f4	74 21		 je	 SHORT $L9088
  007f6	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:_t1394VDev_CancelIrp@8
  007fb	8d 4b 38	 lea	 ecx, DWORD PTR [ebx+56]
  007fe	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@InterlockedExchange@8
  00804	85 c0		 test	 eax, eax
  00806	74 0f		 je	 SHORT $L9088

; 1011 : 
; 1012 :                             RemoveEntryList(&BusResetIrp->BusResetIrpList);

  00808	8b 07		 mov	 eax, DWORD PTR [edi]
  0080a	8b 7f 04	 mov	 edi, DWORD PTR [edi+4]
  0080d	89 07		 mov	 DWORD PTR [edi], eax
  0080f	89 78 04	 mov	 DWORD PTR [eax+4], edi

; 1013 :                             ntStatus = STATUS_CANCELLED;

  00812	be 20 01 00 c0	 mov	 esi, -1073741536	; c0000120H
$L9088:

; 1014 :                         }
; 1015 : 
; 1016 :                         KeReleaseSpinLock(&deviceExtension->ResetSpinLock, Irql);

  00817	8a 55 0b	 mov	 dl, BYTE PTR _Irql$9068[ebp]
  0081a	8b 4d 0c	 mov	 ecx, DWORD PTR tv1113[ebp]
  0081d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@KfReleaseSpinLock@8

; 1017 : 
; 1018 :                         // goto t1394VDev_IoControlExit on success so we don't complete the irp
; 1019 :                         if (ntStatus == STATUS_PENDING)
; 1020 :                             goto t1394VDev_IoControlExit;
; 1021 :                     }
; 1022 :                     else

  00823	e9 58 fa ff ff	 jmp	 $L9165
$L9070:

; 1023 :                         ntStatus = STATUS_INSUFFICIENT_RESOURCES;

  00828	be 9a 00 00 c0	 mov	 esi, -1073741670	; c000009aH
$t1394VDev_ExitGetDiagVersion$9103:

; 1075 :             break;
; 1076 : 
; 1077 :     } // switch
; 1078 :
; 1082 : 
; 1083 :     // only complete if the device is there
; 1084 :     if (ntStatus != STATUS_NO_SUCH_DEVICE) {

  0082d	81 fe 0e 00 00
	c0		 cmp	 esi, -1073741810	; c000000eH
  00833	74 0d		 je	 SHORT $t1394VDev_IoControlExit$8871
$L9159:

; 1085 :     
; 1086 :         Irp->IoStatus.Status = ntStatus;
; 1087 :         IoCompleteRequest(Irp, IO_NO_INCREMENT);

  00835	8b cb		 mov	 ecx, ebx
  00837	32 d2		 xor	 dl, dl
  00839	89 73 18	 mov	 DWORD PTR [ebx+24], esi
  0083c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@IofCompleteRequest@8
$t1394VDev_IoControlExit$8871:

; 1088 :     }
; 1089 : 
; 1090 : t1394VDev_IoControlExit:
; 1091 : 
; 1092 :     EXIT("t1394VDev_IoControl", ntStatus);
; 1093 :     return(ntStatus);

  00842	8b c6		 mov	 eax, esi
$L8713:

; 1094 : } // t1394VDev_IoControl

  00844	5f		 pop	 edi
  00845	5e		 pop	 esi
  00846	5b		 pop	 ebx
  00847	c9		 leave
  00848	c2 08 00	 ret	 8
_t1394VDev_IoControl@8 ENDP
_TEXT	ENDS
END

