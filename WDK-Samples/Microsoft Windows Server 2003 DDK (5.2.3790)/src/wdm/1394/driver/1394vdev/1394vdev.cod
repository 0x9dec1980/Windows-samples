; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.2190 

	TITLE	.\1394vdev.c
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT _RemoveEntryList@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _RemoveHeadList@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _InsertHeadList@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _t1394_SubmitIrpAsync@12
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _t1394_SubmitIrpSynch@12
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _t1394_SynchCompletionRoutine@12
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _t1394_IsOnList@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _t1394_UpdateGenerationCount@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _t1394_GetLocalHostInformation@20
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _t1394_Get1394AddressFromDeviceObject@16
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _t1394_Control@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _t1394_GetMaxSpeedBetweenDevices@24
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _t1394_SetDeviceXmitProperties@16
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _t1394_GetConfigurationInformation@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _t1394_BusReset@12
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _t1394_GetGenerationCount@12
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _t1394_SendPhyConfigurationPacket@16
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _t1394_SetLocalHostProperties@16
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _t1394_BusResetRoutine@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _t1394_BusResetNotification@12
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _t1394_AllocateAddressRange@44
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _t1394_FreeAddressRange@12
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _t1394_GetAddressData@24
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _t1394_SetAddressData@24
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _t1394_AsyncRead@48
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _t1394_AsyncWrite@48
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _t1394_AsyncLock@60
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _t1394_AsyncStream@36
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _t1394_IsochAllocateBandwidth@28
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _t1394_IsochAllocateChannel@20
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _t1394_IsochAllocateResources@40
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _t1394_IsochAttachBuffers@28
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _t1394_IsochDetachBuffers@20
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _t1394_IsochFreeBandwidth@12
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _t1394_IsochFreeChannel@12
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _t1394_IsochFreeResources@12
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _t1394_IsochListen@20
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _t1394_IsochQueryCurrentCycleTime@12
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _t1394_IsochQueryResources@20
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _t1394_IsochSetChannelBandwidth@16
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _t1394_IsochModifyStreamProperties@24
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _t1394_IsochStop@16
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _t1394_IsochTalk@20
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _t1394_IsochCallback@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _t1394_IsochTimeout@16
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _t1394_IsochCleanup@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _t1394_IsochDetachCompletionRoutine@12
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _t1394_IsochAttachCompletionRoutine@12
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _DriverEntry@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _t1394VDev_Create@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _t1394VDev_Close@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _t1394VDev_CancelIrp@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _GUID_1394VDEV
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT _GUID_1394DIAG
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT _BUS1394_CLASS_GUID
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
sxdata	SEGMENT DWORD USE32 'SXDATA'
sxdata	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBC
INCLUDELIB OLDNAMES

PUBLIC	_BUS1394_CLASS_GUID
PUBLIC	_GUID_1394DIAG
PUBLIC	_GUID_1394VDEV
;	COMDAT _BUS1394_CLASS_GUID
CONST	SEGMENT
_BUS1394_CLASS_GUID DD 06bdd1fc1H
	DW	0810fH
	DW	011d0H
	DB	0beH
	DB	0c7H
	DB	08H
	DB	00H
	DB	02bH
	DB	0e2H
	DB	09H
	DB	02fH
CONST	ENDS
;	COMDAT _GUID_1394DIAG
CONST	SEGMENT
_GUID_1394DIAG DD 0c459df55H
	DW	0db08H
	DW	011d1H
	DB	0b0H
	DB	09H
	DB	00H
	DB	0a0H
	DB	0c9H
	DB	08H
	DB	01fH
	DB	0f6H
CONST	ENDS
;	COMDAT _GUID_1394VDEV
CONST	SEGMENT
_GUID_1394VDEV DD 0737613e5H
	DW	069eaH
	DW	04b96H
	DB	09cH
	DB	02aH
	DB	0eeH
	DB	0bcH
	DB	022H
	DB	0fH
	DB	04cH
	DB	039H
CONST	ENDS
PUBLIC	_RemoveEntryList@4
; Function compile flags: /Ogsy
; File d:\srv03rtm\public\sdk\inc\wdm.h
;	COMDAT _RemoveEntryList@4
_TEXT	SEGMENT
_Entry$ = 8						; size = 4
_RemoveEntryList@4 PROC NEAR				; COMDAT

; 1540 :     PLIST_ENTRY Blink;
; 1541 :     PLIST_ENTRY Flink;
; 1542 : 
; 1543 :     Flink = Entry->Flink;

  00000	8b 4c 24 04	 mov	 ecx, DWORD PTR _Entry$[esp-4]
  00004	8b 01		 mov	 eax, DWORD PTR [ecx]

; 1544 :     Blink = Entry->Blink;

  00006	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]

; 1545 :     Blink->Flink = Flink;

  00009	89 01		 mov	 DWORD PTR [ecx], eax

; 1546 :     Flink->Blink = Blink;
; 1547 :     return (BOOLEAN)(Flink == Blink);

  0000b	3b c1		 cmp	 eax, ecx
  0000d	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00010	0f 94 c0	 sete	 al

; 1548 : }

  00013	c2 04 00	 ret	 4
_RemoveEntryList@4 ENDP
_TEXT	ENDS
PUBLIC	_RemoveHeadList@4
; Function compile flags: /Ogsy
;	COMDAT _RemoveHeadList@4
_TEXT	SEGMENT
_ListHead$ = 8						; size = 4
_RemoveHeadList@4 PROC NEAR				; COMDAT

; 1556 :     PLIST_ENTRY Flink;
; 1557 :     PLIST_ENTRY Entry;
; 1558 : 
; 1559 :     Entry = ListHead->Flink;

  00000	8b 4c 24 04	 mov	 ecx, DWORD PTR _ListHead$[esp-4]
  00004	8b 01		 mov	 eax, DWORD PTR [ecx]

; 1560 :     Flink = Entry->Flink;

  00006	8b 10		 mov	 edx, DWORD PTR [eax]

; 1561 :     ListHead->Flink = Flink;

  00008	89 11		 mov	 DWORD PTR [ecx], edx

; 1562 :     Flink->Blink = ListHead;

  0000a	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 1563 :     return Entry;
; 1564 : }

  0000d	c2 04 00	 ret	 4
_RemoveHeadList@4 ENDP
_TEXT	ENDS
PUBLIC	_InsertHeadList@8
; Function compile flags: /Ogsy
;	COMDAT _InsertHeadList@8
_TEXT	SEGMENT
_ListHead$ = 8						; size = 4
_Entry$ = 12						; size = 4
_InsertHeadList@8 PROC NEAR				; COMDAT

; 1609 :     PLIST_ENTRY Flink;
; 1610 : 
; 1611 :     Flink = ListHead->Flink;

  00000	8b 4c 24 04	 mov	 ecx, DWORD PTR _ListHead$[esp-4]
  00004	8b 11		 mov	 edx, DWORD PTR [ecx]

; 1612 :     Entry->Flink = Flink;

  00006	8b 44 24 08	 mov	 eax, DWORD PTR _Entry$[esp-4]
  0000a	89 10		 mov	 DWORD PTR [eax], edx

; 1613 :     Entry->Blink = ListHead;

  0000c	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 1614 :     Flink->Blink = Entry;

  0000f	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 1615 :     ListHead->Flink = Entry;

  00012	89 01		 mov	 DWORD PTR [ecx], eax

; 1616 : }

  00014	c2 08 00	 ret	 8
_InsertHeadList@8 ENDP
_TEXT	ENDS
PUBLIC	_t1394_SubmitIrpAsync@12
EXTRN	__imp_@IofCallDriver@8:NEAR
; Function compile flags: /Ogsy
; File d:\srv03rtm\drivers\wdm\1394\tools\test\driver\common\util.c
;	COMDAT _t1394_SubmitIrpAsync@12
_TEXT	SEGMENT
_DeviceObject$ = 8					; size = 4
_Irp$ = 12						; size = 4
_Irb$ = 16						; size = 4
_t1394_SubmitIrpAsync@12 PROC NEAR			; COMDAT

; 29   :     PIO_STACK_LOCATION  NextIrpStack;
; 30   :     NTSTATUS            ntStatus = STATUS_SUCCESS;
; 31   : 
; 32   :     ENTER("t1394_SubmitIrpAsync");
; 33   : 
; 34   :     if (Irb) {

  00000	8b 44 24 0c	 mov	 eax, DWORD PTR _Irb$[esp-4]
  00004	85 c0		 test	 eax, eax

; 35   : 
; 36   :         NextIrpStack = IoGetNextIrpStackLocation(Irp);
; 37   :         NextIrpStack->Parameters.Others.Argument1 = Irb;

  00006	8b 54 24 08	 mov	 edx, DWORD PTR _Irp$[esp-4]
  0000a	74 08		 je	 SHORT $L8720
  0000c	8b 4a 60	 mov	 ecx, DWORD PTR [edx+96]
  0000f	89 41 e0	 mov	 DWORD PTR [ecx-32], eax

; 38   :     }
; 39   :     else {

  00012	eb 15		 jmp	 SHORT $L8721
$L8720:
  00014	56		 push	 esi

; 40   : 
; 41   :         IoCopyCurrentIrpStackLocationToNext(Irp);

  00015	8b 72 60	 mov	 esi, DWORD PTR [edx+96]
  00018	57		 push	 edi
  00019	8d 46 dc	 lea	 eax, DWORD PTR [esi-36]
  0001c	6a 07		 push	 7
  0001e	59		 pop	 ecx
  0001f	8b f8		 mov	 edi, eax
  00021	f3 a5		 rep movsd
  00023	5f		 pop	 edi
  00024	c6 40 03 00	 mov	 BYTE PTR [eax+3], 0
  00028	5e		 pop	 esi
$L8721:

; 42   :     }
; 43   : 
; 44   :     ntStatus = IoCallDriver (DeviceObject, Irp);

  00029	8b 4c 24 04	 mov	 ecx, DWORD PTR _DeviceObject$[esp-4]
  0002d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@IofCallDriver@8

; 45   :     return ntStatus;
; 46   : }

  00033	c2 0c 00	 ret	 12			; 0000000cH
_t1394_SubmitIrpAsync@12 ENDP
_TEXT	ENDS
PUBLIC	_t1394_SynchCompletionRoutine@12
EXTRN	__imp__KeSetEvent@12:NEAR
; Function compile flags: /Ogsy
;	COMDAT _t1394_SynchCompletionRoutine@12
_TEXT	SEGMENT
_DeviceObject$ = 8					; size = 4
_Irp$ = 12						; size = 4
_Event$ = 16						; size = 4
_t1394_SynchCompletionRoutine@12 PROC NEAR		; COMDAT

; 122  :     NTSTATUS        ntStatus = STATUS_SUCCESS;
; 123  : 
; 124  :     ENTER("t1394_SynchCompletionRoutine");
; 125  : 
; 126  :     if (Event)

  00000	33 c0		 xor	 eax, eax
  00002	39 44 24 0c	 cmp	 DWORD PTR _Event$[esp-4], eax
  00006	74 0c		 je	 SHORT $L8764

; 127  :         KeSetEvent(Event, 0, FALSE);

  00008	50		 push	 eax
  00009	50		 push	 eax
  0000a	ff 74 24 14	 push	 DWORD PTR _Event$[esp+4]
  0000e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeSetEvent@12
$L8764:

; 128  :     
; 129  :     EXIT("t1394_SynchCompletionRoutine", ntStatus);
; 130  :     return(STATUS_MORE_PROCESSING_REQUIRED);

  00014	b8 16 00 00 c0	 mov	 eax, -1073741802	; c0000016H

; 131  : } // t1394_SynchCompletionRoutine

  00019	c2 0c 00	 ret	 12			; 0000000cH
_t1394_SynchCompletionRoutine@12 ENDP
_TEXT	ENDS
PUBLIC	_t1394_IsOnList@8
; Function compile flags: /Ogsy
;	COMDAT _t1394_IsOnList@8
_TEXT	SEGMENT
_Entry$ = 8						; size = 4
_List$ = 12						; size = 4
_t1394_IsOnList@8 PROC NEAR				; COMDAT

; 140  : 	PLIST_ENTRY TempEntry;
; 141  : 
; 142  :     for(
; 143  :         TempEntry = List->Flink;
; 144  :         TempEntry != List;
; 145  :         TempEntry = TempEntry->Flink
; 146  :         )

  00000	8b 4c 24 08	 mov	 ecx, DWORD PTR _List$[esp-4]
  00004	8b 01		 mov	 eax, DWORD PTR [ecx]
  00006	eb 08		 jmp	 SHORT $L10629
$L8772:

; 147  :     {
; 148  :         if (TempEntry == Entry) 

  00008	3b 44 24 04	 cmp	 eax, DWORD PTR _Entry$[esp-4]
  0000c	74 0b		 je	 SHORT $L10627

; 140  : 	PLIST_ENTRY TempEntry;
; 141  : 
; 142  :     for(
; 143  :         TempEntry = List->Flink;
; 144  :         TempEntry != List;
; 145  :         TempEntry = TempEntry->Flink
; 146  :         )

  0000e	8b 00		 mov	 eax, DWORD PTR [eax]
$L10629:
  00010	3b c1		 cmp	 eax, ecx
  00012	75 f4		 jne	 SHORT $L8772

; 152  :         }
; 153  :     }
; 154  : 
; 155  : 	TRACE(TL_TRACE, ("Entry 0x%x not found on list 0x%x\n", Entry, List));
; 156  :     return FALSE;

  00014	32 c0		 xor	 al, al
$L8770:

; 157  : }

  00016	c2 08 00	 ret	 8
$L10627:

; 149  :         {
; 150  : 			TRACE(TL_TRACE, ("Entry 0x%x found on list 0x%x\n", Entry, List));
; 151  : 			return TRUE;

  00019	b0 01		 mov	 al, 1
  0001b	eb f9		 jmp	 SHORT $L8770
_t1394_IsOnList@8 ENDP
_TEXT	ENDS
PUBLIC	_t1394_Control@8
; Function compile flags: /Ogsy
; File d:\srv03rtm\drivers\wdm\1394\tools\test\driver\common\1394api.c
;	COMDAT _t1394_Control@8
_TEXT	SEGMENT
_DeviceObject$ = 8					; size = 4
_Irp$ = 12						; size = 4
_t1394_Control@8 PROC NEAR				; COMDAT

; 381  :     NTSTATUS            ntStatus = STATUS_SUCCESS;
; 382  :     PDEVICE_EXTENSION   deviceExtension = DeviceObject->DeviceExtension;
; 383  : 
; 384  :     ENTER("t1394_Control");
; 385  : 
; 386  :     ntStatus = STATUS_NOT_IMPLEMENTED;
; 387  : 
; 388  :     EXIT("t1394_Control", ntStatus);
; 389  :     return(ntStatus);

  00000	b8 02 00 00 c0	 mov	 eax, -1073741822	; c0000002H

; 390  : } // t1394_Control

  00005	c2 08 00	 ret	 8
_t1394_Control@8 ENDP
_TEXT	ENDS
PUBLIC	_t1394_GetAddressData@24
EXTRN	__imp_@KfAcquireSpinLock@4:NEAR
EXTRN	__imp_@KfReleaseSpinLock@8:NEAR
; Function compile flags: /Ogsy
; File d:\srv03rtm\drivers\wdm\1394\tools\test\driver\common\asyncapi.c
;	COMDAT _t1394_GetAddressData@24
_TEXT	SEGMENT
_ntStatus$ = -4						; size = 4
tv131 = 8						; size = 4
_DeviceObject$ = 8					; size = 4
_Irp$ = 12						; size = 4
_hAddressRange$ = 16					; size = 4
_nLength$ = 20						; size = 4
_ulOffset$ = 24						; size = 4
_Data$ = 28						; size = 4
_t1394_GetAddressData@24 PROC NEAR			; COMDAT

; 446  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 447  :     NTSTATUS                ntStatus = STATUS_SUCCESS;
; 448  :     PDEVICE_EXTENSION       deviceExtension = DeviceObject->DeviceExtension;

  00004	8b 45 08	 mov	 eax, DWORD PTR _DeviceObject$[ebp]
  00007	83 65 fc 00	 and	 DWORD PTR _ntStatus$[ebp], 0
  0000b	53		 push	 ebx
  0000c	56		 push	 esi
  0000d	8b 70 28	 mov	 esi, DWORD PTR [eax+40]

; 449  :     KIRQL                   Irql;
; 450  :     PASYNC_ADDRESS_DATA     AsyncAddressData;
; 451  : 
; 452  :     ENTER("t1394_GetAddressData");
; 453  : 
; 454  :     TRACE(TL_TRACE, ("hAddressRange = 0x%x\n", hAddressRange));
; 455  :     TRACE(TL_TRACE, ("nLength = 0x%x\n", nLength));
; 456  :     TRACE(TL_TRACE, ("ulOffset = 0x%x\n", ulOffset));
; 457  : 
; 458  :     // have to find our struct...
; 459  :     KeAcquireSpinLock(&deviceExtension->AsyncSpinLock, &Irql);

  00010	8d 4e 1c	 lea	 ecx, DWORD PTR [esi+28]
  00013	89 4d 08	 mov	 DWORD PTR tv131[ebp], ecx
  00016	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@KfAcquireSpinLock@4

; 460  : 
; 461  :     AsyncAddressData = (PASYNC_ADDRESS_DATA) deviceExtension->AsyncAddressData.Flink;

  0001c	83 c6 48	 add	 esi, 72			; 00000048H
  0001f	8b 1e		 mov	 ebx, DWORD PTR [esi]
  00021	eb 0e		 jmp	 SHORT $L10639
$L9482:

; 464  : 
; 465  :         if (AsyncAddressData->hAddressRange == hAddressRange) {

  00023	8b 4b 1c	 mov	 ecx, DWORD PTR [ebx+28]
  00026	3b 4d 10	 cmp	 ecx, DWORD PTR _hAddressRange$[ebp]
  00029	74 0c		 je	 SHORT $L10637

; 478  :         }
; 479  :         else if (AsyncAddressData->AsyncAddressList.Flink == &deviceExtension->AsyncAddressData) {

  0002b	8b 1b		 mov	 ebx, DWORD PTR [ebx]
  0002d	3b de		 cmp	 ebx, esi
  0002f	74 24		 je	 SHORT $L10638
$L10639:

; 462  : 
; 463  :     while (AsyncAddressData) {

  00031	85 db		 test	 ebx, ebx
  00033	75 ee		 jne	 SHORT $L9482

; 478  :         }
; 479  :         else if (AsyncAddressData->AsyncAddressList.Flink == &deviceExtension->AsyncAddressData) {

  00035	eb 20		 jmp	 SHORT $L9483
$L10637:

; 466  : 
; 467  :             PCHAR   pBuffer;
; 468  :             ULONG   i;
; 469  : 
; 470  :             // found it, let's copy over the contents to our buffer
; 471  :             pBuffer = (PCHAR)((ULONG_PTR)AsyncAddressData->Buffer + ulOffset);

  00037	8b 73 0c	 mov	 esi, DWORD PTR [ebx+12]

; 472  : 
; 473  :             TRACE(TL_TRACE, ("pBuffer = 0x%x\n", pBuffer));
; 474  :             TRACE(TL_TRACE, ("Data = 0x%x\n", Data));
; 475  :             RtlCopyMemory(Data, pBuffer, nLength);

  0003a	8b 4d 14	 mov	 ecx, DWORD PTR _nLength$[ebp]
  0003d	03 75 18	 add	 esi, DWORD PTR _ulOffset$[ebp]
  00040	8b d1		 mov	 edx, ecx
  00042	57		 push	 edi
  00043	8b 7d 1c	 mov	 edi, DWORD PTR _Data$[ebp]
  00046	c1 e9 02	 shr	 ecx, 2
  00049	f3 a5		 rep movsd
  0004b	8b ca		 mov	 ecx, edx
  0004d	83 e1 03	 and	 ecx, 3
  00050	f3 a4		 rep movsb
  00052	5f		 pop	 edi

; 476  :             
; 477  :             break;

  00053	eb 02		 jmp	 SHORT $L9483
$L10638:

; 480  : 
; 481  :             AsyncAddressData = NULL;

  00055	33 db		 xor	 ebx, ebx
$L9483:

; 482  :             break;
; 483  :         }
; 484  :         else
; 485  :             AsyncAddressData = (PASYNC_ADDRESS_DATA)AsyncAddressData->AsyncAddressList.Flink;
; 486  :     }
; 487  : 
; 488  :     KeReleaseSpinLock(&deviceExtension->AsyncSpinLock, Irql);

  00057	8b 4d 08	 mov	 ecx, DWORD PTR tv131[ebp]
  0005a	8a d0		 mov	 dl, al
  0005c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@KfReleaseSpinLock@8
  00062	5e		 pop	 esi

; 489  : 
; 490  :     // never found an entry...
; 491  :     if (!AsyncAddressData) {

  00063	85 db		 test	 ebx, ebx
  00065	5b		 pop	 ebx
  00066	75 07		 jne	 SHORT $L9494

; 492  : 
; 493  :         ntStatus = STATUS_INVALID_PARAMETER;

  00068	c7 45 fc 0d 00
	00 c0		 mov	 DWORD PTR _ntStatus$[ebp], -1073741811 ; c000000dH
$L9494:

; 494  :     }
; 495  : 
; 496  :     EXIT("t1394_GetAddressData", ntStatus);
; 497  :     return(ntStatus);

  0006f	8b 45 fc	 mov	 eax, DWORD PTR _ntStatus$[ebp]

; 498  : } // t1394_GetAddressData

  00072	c9		 leave
  00073	c2 18 00	 ret	 24			; 00000018H
_t1394_GetAddressData@24 ENDP
_TEXT	ENDS
PUBLIC	_t1394_SetAddressData@24
; Function compile flags: /Ogsy
;	COMDAT _t1394_SetAddressData@24
_TEXT	SEGMENT
_ntStatus$ = -4						; size = 4
tv131 = 8						; size = 4
_DeviceObject$ = 8					; size = 4
_Irp$ = 12						; size = 4
_hAddressRange$ = 16					; size = 4
_nLength$ = 20						; size = 4
_ulOffset$ = 24						; size = 4
_Data$ = 28						; size = 4
_t1394_SetAddressData@24 PROC NEAR			; COMDAT

; 509  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 510  :     NTSTATUS                ntStatus = STATUS_SUCCESS;
; 511  :     PDEVICE_EXTENSION       deviceExtension = DeviceObject->DeviceExtension;

  00004	8b 45 08	 mov	 eax, DWORD PTR _DeviceObject$[ebp]
  00007	83 65 fc 00	 and	 DWORD PTR _ntStatus$[ebp], 0
  0000b	53		 push	 ebx
  0000c	56		 push	 esi
  0000d	8b 70 28	 mov	 esi, DWORD PTR [eax+40]

; 512  :     KIRQL                   Irql;
; 513  :     PASYNC_ADDRESS_DATA     AsyncAddressData;
; 514  : 
; 515  :     ENTER("t1394_SetAddressData");
; 516  : 
; 517  :     TRACE(TL_TRACE, ("hAddressRange = 0x%x\n", hAddressRange));
; 518  :     TRACE(TL_TRACE, ("nLength = 0x%x\n", nLength));
; 519  :     TRACE(TL_TRACE, ("ulOffset = 0x%x\n", ulOffset));
; 520  : 
; 521  :     // have to find our struct...
; 522  :     KeAcquireSpinLock(&deviceExtension->AsyncSpinLock, &Irql);

  00010	8d 4e 1c	 lea	 ecx, DWORD PTR [esi+28]
  00013	89 4d 08	 mov	 DWORD PTR tv131[ebp], ecx
  00016	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@KfAcquireSpinLock@4

; 523  : 
; 524  :     AsyncAddressData = (PASYNC_ADDRESS_DATA) deviceExtension->AsyncAddressData.Flink;

  0001c	83 c6 48	 add	 esi, 72			; 00000048H
  0001f	8b 1e		 mov	 ebx, DWORD PTR [esi]
  00021	eb 0e		 jmp	 SHORT $L10645
$L9516:

; 527  : 
; 528  :         if (AsyncAddressData->hAddressRange == hAddressRange) {

  00023	8b 4b 1c	 mov	 ecx, DWORD PTR [ebx+28]
  00026	3b 4d 10	 cmp	 ecx, DWORD PTR _hAddressRange$[ebp]
  00029	74 0c		 je	 SHORT $L10643

; 539  :         }
; 540  :         else if (AsyncAddressData->AsyncAddressList.Flink == &deviceExtension->AsyncAddressData) {

  0002b	8b 1b		 mov	 ebx, DWORD PTR [ebx]
  0002d	3b de		 cmp	 ebx, esi
  0002f	74 24		 je	 SHORT $L10644
$L10645:

; 525  : 
; 526  :     while (AsyncAddressData) {

  00031	85 db		 test	 ebx, ebx
  00033	75 ee		 jne	 SHORT $L9516

; 539  :         }
; 540  :         else if (AsyncAddressData->AsyncAddressList.Flink == &deviceExtension->AsyncAddressData) {

  00035	eb 20		 jmp	 SHORT $L9517
$L10643:

; 529  : 
; 530  :             PULONG  pBuffer;
; 531  : 
; 532  :             // found it, let's copy over the contents from data...
; 533  :             pBuffer = (PULONG)((ULONG_PTR)AsyncAddressData->Buffer + ulOffset);
; 534  : 
; 535  :             TRACE(TL_TRACE, ("pBuffer = 0x%x\n", pBuffer));
; 536  :             TRACE(TL_TRACE, ("Data = 0x%x\n", Data));
; 537  :             RtlCopyMemory(pBuffer, Data, nLength);

  00037	8b 4d 14	 mov	 ecx, DWORD PTR _nLength$[ebp]
  0003a	8b 75 1c	 mov	 esi, DWORD PTR _Data$[ebp]
  0003d	57		 push	 edi
  0003e	8b 7b 0c	 mov	 edi, DWORD PTR [ebx+12]
  00041	03 7d 18	 add	 edi, DWORD PTR _ulOffset$[ebp]
  00044	8b d1		 mov	 edx, ecx
  00046	c1 e9 02	 shr	 ecx, 2
  00049	f3 a5		 rep movsd
  0004b	8b ca		 mov	 ecx, edx
  0004d	83 e1 03	 and	 ecx, 3
  00050	f3 a4		 rep movsb
  00052	5f		 pop	 edi

; 538  :             break;

  00053	eb 02		 jmp	 SHORT $L9517
$L10644:

; 541  : 
; 542  :             AsyncAddressData = NULL;

  00055	33 db		 xor	 ebx, ebx
$L9517:

; 543  :             break;
; 544  :         }
; 545  :         else
; 546  :             AsyncAddressData = (PASYNC_ADDRESS_DATA)AsyncAddressData->AsyncAddressList.Flink;
; 547  :     }
; 548  : 
; 549  :     KeReleaseSpinLock(&deviceExtension->AsyncSpinLock, Irql);

  00057	8b 4d 08	 mov	 ecx, DWORD PTR tv131[ebp]
  0005a	8a d0		 mov	 dl, al
  0005c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@KfReleaseSpinLock@8
  00062	5e		 pop	 esi

; 550  : 
; 551  :     // never found an entry...
; 552  :     if (!AsyncAddressData) {

  00063	85 db		 test	 ebx, ebx
  00065	5b		 pop	 ebx
  00066	75 07		 jne	 SHORT $L9527

; 553  : 
; 554  :         ntStatus = STATUS_INVALID_PARAMETER;

  00068	c7 45 fc 0d 00
	00 c0		 mov	 DWORD PTR _ntStatus$[ebp], -1073741811 ; c000000dH
$L9527:

; 555  :     }
; 556  : 
; 557  :     EXIT("t1394_SetAddressData", ntStatus);
; 558  :     return(ntStatus);

  0006f	8b 45 fc	 mov	 eax, DWORD PTR _ntStatus$[ebp]

; 559  : } // t1394_SetAddressData

  00072	c9		 leave
  00073	c2 18 00	 ret	 24			; 00000018H
_t1394_SetAddressData@24 ENDP
_TEXT	ENDS
PUBLIC	_t1394_IsochDetachCompletionRoutine@12
EXTRN	__imp_@IofCompleteRequest@8:NEAR
EXTRN	__imp__IoFreeIrp@4:NEAR
EXTRN	__imp__IoFreeMdl@4:NEAR
EXTRN	__imp__ExFreePool@4:NEAR
; Function compile flags: /Ogsy
; File d:\srv03rtm\drivers\wdm\1394\tools\test\driver\common\isochapi.c
;	COMDAT _t1394_IsochDetachCompletionRoutine@12
_TEXT	SEGMENT
_DeviceObject$ = 8					; size = 4
_Irp$ = 12						; size = 4
_IsochDetachData$ = 16					; size = 4
_t1394_IsochDetachCompletionRoutine@12 PROC NEAR	; COMDAT

; 1860 : {

  00000	56		 push	 esi

; 1861 :     NTSTATUS        ntStatus = STATUS_SUCCESS;
; 1862 :     ULONG           i;
; 1863 : 
; 1864 :     ENTER("t1394_IsochDetachCompletionRoutine");
; 1865 : 
; 1866 :     if (!IsochDetachData) {

  00001	8b 74 24 10	 mov	 esi, DWORD PTR _IsochDetachData$[esp]
  00005	57		 push	 edi
  00006	33 ff		 xor	 edi, edi
  00008	3b f7		 cmp	 esi, edi
  0000a	74 7c		 je	 SHORT $Exit_IsochDetachCompletionRoutine$10446

; 1867 : 
; 1868 :         TRACE(TL_WARNING, ("Invalid IsochDetachData\n"));
; 1869 :         goto Exit_IsochDetachCompletionRoutine;
; 1870 :     }
; 1871 : 
; 1872 :     if (IsochDetachData->DetachIrb)

  0000c	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  0000f	3b c7		 cmp	 eax, edi
  00011	55		 push	 ebp
  00012	8b 2d 00 00 00
	00		 mov	 ebp, DWORD PTR __imp__ExFreePool@4
  00018	74 03		 je	 SHORT $L10447

; 1873 :     {
; 1874 :         ExFreePool(IsochDetachData->DetachIrb);

  0001a	50		 push	 eax
  0001b	ff d5		 call	 ebp
$L10447:

; 1875 :     }
; 1876 :     TRACE(TL_TRACE, ("Now lets complete the Irp.\n"));
; 1877 : 
; 1878 :     if (IsochDetachData->AttachIrb)

  0001d	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  00020	3b c7		 cmp	 eax, edi
  00022	74 03		 je	 SHORT $L10448

; 1879 :         ExFreePool(IsochDetachData->AttachIrb);

  00024	50		 push	 eax
  00025	ff d5		 call	 ebp
$L10448:
  00027	53		 push	 ebx

; 1880 : 
; 1881 :     for (i=0; i<IsochDetachData->numIsochDescriptors; i++)

  00028	33 db		 xor	 ebx, ebx
  0002a	39 7e 74	 cmp	 DWORD PTR [esi+116], edi
  0002d	76 1e		 jbe	 SHORT $L10451
$L10449:

; 1882 :     {
; 1883 : 
; 1884 :         if (IsochDetachData->IsochDescriptor[i].Mdl)

  0002f	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00032	8b 44 38 04	 mov	 eax, DWORD PTR [eax+edi+4]
  00036	85 c0		 test	 eax, eax
  00038	74 07		 je	 SHORT $L10450

; 1885 :         {
; 1886 :             IoFreeMdl(IsochDetachData->IsochDescriptor[i].Mdl);

  0003a	50		 push	 eax
  0003b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoFreeMdl@4
$L10450:
  00041	43		 inc	 ebx
  00042	81 c7 ac 00 00
	00		 add	 edi, 172		; 000000acH
  00048	3b 5e 74	 cmp	 ebx, DWORD PTR [esi+116]
  0004b	72 e2		 jb	 SHORT $L10449
$L10451:

; 1887 :         }
; 1888 :     }
; 1889 : 
; 1890 :     if (IsochDetachData->IsochDescriptor)

  0004d	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00050	85 c0		 test	 eax, eax
  00052	5b		 pop	 ebx
  00053	74 03		 je	 SHORT $L10453

; 1891 :     {
; 1892 :         ExFreePool(IsochDetachData->IsochDescriptor);

  00055	50		 push	 eax
  00056	ff d5		 call	 ebp
$L10453:

; 1893 :     }
; 1894 :     
; 1895 :     // only set this if its a success...
; 1896 :     if (NT_SUCCESS(IsochDetachData->AttachStatus))

  00058	83 7e 20 00	 cmp	 DWORD PTR [esi+32], 0
  0005c	7c 09		 jl	 SHORT $L10455

; 1897 :     {
; 1898 :         IsochDetachData->Irp->IoStatus.Information = IsochDetachData->outputBufferLength;

  0005e	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00061	8b 4e 78	 mov	 ecx, DWORD PTR [esi+120]
  00064	89 48 1c	 mov	 DWORD PTR [eax+28], ecx
$L10455:

; 1899 :     }
; 1900 :     
; 1901 :     IsochDetachData->Irp->IoStatus.Status = IsochDetachData->AttachStatus;

  00067	8b 4e 20	 mov	 ecx, DWORD PTR [esi+32]
  0006a	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0006d	89 48 18	 mov	 DWORD PTR [eax+24], ecx

; 1902 : 
; 1903 :     //
; 1904 :     // Complete original Irp and free the one we allocated in
; 1905 :     // IsochAttachBuffers
; 1906 :     //
; 1907 :     IoCompleteRequest(IsochDetachData->Irp, IO_NO_INCREMENT);

  00070	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  00073	32 d2		 xor	 dl, dl
  00075	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@IofCompleteRequest@8

; 1908 :     IoFreeIrp (IsochDetachData->newIrp);

  0007b	ff 76 14	 push	 DWORD PTR [esi+20]
  0007e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoFreeIrp@4

; 1909 : 
; 1910 :     // all done with IsochDetachData, lets deallocate it...
; 1911 :     if (IsochDetachData)
; 1912 :     {
; 1913 :         ExFreePool(IsochDetachData);

  00084	56		 push	 esi
  00085	ff d5		 call	 ebp
  00087	5d		 pop	 ebp
$Exit_IsochDetachCompletionRoutine$10446:
  00088	5f		 pop	 edi

; 1914 :     }
; 1915 :     
; 1916 : Exit_IsochDetachCompletionRoutine:
; 1917 : 
; 1918 :     EXIT("t1394_IsochDetachCompletionRoutine", ntStatus);
; 1919 :     return(STATUS_MORE_PROCESSING_REQUIRED);

  00089	b8 16 00 00 c0	 mov	 eax, -1073741802	; c0000016H
  0008e	5e		 pop	 esi

; 1920 : } // t1394_IsochDetachCompletionRoutine

  0008f	c2 0c 00	 ret	 12			; 0000000cH
_t1394_IsochDetachCompletionRoutine@12 ENDP
_TEXT	ENDS
PUBLIC	_t1394_IsochAttachCompletionRoutine@12
EXTRN	__imp__KeCancelTimer@4:NEAR
; Function compile flags: /Ogsy
;	COMDAT _t1394_IsochAttachCompletionRoutine@12
_TEXT	SEGMENT
_DeviceObject$ = 8					; size = 4
_Irp$ = 12						; size = 4
_i$ = 16						; size = 4
_IsochDetachData$ = 16					; size = 4
_Irql$ = 19						; size = 1
_t1394_IsochAttachCompletionRoutine@12 PROC NEAR	; COMDAT

; 1928 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1929 : 	PDEVICE_EXTENSION   DeviceExtension;
; 1930 :     NTSTATUS            ntStatus 		= STATUS_SUCCESS;
; 1931 :     ULONG               i;
; 1932 :     KIRQL               Irql;
; 1933 : 
; 1934 :     ENTER("t1394_IsochAttachCompletionRoutine");
; 1935 : 
; 1936 :     if (!NT_SUCCESS(Irp->IoStatus.Status))

  00003	8b 45 0c	 mov	 eax, DWORD PTR _Irp$[ebp]
  00006	83 78 18 00	 cmp	 DWORD PTR [eax+24], 0
  0000a	0f 8d c2 00 00
	00		 jge	 $Exit_IsochAttachCompletionRoutine$10474
  00010	53		 push	 ebx
  00011	56		 push	 esi

; 1937 :     {
; 1938 : 		// make sure this irp is still on the device extension list, meaning no one else
; 1939 : 		// has already handled this yet
; 1940 : 		DeviceExtension = IsochDetachData->DeviceExtension;

  00012	8b 75 10	 mov	 esi, DWORD PTR _IsochDetachData$[ebp]
  00015	57		 push	 edi
  00016	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]

; 1941 : 		KeAcquireSpinLock(&DeviceExtension->IsochSpinLock, &Irql);

  00019	8d 5f 20	 lea	 ebx, DWORD PTR [edi+32]
  0001c	8b cb		 mov	 ecx, ebx
  0001e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@KfAcquireSpinLock@4

; 1942 : 		if (t1394_IsOnList(&IsochDetachData->IsochDetachList, &DeviceExtension->IsochDetachData))

  00024	83 c7 50	 add	 edi, 80			; 00000050H
  00027	57		 push	 edi
  00028	8a d0		 mov	 dl, al
  0002a	56		 push	 esi
  0002b	88 55 13	 mov	 BYTE PTR _Irql$[ebp], dl
  0002e	e8 00 00 00 00	 call	 _t1394_IsOnList@8
  00033	84 c0		 test	 al, al
  00035	0f 84 8c 00 00
	00		 je	 $L10472

; 1943 : 		{
; 1944 :         	RemoveEntryList(&IsochDetachData->IsochDetachList);

  0003b	8b 06		 mov	 eax, DWORD PTR [esi]
  0003d	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00040	89 01		 mov	 DWORD PTR [ecx], eax
  00042	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 1945 :         	KeCancelTimer(&IsochDetachData->Timer);

  00045	8d 46 28	 lea	 eax, DWORD PTR [esi+40]
  00048	50		 push	 eax
  00049	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeCancelTimer@4

; 1946 : 			KeReleaseSpinLock(&DeviceExtension->IsochSpinLock, Irql);		

  0004f	8a 55 13	 mov	 dl, BYTE PTR _Irql$[ebp]
  00052	8b cb		 mov	 ecx, ebx
  00054	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@KfReleaseSpinLock@8

; 1952 : 			goto Exit_IsochAttachCompletionRoutine;
; 1953 : 		}
; 1954 :         TRACE(TL_ERROR, ("Isoch Attach Failed! = 0x%x\n", Irp->IoStatus.Status));
; 1955 :         ntStatus = Irp->IoStatus.Status;
; 1956 :     
; 1957 :         if (!IsochDetachData)
; 1958 :         {        
; 1959 :             goto Exit_IsochAttachCompletionRoutine;
; 1960 :         }
; 1961 : 
; 1962 :         DeviceExtension = IsochDetachData->DeviceExtension;
; 1963 : 
; 1964 :         TRACE(TL_TRACE, ("IsochAttachCompletionRoutine: IsochDetachData = 0x%x\n", IsochDetachData));
; 1965 :         TRACE(TL_TRACE, ("IsochAttachCompletionRoutine: IsochDetachData->Irp = 0x%x\n", IsochDetachData->Irp));
; 1966 :         TRACE(TL_TRACE, ("IsochAttachCompletionRoutine: IsochDetachData->newIrp = 0x%x\n", IsochDetachData->newIrp));
; 1967 :         TRACE(TL_TRACE, ("Now lets complete Irp.\n"));
; 1968 : 
; 1969 :         if (IsochDetachData->AttachIrb)

  0005a	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  0005d	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__ExFreePool@4
  00063	33 db		 xor	 ebx, ebx
  00065	3b c3		 cmp	 eax, ebx
  00067	74 03		 je	 SHORT $L10476

; 1970 :         {
; 1971 :             ExFreePool(IsochDetachData->AttachIrb);

  00069	50		 push	 eax
  0006a	ff d7		 call	 edi
$L10476:

; 1972 : 		}
; 1973 : 
; 1974 :         for (i=0; i<IsochDetachData->numIsochDescriptors; i++)

  0006c	39 5e 74	 cmp	 DWORD PTR [esi+116], ebx
  0006f	89 5d 10	 mov	 DWORD PTR _i$[ebp], ebx
  00072	76 23		 jbe	 SHORT $L10479
$L10477:

; 1975 :         {
; 1976 :             if (IsochDetachData->IsochDescriptor[i].Mdl)

  00074	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00077	8b 44 03 04	 mov	 eax, DWORD PTR [ebx+eax+4]
  0007b	85 c0		 test	 eax, eax
  0007d	74 07		 je	 SHORT $L10478

; 1977 :             {
; 1978 :                 IoFreeMdl(IsochDetachData->IsochDescriptor[i].Mdl);

  0007f	50		 push	 eax
  00080	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoFreeMdl@4
$L10478:
  00086	ff 45 10	 inc	 DWORD PTR _i$[ebp]
  00089	8b 45 10	 mov	 eax, DWORD PTR _i$[ebp]
  0008c	81 c3 ac 00 00
	00		 add	 ebx, 172		; 000000acH
  00092	3b 46 74	 cmp	 eax, DWORD PTR [esi+116]
  00095	72 dd		 jb	 SHORT $L10477
$L10479:

; 1979 :             }
; 1980 :         }
; 1981 : 
; 1982 :         ExFreePool(IsochDetachData->IsochDescriptor);

  00097	ff 76 0c	 push	 DWORD PTR [esi+12]
  0009a	ff d7		 call	 edi

; 1983 : 
; 1984 :         //
; 1985 :         // Complete original Irp and free the one we allocated in
; 1986 :         // IsochAttachBuffers
; 1987 :         //
; 1988 :         IsochDetachData->Irp->IoStatus = Irp->IoStatus;

  0009c	8b 45 0c	 mov	 eax, DWORD PTR _Irp$[ebp]
  0009f	8b 50 18	 mov	 edx, DWORD PTR [eax+24]
  000a2	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  000a5	89 51 18	 mov	 DWORD PTR [ecx+24], edx
  000a8	8b 40 1c	 mov	 eax, DWORD PTR [eax+28]
  000ab	89 41 1c	 mov	 DWORD PTR [ecx+28], eax

; 1989 :         IoCompleteRequest(IsochDetachData->Irp, IO_NO_INCREMENT);

  000ae	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  000b1	32 d2		 xor	 dl, dl
  000b3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@IofCompleteRequest@8

; 1990 :         IoFreeIrp (IsochDetachData->newIrp);

  000b9	ff 76 14	 push	 DWORD PTR [esi+20]
  000bc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoFreeIrp@4

; 1991 : 
; 1992 :         // all done with IsochDetachData, lets deallocate it...
; 1993 :         ExFreePool(IsochDetachData);

  000c2	56		 push	 esi
  000c3	ff d7		 call	 edi
  000c5	eb 08		 jmp	 SHORT $L10660
$L10472:

; 1947 : 		}
; 1948 : 		else
; 1949 : 		{
; 1950 : 			// just bomb out here
; 1951 : 			KeReleaseSpinLock(&DeviceExtension->IsochSpinLock, Irql);

  000c7	8b cb		 mov	 ecx, ebx
  000c9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@KfReleaseSpinLock@8
$L10660:
  000cf	5f		 pop	 edi
  000d0	5e		 pop	 esi
  000d1	5b		 pop	 ebx
$Exit_IsochAttachCompletionRoutine$10474:

; 1994 :     }
; 1995 : 
; 1996 : Exit_IsochAttachCompletionRoutine:
; 1997 : 
; 1998 :     EXIT("t1394_IsochAttachCompletionRoutine", ntStatus);
; 1999 :     return(STATUS_MORE_PROCESSING_REQUIRED);

  000d2	b8 16 00 00 c0	 mov	 eax, -1073741802	; c0000016H

; 2000 : } // t1394_IsochAttachCompletionRoutine

  000d7	5d		 pop	 ebp
  000d8	c2 0c 00	 ret	 12			; 0000000cH
_t1394_IsochAttachCompletionRoutine@12 ENDP
_TEXT	ENDS
PUBLIC	_t1394VDev_Create@8
; Function compile flags: /Ogsy
; File d:\srv03rtm\drivers\wdm\1394\tools\test\driver\1394vdev\1394vdev.c
;	COMDAT _t1394VDev_Create@8
_TEXT	SEGMENT
_DriverObject$ = 8					; size = 4
_Irp$ = 12						; size = 4
_t1394VDev_Create@8 PROC NEAR				; COMDAT

; 59   :     NTSTATUS    ntStatus = STATUS_SUCCESS;
; 60   : 
; 61   :     ENTER("t1394VDev_Create");
; 62   : 
; 63   :     Irp->IoStatus.Status = STATUS_SUCCESS;

  00000	8b 4c 24 08	 mov	 ecx, DWORD PTR _Irp$[esp-4]
  00004	83 61 18 00	 and	 DWORD PTR [ecx+24], 0

; 64   :     IoCompleteRequest(Irp, IO_NO_INCREMENT);

  00008	32 d2		 xor	 dl, dl
  0000a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@IofCompleteRequest@8

; 65   : 
; 66   :     EXIT("t1394VDev_Create", ntStatus);
; 67   :     return(ntStatus);

  00010	33 c0		 xor	 eax, eax

; 68   : } // t1394VDev_Create

  00012	c2 08 00	 ret	 8
_t1394VDev_Create@8 ENDP
_TEXT	ENDS
PUBLIC	_t1394VDev_Close@8
; Function compile flags: /Ogsy
;	COMDAT _t1394VDev_Close@8
_TEXT	SEGMENT
_DriverObject$ = 8					; size = 4
_Irp$ = 12						; size = 4
_t1394VDev_Close@8 PROC NEAR				; COMDAT

; 76   :     NTSTATUS    ntStatus = STATUS_SUCCESS;
; 77   : 
; 78   :     ENTER("t1394VDev_Close");
; 79   : 
; 80   :     Irp->IoStatus.Status = STATUS_SUCCESS;

  00000	8b 4c 24 08	 mov	 ecx, DWORD PTR _Irp$[esp-4]
  00004	83 61 18 00	 and	 DWORD PTR [ecx+24], 0

; 81   :     IoCompleteRequest(Irp, IO_NO_INCREMENT);

  00008	32 d2		 xor	 dl, dl
  0000a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@IofCompleteRequest@8

; 82   : 
; 83   :     EXIT("t1394VDev_Close", ntStatus);
; 84   :     return(ntStatus);

  00010	33 c0		 xor	 eax, eax

; 85   : } // t1394VDev_Close

  00012	c2 08 00	 ret	 8
_t1394VDev_Close@8 ENDP
_TEXT	ENDS
PUBLIC	_t1394VDev_CancelIrp@8
EXTRN	__imp__IoReleaseCancelSpinLock@4:NEAR
; Function compile flags: /Ogsy
;	COMDAT _t1394VDev_CancelIrp@8
_TEXT	SEGMENT
_DeviceObject$ = 8					; size = 4
_Irp$ = 12						; size = 4
_t1394VDev_CancelIrp@8 PROC NEAR			; COMDAT

; 93   :     KIRQL               Irql;
; 94   :     PBUS_RESET_IRP      BusResetIrp;
; 95   :     PDEVICE_EXTENSION   deviceExtension;
; 96   : 
; 97   :     ENTER("t1394VDev_CancelIrp");
; 98   : 
; 99   :     deviceExtension = DeviceObject->DeviceExtension;

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _DeviceObject$[esp-4]
  00004	53		 push	 ebx
  00005	56		 push	 esi
  00006	8b 70 28	 mov	 esi, DWORD PTR [eax+40]
  00009	57		 push	 edi

; 100  : 
; 101  :     KeAcquireSpinLock(&deviceExtension->ResetSpinLock, &Irql);

  0000a	8d 7e 14	 lea	 edi, DWORD PTR [esi+20]
  0000d	8b cf		 mov	 ecx, edi
  0000f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@KfAcquireSpinLock@4

; 102  : 
; 103  :     BusResetIrp = (PBUS_RESET_IRP) deviceExtension->BusResetIrps.Flink;

  00015	8d 4e 38	 lea	 ecx, DWORD PTR [esi+56]

; 104  : 
; 105  :     TRACE(TL_TRACE, ("Irp = 0x%x\n", Irp));
; 106  : 
; 107  :     while (BusResetIrp) {

  00018	8b 74 24 14	 mov	 esi, DWORD PTR _Irp$[esp+8]
  0001c	8a d8		 mov	 bl, al
  0001e	8b 01		 mov	 eax, DWORD PTR [ecx]
  00020	eb 0b		 jmp	 SHORT $L10679
$L10515:

; 108  : 
; 109  :         TRACE(TL_TRACE, ("Cancelling BusResetIrp->Irp = 0x%x\n", BusResetIrp->Irp));
; 110  : 
; 111  :         if (BusResetIrp->Irp == Irp) {

  00022	39 70 08	 cmp	 DWORD PTR [eax+8], esi
  00025	74 0c		 je	 SHORT $L10677

; 115  :             break;
; 116  :         }
; 117  :         else if (BusResetIrp->BusResetIrpList.Flink == &deviceExtension->BusResetIrps) {

  00027	8b 00		 mov	 eax, DWORD PTR [eax]
  00029	3b c1		 cmp	 eax, ecx
  0002b	74 17		 je	 SHORT $L10678
$L10679:

; 104  : 
; 105  :     TRACE(TL_TRACE, ("Irp = 0x%x\n", Irp));
; 106  : 
; 107  :     while (BusResetIrp) {

  0002d	85 c0		 test	 eax, eax
  0002f	75 f1		 jne	 SHORT $L10515

; 115  :             break;
; 116  :         }
; 117  :         else if (BusResetIrp->BusResetIrpList.Flink == &deviceExtension->BusResetIrps) {

  00031	eb 11		 jmp	 SHORT $L10678
$L10677:

; 112  : 
; 113  :             RemoveEntryList(&BusResetIrp->BusResetIrpList);

  00033	8b 08		 mov	 ecx, DWORD PTR [eax]
  00035	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00038	89 0a		 mov	 DWORD PTR [edx], ecx

; 114  :             ExFreePool(BusResetIrp);

  0003a	50		 push	 eax
  0003b	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  0003e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePool@4
$L10678:

; 118  :             break;
; 119  :         }
; 120  :         else
; 121  :             BusResetIrp = (PBUS_RESET_IRP)BusResetIrp->BusResetIrpList.Flink;
; 122  :     }
; 123  : 
; 124  :     KeReleaseSpinLock(&deviceExtension->ResetSpinLock, Irql);

  00044	8a d3		 mov	 dl, bl
  00046	8b cf		 mov	 ecx, edi
  00048	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@KfReleaseSpinLock@8

; 125  : 
; 126  :     IoReleaseCancelSpinLock(Irp->CancelIrql);

  0004e	33 c0		 xor	 eax, eax
  00050	8a 46 25	 mov	 al, BYTE PTR [esi+37]
  00053	50		 push	 eax
  00054	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoReleaseCancelSpinLock@4

; 127  : 
; 128  :     Irp->IoStatus.Status = STATUS_CANCELLED;
; 129  :     IoCompleteRequest(Irp, IO_NO_INCREMENT);

  0005a	32 d2		 xor	 dl, dl
  0005c	8b ce		 mov	 ecx, esi
  0005e	c7 46 18 20 01
	00 c0		 mov	 DWORD PTR [esi+24], -1073741536 ; c0000120H
  00065	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@IofCompleteRequest@8
  0006b	5f		 pop	 edi
  0006c	5e		 pop	 esi
  0006d	5b		 pop	 ebx

; 130  : 
; 131  :     EXIT("t1394VDev_CancelIrp", STATUS_SUCCESS);
; 132  : } // t1394VDev_CancelIrp

  0006e	c2 08 00	 ret	 8
_t1394VDev_CancelIrp@8 ENDP
_TEXT	ENDS
PUBLIC	_t1394_SubmitIrpSynch@12
EXTRN	__imp__KeInitializeEvent@12:NEAR
EXTRN	__imp__KeWaitForSingleObject@20:NEAR
EXTRN	__imp__KeGetCurrentIrql@0:NEAR
; Function compile flags: /Ogsy
; File d:\srv03rtm\drivers\wdm\1394\tools\test\driver\common\util.c
;	COMDAT _t1394_SubmitIrpSynch@12
_TEXT	SEGMENT
_Event$ = -16						; size = 16
_DeviceObject$ = 8					; size = 4
_Irp$ = 12						; size = 4
_Irb$ = 16						; size = 4
_t1394_SubmitIrpSynch@12 PROC NEAR			; COMDAT

; 54   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 55   :     NTSTATUS            ntStatus = STATUS_SUCCESS;
; 56   :     KEVENT              Event;
; 57   :     PIO_STACK_LOCATION  NextIrpStack;
; 58   : 
; 59   :     ENTER("t1394_SubmitIrpSynch");
; 60   : 
; 61   :     TRACE(TL_TRACE, ("DeviceObject = 0x%x\n", DeviceObject));
; 62   :     TRACE(TL_TRACE, ("Irp = 0x%x\n", Irp));
; 63   :     TRACE(TL_TRACE, ("Irb = 0x%x\n", Irb));
; 64   :  
; 65   :     if (Irb) {

  00006	8b 4d 10	 mov	 ecx, DWORD PTR _Irb$[ebp]
  00009	85 c9		 test	 ecx, ecx
  0000b	53		 push	 ebx

; 66   : 
; 67   :         NextIrpStack = IoGetNextIrpStackLocation(Irp);

  0000c	8b 5d 0c	 mov	 ebx, DWORD PTR _Irp$[ebp]
  0000f	74 15		 je	 SHORT $L8738
  00011	8b 43 60	 mov	 eax, DWORD PTR [ebx+96]
  00014	83 e8 24	 sub	 eax, 36			; 00000024H

; 68   :         NextIrpStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;

  00017	c6 00 0f	 mov	 BYTE PTR [eax], 15	; 0000000fH

; 69   :         NextIrpStack->Parameters.DeviceIoControl.IoControlCode = IOCTL_1394_CLASS;

  0001a	c7 40 0c 1d 02
	22 00		 mov	 DWORD PTR [eax+12], 2228765 ; 0022021dH

; 70   :         NextIrpStack->Parameters.Others.Argument1 = Irb;

  00021	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 71   :     }
; 72   :     else {

  00024	eb 15		 jmp	 SHORT $L8739
$L8738:
  00026	56		 push	 esi

; 73   : 
; 74   :         IoCopyCurrentIrpStackLocationToNext(Irp);

  00027	8b 73 60	 mov	 esi, DWORD PTR [ebx+96]
  0002a	57		 push	 edi
  0002b	8d 46 dc	 lea	 eax, DWORD PTR [esi-36]
  0002e	6a 07		 push	 7
  00030	59		 pop	 ecx
  00031	8b f8		 mov	 edi, eax
  00033	f3 a5		 rep movsd
  00035	5f		 pop	 edi
  00036	c6 40 03 00	 mov	 BYTE PTR [eax+3], 0
  0003a	5e		 pop	 esi
$L8739:

; 75   :     }
; 76   : 
; 77   :     KeInitializeEvent(&Event, SynchronizationEvent, FALSE);

  0003b	6a 00		 push	 0
  0003d	6a 01		 push	 1
  0003f	8d 45 f0	 lea	 eax, DWORD PTR _Event$[ebp]
  00042	50		 push	 eax
  00043	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeInitializeEvent@12

; 78   : 
; 79   :     IoSetCompletionRoutine( Irp,
; 80   :                             t1394_SynchCompletionRoutine,
; 81   :                             &Event,
; 82   :                             TRUE,
; 83   :                             TRUE,
; 84   :                             TRUE
; 85   :                             );

  00049	8b 43 60	 mov	 eax, DWORD PTR [ebx+96]
  0004c	83 e8 24	 sub	 eax, 36			; 00000024H
  0004f	8d 4d f0	 lea	 ecx, DWORD PTR _Event$[ebp]
  00052	89 48 20	 mov	 DWORD PTR [eax+32], ecx

; 86   : 
; 87   :     ntStatus = IoCallDriver(DeviceObject, Irp);

  00055	8b 4d 08	 mov	 ecx, DWORD PTR _DeviceObject$[ebp]
  00058	8b d3		 mov	 edx, ebx
  0005a	c7 40 1c 00 00
	00 00		 mov	 DWORD PTR [eax+28], OFFSET FLAT:_t1394_SynchCompletionRoutine@12
  00061	c6 40 03 e0	 mov	 BYTE PTR [eax+3], 224	; 000000e0H
  00065	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@IofCallDriver@8

; 88   : 
; 89   :     if (ntStatus == STATUS_PENDING) {

  0006b	3d 03 01 00 00	 cmp	 eax, 259		; 00000103H
  00070	75 1a		 jne	 SHORT $L8752

; 90   : 
; 91   :         TRACE(TL_TRACE, ("t1394_SubmitIrpSynch: Irp is pending...\n"));
; 92   :        
; 93   :         // we can only wait for our completion routine if we are less than dispatch level
; 94   :         if (KeGetCurrentIrql() < DISPATCH_LEVEL) 

  00072	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeGetCurrentIrql@0
  00078	3c 02		 cmp	 al, 2
  0007a	73 10		 jae	 SHORT $L8752

; 95   :         {
; 96   :             KeWaitForSingleObject( &Event,
; 97   :                                    Executive,
; 98   :                                    KernelMode,
; 99   :                                    FALSE,
; 100  :                                    NULL
; 101  :                                    );

  0007c	33 c0		 xor	 eax, eax
  0007e	50		 push	 eax
  0007f	50		 push	 eax
  00080	50		 push	 eax
  00081	50		 push	 eax
  00082	8d 45 f0	 lea	 eax, DWORD PTR _Event$[ebp]
  00085	50		 push	 eax
  00086	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeWaitForSingleObject@20
$L8752:

; 102  : 
; 103  :         }
; 104  :         else
; 105  :         {
; 106  :             TRACE(TL_WARNING, ("STATUS_PENDING returned at >= DISPATCH_LEVEL\n"));
; 107  :         }                      
; 108  :     }
; 109  : 
; 110  :     ntStatus = Irp->IoStatus.Status;
; 111  :     EXIT("t1394_SubmitIrpSynch", ntStatus);
; 112  :     return(ntStatus);

  0008c	8b 43 18	 mov	 eax, DWORD PTR [ebx+24]
  0008f	5b		 pop	 ebx

; 113  : } // t1394_SubmitIrpSynch

  00090	c9		 leave
  00091	c2 0c 00	 ret	 12			; 0000000cH
_t1394_SubmitIrpSynch@12 ENDP
_TEXT	ENDS
PUBLIC	_t1394_UpdateGenerationCount@8
EXTRN	__imp__IoAllocateIrp@8:NEAR
EXTRN	__imp__ExAllocatePoolWithTag@12:NEAR
EXTRN	_IoFreeWorkItem@4:NEAR
; Function compile flags: /Ogsy
;	COMDAT _t1394_UpdateGenerationCount@8
_TEXT	SEGMENT
_Irp$ = 8						; size = 4
_DeviceObject$ = 8					; size = 4
_Context$ = 12						; size = 4
_t1394_UpdateGenerationCount@8 PROC NEAR		; COMDAT

; 165  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 166  : 	PDEVICE_EXTENSION       deviceExtension = DeviceObject->DeviceExtension;

  00003	8b 45 08	 mov	 eax, DWORD PTR _DeviceObject$[ebp]
  00006	53		 push	 ebx
  00007	8b 58 28	 mov	 ebx, DWORD PTR [eax+40]

; 167  : 	PIO_WORKITEM			ioWorkItem		= Context;
; 168  : 	NTSTATUS				ntStatus		= STATUS_SUCCESS;
; 169  : 	PIRB					Irb				= NULL;
; 170  : 	PIRP					Irp				= NULL;
; 171  : 		
; 172  : 
; 173  : 	ENTER("t1394_UpdateGenerationCountWorkItem");
; 174  : 
; 175  : 	// allocate irp
; 176  :     Irp = IoAllocateIrp (deviceExtension->StackDeviceObject->StackSize, FALSE);

  0000a	8b 03		 mov	 eax, DWORD PTR [ebx]
  0000c	0f be 40 30	 movsx	 eax, BYTE PTR [eax+48]
  00010	6a 00		 push	 0
  00012	50		 push	 eax
  00013	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoAllocateIrp@8

; 177  : 	if (!Irp)

  00019	85 c0		 test	 eax, eax
  0001b	89 45 08	 mov	 DWORD PTR _Irp$[ebp], eax
  0001e	74 57		 je	 SHORT $L8800
  00020	56		 push	 esi

; 178  : 	{
; 179  : 		ntStatus = STATUS_INSUFFICIENT_RESOURCES;
; 180  : 		TRACE(TL_ERROR, ("Failed to allocate Irp!\n"));
; 181  : 		goto Exit_UpdateGenerationCountWorkItem;
; 182  : 	}
; 183  : 
; 184  : 	// allocate irb
; 185  : 	Irb = ExAllocatePool(NonPagedPool, sizeof (IRB));

  00021	68 57 64 6d 20	 push	 544040023		; 206d6457H
  00026	68 58 01 00 00	 push	 344			; 00000158H
  0002b	6a 00		 push	 0
  0002d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExAllocatePoolWithTag@12
  00033	8b f0		 mov	 esi, eax

; 186  : 	if (!Irb)

  00035	85 f6		 test	 esi, esi
  00037	74 29		 je	 SHORT $Exit_UpdateGenerationCountWorkItem$8791
  00039	57		 push	 edi

; 187  : 	{
; 188  : 		ntStatus = STATUS_INSUFFICIENT_RESOURCES;
; 189  : 		TRACE(TL_ERROR, ("Failed to allocate Irb!\n"));
; 190  : 		goto Exit_UpdateGenerationCountWorkItem;
; 191  : 	}
; 192  : 
; 193  : 	// send request down stack
; 194  :     RtlZeroMemory (Irb, sizeof (IRB));

  0003a	6a 56		 push	 86			; 00000056H
  0003c	59		 pop	 ecx

; 195  :     Irb->FunctionNumber = REQUEST_GET_GENERATION_COUNT;
; 196  :     Irb->Flags = 0;
; 197  : 
; 198  : 	ntStatus = t1394_SubmitIrpSynch(deviceExtension->StackDeviceObject, Irp, Irb);

  0003d	56		 push	 esi
  0003e	ff 75 08	 push	 DWORD PTR _Irp$[ebp]
  00041	33 c0		 xor	 eax, eax
  00043	8b fe		 mov	 edi, esi
  00045	f3 ab		 rep stosd
  00047	21 46 04	 and	 DWORD PTR [esi+4], eax
  0004a	c7 06 1a 00 00
	00		 mov	 DWORD PTR [esi], 26	; 0000001aH
  00050	ff 33		 push	 DWORD PTR [ebx]
  00052	e8 00 00 00 00	 call	 _t1394_SubmitIrpSynch@12

; 199  :     
; 200  : 	// update DeviceExtension->GenerationCount
; 201  : 	if (NT_SUCCESS(ntStatus))

  00057	85 c0		 test	 eax, eax
  00059	5f		 pop	 edi
  0005a	7c 06		 jl	 SHORT $Exit_UpdateGenerationCountWorkItem$8791

; 202  : 	{
; 203  :         deviceExtension->GenerationCount = Irb->u.GetGenerationCount.GenerationCount;

  0005c	8b 46 48	 mov	 eax, DWORD PTR [esi+72]
  0005f	89 43 34	 mov	 DWORD PTR [ebx+52], eax
$Exit_UpdateGenerationCountWorkItem$8791:

; 204  :         TRACE(TL_TRACE, ("GenerationCount = 0x%x\n", deviceExtension->GenerationCount));
; 205  :     }
; 206  :     else
; 207  : 	{
; 208  :         TRACE(TL_ERROR, ("SubmitIrpSync failed = 0x%x\n", ntStatus));
; 209  :     }
; 210  : 	
; 211  : Exit_UpdateGenerationCountWorkItem:
; 212  : 
; 213  : 	if (Irp)
; 214  : 	{
; 215  : 		IoFreeIrp(Irp);

  00062	ff 75 08	 push	 DWORD PTR _Irp$[ebp]
  00065	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoFreeIrp@4

; 216  : 	}
; 217  : 
; 218  : 	if (Irb)

  0006b	85 f6		 test	 esi, esi
  0006d	74 07		 je	 SHORT $L10686

; 219  : 	{
; 220  : 		ExFreePool (Irb);

  0006f	56		 push	 esi
  00070	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePool@4
$L10686:
  00076	5e		 pop	 esi
$L8800:

; 221  : 	}
; 222  : 
; 223  : 	if (ioWorkItem)

  00077	83 7d 0c 00	 cmp	 DWORD PTR _Context$[ebp], 0
  0007b	5b		 pop	 ebx
  0007c	74 08		 je	 SHORT $L8801

; 224  : 	{
; 225  : 		IoFreeWorkItem(ioWorkItem);

  0007e	ff 75 0c	 push	 DWORD PTR _Context$[ebp]
  00081	e8 00 00 00 00	 call	 _IoFreeWorkItem@4
$L8801:

; 226  : 	}
; 227  : 
; 228  : 	EXIT("t1394_UpdateGenerationCountWorkItem", ntStatus);
; 229  : 
; 230  : 	return;
; 231  : }

  00086	5d		 pop	 ebp
  00087	c2 08 00	 ret	 8
_t1394_UpdateGenerationCount@8 ENDP
_TEXT	ENDS
PUBLIC	_t1394_GetLocalHostInformation@20
EXTRN	__imp__IoBuildDeviceIoControlRequest@36:NEAR
; Function compile flags: /Ogsy
; File d:\srv03rtm\drivers\wdm\1394\tools\test\driver\common\1394api.c
;	COMDAT _t1394_GetLocalHostInformation@20
_TEXT	SEGMENT
_Event$ = -72						; size = 16
_LocalHostInfo7$ = -56					; size = 16
_LocalHostInfo6$ = -40					; size = 16
_ioStatus$ = -24					; size = 8
_LocalHostInfo5$ = -16					; size = 8
_newIrp$ = -8						; size = 4
_deviceExtension$ = -4					; size = 4
_ntStatus$ = -4						; size = 4
_DeviceObject$ = 8					; size = 4
_allocNewIrp$ = 11					; size = 1
_Irp$ = 12						; size = 4
_nLevel$ = 16						; size = 4
_UserStatus$ = 20					; size = 4
_Information$ = 24					; size = 4
_t1394_GetLocalHostInformation@20 PROC NEAR		; COMDAT

; 38   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H

; 39   :     NTSTATUS                ntStatus = STATUS_SUCCESS;
; 40   :     PDEVICE_EXTENSION       deviceExtension = DeviceObject->DeviceExtension;

  00006	8b 45 08	 mov	 eax, DWORD PTR _DeviceObject$[ebp]
  00009	8b 40 28	 mov	 eax, DWORD PTR [eax+40]
  0000c	56		 push	 esi
  0000d	57		 push	 edi

; 41   :     PIRB                    pIrb;
; 42   : 	GET_LOCAL_HOST_INFO7	LocalHostInfo7;
; 43   :     GET_LOCAL_HOST_INFO6    LocalHostInfo6;
; 44   :     GET_LOCAL_HOST_INFO5    LocalHostInfo5;
; 45   : 
; 46   :     PIRP                    newIrp;
; 47   :     BOOLEAN                 allocNewIrp = FALSE;
; 48   :     KEVENT                  Event;
; 49   :     IO_STATUS_BLOCK         ioStatus;
; 50   :     
; 51   :     ENTER("t1394_GetLocalHostInformation");
; 52   : 
; 53   :     TRACE(TL_TRACE, ("nLevel = 0x%x\n", nLevel));
; 54   :     TRACE(TL_TRACE, ("Information = 0x%x\n", Information));
; 55   : 
; 56   :     //
; 57   :     // If this is a UserMode request create a newIrp so that the request
; 58   :     // will be issued from KernelMode
; 59   :     //
; 60   :     if (Irp->RequestorMode == UserMode) {

  0000e	8b 7d 0c	 mov	 edi, DWORD PTR _Irp$[ebp]

; 61   : 
; 62   :         newIrp = IoBuildDeviceIoControlRequest (IOCTL_1394_CLASS, deviceExtension->StackDeviceObject, 
; 63   :                             NULL, 0, NULL, 0, TRUE, &Event, &ioStatus);

  00011	33 f6		 xor	 esi, esi
  00013	80 7f 20 01	 cmp	 BYTE PTR [edi+32], 1
  00017	89 45 fc	 mov	 DWORD PTR _deviceExtension$[ebp], eax
  0001a	c6 45 0b 00	 mov	 BYTE PTR _allocNewIrp$[ebp], 0
  0001e	75 32		 jne	 SHORT $L8825
  00020	8d 4d e8	 lea	 ecx, DWORD PTR _ioStatus$[ebp]
  00023	51		 push	 ecx
  00024	8d 4d b8	 lea	 ecx, DWORD PTR _Event$[ebp]
  00027	51		 push	 ecx
  00028	6a 01		 push	 1
  0002a	56		 push	 esi
  0002b	56		 push	 esi
  0002c	56		 push	 esi
  0002d	56		 push	 esi
  0002e	ff 30		 push	 DWORD PTR [eax]
  00030	68 1d 02 22 00	 push	 2228765			; 0022021dH
  00035	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoBuildDeviceIoControlRequest@36

; 64   : 
; 65   :         if (!newIrp) {

  0003b	3b c6		 cmp	 eax, esi
  0003d	89 45 f8	 mov	 DWORD PTR _newIrp$[ebp], eax
  00040	75 0c		 jne	 SHORT $L8828

; 66   : 
; 67   :             TRACE(TL_ERROR, ("Failed to allocate newIrp!\n"));
; 68   :             ntStatus = STATUS_INSUFFICIENT_RESOURCES;

  00042	c7 45 fc 9a 00
	00 c0		 mov	 DWORD PTR _ntStatus$[ebp], -1073741670 ; c000009aH

; 69   :             goto Exit_GetLocalHostInformation;            

  00049	e9 6c 01 00 00	 jmp	 $L10690
$L8828:

; 70   :         }
; 71   :         allocNewIrp = TRUE;

  0004e	c6 45 0b 01	 mov	 BYTE PTR _allocNewIrp$[ebp], 1
$L8825:
  00052	53		 push	 ebx

; 72   :     }
; 73   :     
; 74   :     pIrb = ExAllocatePool(NonPagedPool, sizeof(IRB));

  00053	68 57 64 6d 20	 push	 544040023		; 206d6457H
  00058	68 58 01 00 00	 push	 344			; 00000158H
  0005d	56		 push	 esi
  0005e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExAllocatePoolWithTag@12
  00064	8b d8		 mov	 ebx, eax

; 75   : 
; 76   :     if (!pIrb) {

  00066	3b de		 cmp	 ebx, esi
  00068	75 0c		 jne	 SHORT $L8832

; 77   : 
; 78   :         TRACE(TL_ERROR, ("Failed to allocate pIrb!\n"));
; 79   :         ntStatus = STATUS_INSUFFICIENT_RESOURCES;

  0006a	c7 45 fc 9a 00
	00 c0		 mov	 DWORD PTR _ntStatus$[ebp], -1073741670 ; c000009aH

; 80   :         goto Exit_GetLocalHostInformation;

  00071	e9 31 01 00 00	 jmp	 $Exit_GetLocalHostInformation$8830
$L8832:

; 81   :     } // if
; 82   : 
; 83   :     RtlZeroMemory (pIrb, sizeof (IRB));

  00076	6a 56		 push	 86			; 00000056H
  00078	33 c0		 xor	 eax, eax
  0007a	59		 pop	 ecx
  0007b	8b fb		 mov	 edi, ebx
  0007d	f3 ab		 rep stosd

; 84   :     pIrb->FunctionNumber = REQUEST_GET_LOCAL_HOST_INFO;
; 85   :     pIrb->Flags = 0;
; 86   :     pIrb->u.GetLocalHostInformation.nLevel = nLevel;

  0007f	8b 45 10	 mov	 eax, DWORD PTR _nLevel$[ebp]

; 87   : 
; 88   : 	if (nLevel == 7) {

  00082	83 f8 07	 cmp	 eax, 7
  00085	c7 03 13 00 00
	00		 mov	 DWORD PTR [ebx], 19	; 00000013H
  0008b	89 73 04	 mov	 DWORD PTR [ebx+4], esi
  0008e	89 43 48	 mov	 DWORD PTR [ebx+72], eax
  00091	75 0f		 jne	 SHORT $L8835

; 89   : 
; 90   :         // need to ensure that no one passed us an GET_LOCAL_HOST_INFO7 structure that just 
; 91   :         // piggy backed on the GET_LOCAL_HOST_INFORMATION struct, if they did this will cause
; 92   :         // data misalignment errors in 64 bit because 1394bus will be expecting that structure to
; 93   :         // be aligned correctly
; 94   :         RtlCopyMemory (&LocalHostInfo7, Information, sizeof (GET_LOCAL_HOST_INFO7));

  00093	8b 75 18	 mov	 esi, DWORD PTR _Information$[ebp]
  00096	8d 7d c8	 lea	 edi, DWORD PTR _LocalHostInfo7$[ebp]
  00099	a5		 movsd
  0009a	a5		 movsd
  0009b	a5		 movsd
  0009c	a5		 movsd

; 95   :         pIrb->u.GetLocalHostInformation.Information = &LocalHostInfo7;

  0009d	8d 45 c8	 lea	 eax, DWORD PTR _LocalHostInfo7$[ebp]

; 96   :     
; 97   :         TRACE(TL_TRACE, ("HostDmaCapabilities = 0x%p\n", LocalHostInfo7.HostDmaCapabilities));
; 98   :         TRACE(TL_TRACE, ("MaxDmaBufferSize High = 0x%x\n", LocalHostInfo7.MaxDmaBufferSize.HighPart));
; 99   : 		TRACE(TL_TRACE, ("MaxDmaBufferSize Low = 0x%x\n", LocalHostInfo7.MaxDmaBufferSize.LowPart));
; 100  : 
; 101  : 	}
; 102  : 	else if (nLevel == 6) {

  000a0	eb 1a		 jmp	 SHORT $L10692
$L8835:
  000a2	83 f8 06	 cmp	 eax, 6
  000a5	75 19		 jne	 SHORT $L8838

; 103  : 
; 104  : 		// in the case of nLevel = 6, we need to reset Information,
; 105  :     	// because we have a variable sized data buffer being passed in
; 106  :     	// from user mode.
; 107  : 
; 108  : 
; 109  :         RtlCopyMemory(&LocalHostInfo6, Information, sizeof (GET_LOCAL_HOST_INFO6));

  000a7	8b 45 18	 mov	 eax, DWORD PTR _Information$[ebp]
  000aa	8b f0		 mov	 esi, eax
  000ac	8d 7d d8	 lea	 edi, DWORD PTR _LocalHostInfo6$[ebp]
  000af	a5		 movsd
  000b0	a5		 movsd
  000b1	a5		 movsd

; 110  :         LocalHostInfo6.CsrDataBuffer = &((PGET_LOCAL_HOST_INFO6)Information)->CsrDataBuffer;

  000b2	83 c0 0c	 add	 eax, 12			; 0000000cH
  000b5	a5		 movsd
  000b6	89 45 e4	 mov	 DWORD PTR _LocalHostInfo6$[ebp+12], eax

; 111  : 
; 112  : #ifdef _WIN64
; 113  :         // need to special case this in 64 bit because data padding causes an off by 1 error
; 114  :         // since pointers are 64 bits, there is a 32 bit space between the CsrDataLength and CsrDataBuffer
; 115  :         (PCHAR)LocalHostInfo6.CsrDataBuffer -= sizeof (ULONG);       
; 116  : #endif
; 117  : 
; 118  :         pIrb->u.GetLocalHostInformation.Information = &LocalHostInfo6;

  000b9	8d 45 d8	 lea	 eax, DWORD PTR _LocalHostInfo6$[ebp]
$L10692:

; 119  : 
; 120  :         TRACE(TL_TRACE, ("CsrBaseAddress.Off_High = 0x%x\n", LocalHostInfo6.CsrBaseAddress.Off_High));
; 121  :         TRACE(TL_TRACE, ("CsrBaseAddress.Off_Low = 0x%x\n", LocalHostInfo6.CsrBaseAddress.Off_Low));
; 122  :         TRACE(TL_TRACE, ("CsrDataLength = 0x%x\n", LocalHostInfo6.CsrDataLength));
; 123  :         TRACE(TL_TRACE, ("CsrDataBuffer = 0x%p\n", LocalHostInfo6.CsrDataBuffer));
; 124  :     }
; 125  :     else if (nLevel == 5)

  000bc	33 f6		 xor	 esi, esi
  000be	eb 16		 jmp	 SHORT $L10691
$L8838:
  000c0	83 f8 05	 cmp	 eax, 5

; 126  :     {
; 127  :         // need to ensure that no one passed us an GET_LOCAL_HOST_INFO5 structure that just 
; 128  :         // piggy backed on the GET_LOCAL_HOST_INFORMATION struct, if they did this will cause
; 129  :         // data misalignment errors in 64 bit because 1394bus will be expecting that structure to
; 130  :         // be aligned correctly
; 131  :         RtlCopyMemory (&LocalHostInfo5, Information, sizeof (GET_LOCAL_HOST_INFO5));

  000c3	8b 45 18	 mov	 eax, DWORD PTR _Information$[ebp]
  000c6	75 0e		 jne	 SHORT $L10691
  000c8	8b 08		 mov	 ecx, DWORD PTR [eax]
  000ca	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000cd	89 45 f4	 mov	 DWORD PTR _LocalHostInfo5$[ebp+4], eax
  000d0	89 4d f0	 mov	 DWORD PTR _LocalHostInfo5$[ebp], ecx

; 132  :         pIrb->u.GetLocalHostInformation.Information = &LocalHostInfo5;

  000d3	8d 45 f0	 lea	 eax, DWORD PTR _LocalHostInfo5$[ebp]
$L10691:

; 133  :     
; 134  :         TRACE(TL_TRACE, ("ConfigRom = 0x%p\n", LocalHostInfo5.ConfigRom));
; 135  :         TRACE(TL_TRACE, ("ConfigRomLength = 0x%x\n", LocalHostInfo5.ConfigRomLength));
; 136  :     }   
; 137  :     else {
; 138  : 
; 139  :         pIrb->u.GetLocalHostInformation.Information = Information;
; 140  :     }
; 141  : 
; 142  :     //
; 143  :     // If we allocated this irp, submit it asynchronously and wait for its
; 144  :     // completion event to be signaled.  Otherwise submit it synchronously
; 145  :     //
; 146  :     if (allocNewIrp) {

  000d6	80 7d 0b 00	 cmp	 BYTE PTR _allocNewIrp$[ebp], 0
  000da	89 43 4c	 mov	 DWORD PTR [ebx+76], eax
  000dd	74 37		 je	 SHORT $L8845

; 147  : 
; 148  :         KeInitializeEvent (&Event, NotificationEvent, FALSE);

  000df	56		 push	 esi
  000e0	56		 push	 esi
  000e1	8d 45 b8	 lea	 eax, DWORD PTR _Event$[ebp]
  000e4	50		 push	 eax
  000e5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeInitializeEvent@12

; 149  :         ntStatus = t1394_SubmitIrpAsync (deviceExtension->StackDeviceObject, newIrp, pIrb);

  000eb	8b 45 fc	 mov	 eax, DWORD PTR _deviceExtension$[ebp]
  000ee	53		 push	 ebx
  000ef	ff 75 f8	 push	 DWORD PTR _newIrp$[ebp]
  000f2	ff 30		 push	 DWORD PTR [eax]
  000f4	e8 00 00 00 00	 call	 _t1394_SubmitIrpAsync@12

; 150  : 
; 151  :         if (ntStatus == STATUS_PENDING) {

  000f9	3d 03 01 00 00	 cmp	 eax, 259		; 00000103H
  000fe	89 45 fc	 mov	 DWORD PTR _ntStatus$[ebp], eax
  00101	75 24		 jne	 SHORT $L8849

; 152  :             KeWaitForSingleObject (&Event, Executive, KernelMode, FALSE, NULL); 

  00103	56		 push	 esi
  00104	56		 push	 esi
  00105	56		 push	 esi
  00106	56		 push	 esi
  00107	8d 45 b8	 lea	 eax, DWORD PTR _Event$[ebp]
  0010a	50		 push	 eax
  0010b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeWaitForSingleObject@20

; 153  :             ntStatus = ioStatus.Status;

  00111	8b 45 e8	 mov	 eax, DWORD PTR _ioStatus$[ebp]

; 154  :         }
; 155  :     }
; 156  :     else {

  00114	eb 0e		 jmp	 SHORT $L10693
$L8845:

; 157  :     
; 158  :         ntStatus = t1394_SubmitIrpSynch(deviceExtension->StackDeviceObject, Irp, pIrb);

  00116	8b 45 fc	 mov	 eax, DWORD PTR _deviceExtension$[ebp]
  00119	53		 push	 ebx
  0011a	ff 75 0c	 push	 DWORD PTR _Irp$[ebp]
  0011d	ff 30		 push	 DWORD PTR [eax]
  0011f	e8 00 00 00 00	 call	 _t1394_SubmitIrpSynch@12
$L10693:
  00124	89 45 fc	 mov	 DWORD PTR _ntStatus$[ebp], eax
$L8849:

; 159  :     }
; 160  :     
; 161  :     if (!NT_SUCCESS(ntStatus)) {

  00127	39 75 fc	 cmp	 DWORD PTR _ntStatus$[ebp], esi
  0012a	7d 3c		 jge	 SHORT $L8851

; 162  : 
; 163  :         if (ntStatus == STATUS_INVALID_BUFFER_SIZE) {

  0012c	81 7d fc 06 02
	00 c0		 cmp	 DWORD PTR _ntStatus$[ebp], -1073741306 ; c0000206H
  00133	75 68		 jne	 SHORT $L8887

; 164  : 
; 165  :             // we have to set status=success, otherwise, we don't get
; 166  :             // the size value passed up to ring 3.
; 167  :             ntStatus = STATUS_SUCCESS;
; 168  :             *UserStatus = 122;
; 169  : 
; 170  :             TRACE(TL_WARNING, ("Invalid Buffer Size. nLevel = 0x%x\n", nLevel));
; 171  : 
; 172  :             // see if it's a config rom request or a csr request
; 173  :             if (nLevel == 5) {

  00135	83 7d 10 05	 cmp	 DWORD PTR _nLevel$[ebp], 5
  00139	8b 45 14	 mov	 eax, DWORD PTR _UserStatus$[ebp]
  0013c	89 75 fc	 mov	 DWORD PTR _ntStatus$[ebp], esi
  0013f	c7 00 7a 00 00
	00		 mov	 DWORD PTR [eax], 122	; 0000007aH
  00145	75 10		 jne	 SHORT $L8855

; 174  : 
; 175  :                 // it is, lets print out the size                
; 176  :                 TRACE(TL_TRACE, ("ConfigRomLength = 0x%x\n", LocalHostInfo5.ConfigRomLength));
; 177  : 
; 178  :                 // neet to set this in the information struct we were passed down
; 179  :                 RtlCopyMemory(Information, &LocalHostInfo5, sizeof (GET_LOCAL_HOST_INFO5));

  00147	8b 4d f0	 mov	 ecx, DWORD PTR _LocalHostInfo5$[ebp]
  0014a	8b 45 18	 mov	 eax, DWORD PTR _Information$[ebp]
  0014d	89 08		 mov	 DWORD PTR [eax], ecx
  0014f	8b 4d f4	 mov	 ecx, DWORD PTR _LocalHostInfo5$[ebp+4]
  00152	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 180  :             }
; 181  :             else if (nLevel == 6) {

  00155	eb 46		 jmp	 SHORT $L8887
$L8855:
  00157	83 7d 10 06	 cmp	 DWORD PTR _nLevel$[ebp], 6
  0015b	75 05		 jne	 SHORT $L8858

; 182  : 
; 183  :                 // csr, print out size
; 184  :                 TRACE(TL_TRACE, ("CsrDataLength needed = 0x%x\n", LocalHostInfo6.CsrDataLength));
; 185  : 
; 186  :                 // need to set this in the information struct we were passed down
; 187  :                 RtlCopyMemory(Information, &LocalHostInfo6, sizeof (GET_LOCAL_HOST_INFO6));

  0015d	8d 75 d8	 lea	 esi, DWORD PTR _LocalHostInfo6$[ebp]

; 188  :             }
; 189  : 			else if (nLevel == 7) {

  00160	eb 34		 jmp	 SHORT $L10694
$L8858:
  00162	83 7d 10 07	 cmp	 DWORD PTR _nLevel$[ebp], 7

; 190  : 
; 191  : 				// copy the results of the struct passed down
; 192  : 				RtlCopyMemory(Information, &LocalHostInfo7, sizeof (GET_LOCAL_HOST_INFO7));
; 193  : 			}
; 194  :         }
; 195  :         else {
; 196  : 
; 197  :             TRACE(TL_ERROR, ("SubmitIrpSync failed = 0x%x\n", ntStatus));
; 198  :         }
; 199  :     }
; 200  :     else {

  00166	eb 29		 jmp	 SHORT $L10695
$L8851:

; 201  : 
; 202  :         *UserStatus = 0;

  00168	8b 45 14	 mov	 eax, DWORD PTR _UserStatus$[ebp]
  0016b	89 30		 mov	 DWORD PTR [eax], esi

; 203  : 
; 204  :         if (nLevel == 1) {

  0016d	8b 45 10	 mov	 eax, DWORD PTR _nLevel$[ebp]
  00170	83 f8 01	 cmp	 eax, 1
  00173	74 28		 je	 SHORT $L8887

; 205  : 
; 206  :             PGET_LOCAL_HOST_INFO1   LocalHostInfo1;
; 207  : 
; 208  :             LocalHostInfo1 = (PGET_LOCAL_HOST_INFO1)Information;
; 209  : 
; 210  :             TRACE(TL_TRACE, ("UniqueId.LowPart = 0x%x\n", LocalHostInfo1->UniqueId.LowPart));
; 211  :             TRACE(TL_TRACE, ("UniqueId.HighPart = 0x%x\n", LocalHostInfo1->UniqueId.HighPart));
; 212  :         }
; 213  :         else if (nLevel == 2) {

  00175	83 f8 02	 cmp	 eax, 2
  00178	74 23		 je	 SHORT $L8887

; 214  : 
; 215  :             PGET_LOCAL_HOST_INFO2   LocalHostInfo2;
; 216  : 
; 217  :             LocalHostInfo2 = (PGET_LOCAL_HOST_INFO2)Information;
; 218  : 
; 219  :             TRACE(TL_TRACE, ("HostCapabilities = 0x%x\n", LocalHostInfo2->HostCapabilities));
; 220  :             TRACE(TL_TRACE, ("MaxAsyncReadRequest = 0x%x\n", LocalHostInfo2->MaxAsyncReadRequest));
; 221  :             TRACE(TL_TRACE, ("MaxAsyncWriteRequest = 0x%x\n", LocalHostInfo2->MaxAsyncWriteRequest));
; 222  :         }
; 223  :         else if (nLevel == 3) {

  0017a	83 f8 03	 cmp	 eax, 3
  0017d	74 1e		 je	 SHORT $L8887

; 224  : 
; 225  :             PGET_LOCAL_HOST_INFO3   LocalHostInfo3;
; 226  : 
; 227  :             LocalHostInfo3 = (PGET_LOCAL_HOST_INFO3)Information;
; 228  : 
; 229  :             TRACE(TL_TRACE, ("deciWattsSupplied = 0x%x\n", LocalHostInfo3->deciWattsSupplied));
; 230  :             TRACE(TL_TRACE, ("Voltage = 0x%x\n", LocalHostInfo3->Voltage));
; 231  :         }
; 232  :         else if (nLevel == 4) {

  0017f	83 f8 04	 cmp	 eax, 4
  00182	74 19		 je	 SHORT $L8887

; 233  : 
; 234  :             PGET_LOCAL_HOST_INFO4   LocalHostInfo4;
; 235  : 
; 236  :             LocalHostInfo4 = (PGET_LOCAL_HOST_INFO4)Information;
; 237  : 
; 238  :             TRACE(TL_TRACE, ("Context = 0x%x\n", LocalHostInfo4->Context));
; 239  :         }
; 240  :         else if (nLevel == 5) {

  00184	83 f8 05	 cmp	 eax, 5
  00187	74 14		 je	 SHORT $L8887

; 241  : 
; 242  :             PGET_LOCAL_HOST_INFO5   pLocalHostInfo5;
; 243  : 
; 244  :             pLocalHostInfo5 = (PGET_LOCAL_HOST_INFO5)Information;
; 245  : 
; 246  :             TRACE(TL_TRACE, ("ConfigRomLength = 0x%x\n", pLocalHostInfo5->ConfigRomLength));
; 247  : 
; 248  :             // IDEAIDEA: add some debug spew for whatever we are getting...
; 249  :         }
; 250  :         else if (nLevel == 6) {

  00189	83 f8 06	 cmp	 eax, 6
  0018c	74 0f		 je	 SHORT $L8887

; 251  : 
; 252  :             // IDEAIDEA: add some debug spew for whatever we are getting...
; 253  : 
; 254  :         }
; 255  : 		else if (nLevel == 7) {

  0018e	83 f8 07	 cmp	 eax, 7
$L10695:
  00191	75 0a		 jne	 SHORT $L8887

; 256  : 
; 257  : 			// need to copy the results back into the original address space passed in
; 258  : 			TRACE(TL_TRACE, ("HostDmaCapabilities = 0x%x\n", LocalHostInfo7.HostDmaCapabilities));
; 259  : 			TRACE(TL_TRACE, ("MaxDmaBufferSize Low = 0x%x\n", LocalHostInfo7.MaxDmaBufferSize.LowPart));
; 260  : 			TRACE(TL_TRACE, ("MaxDmaBufferSize High = 0x%x\n", LocalHostInfo7.MaxDmaBufferSize.HighPart));
; 261  : 			RtlCopyMemory(Information, &LocalHostInfo7, sizeof (GET_LOCAL_HOST_INFO7));

  00193	8d 75 c8	 lea	 esi, DWORD PTR _LocalHostInfo7$[ebp]
$L10694:
  00196	8b 7d 18	 mov	 edi, DWORD PTR _Information$[ebp]
  00199	a5		 movsd
  0019a	a5		 movsd
  0019b	a5		 movsd
  0019c	a5		 movsd
$L8887:

; 262  : 		}
; 263  :         else {
; 264  : 
; 265  :             TRACE(TL_WARNING, ("Returned success on invalid nLevel = 0x%x\n", nLevel));
; 266  :         }
; 267  :     }
; 268  : 
; 269  :     if (pIrb)
; 270  :         ExFreePool(pIrb);

  0019d	53		 push	 ebx
  0019e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePool@4
  001a4	8b 7d 0c	 mov	 edi, DWORD PTR _Irp$[ebp]
$Exit_GetLocalHostInformation$8830:

; 271  : 
; 272  : Exit_GetLocalHostInformation:
; 273  : 
; 274  :     if (allocNewIrp) 

  001a7	80 7d 0b 00	 cmp	 BYTE PTR _allocNewIrp$[ebp], 0
  001ab	5b		 pop	 ebx
  001ac	74 0c		 je	 SHORT $L10690

; 275  :         Irp->IoStatus = ioStatus;

  001ae	8b 45 e8	 mov	 eax, DWORD PTR _ioStatus$[ebp]
  001b1	89 47 18	 mov	 DWORD PTR [edi+24], eax
  001b4	8b 45 ec	 mov	 eax, DWORD PTR _ioStatus$[ebp+4]
  001b7	89 47 1c	 mov	 DWORD PTR [edi+28], eax
$L10690:

; 276  :         
; 277  :     EXIT("t1394_GetLocalHostInformation", ntStatus);
; 278  :     return(ntStatus);

  001ba	8b 45 fc	 mov	 eax, DWORD PTR _ntStatus$[ebp]
  001bd	5f		 pop	 edi
  001be	5e		 pop	 esi

; 279  : } // t1394_GetLocalHostInformation

  001bf	c9		 leave
  001c0	c2 14 00	 ret	 20			; 00000014H
_t1394_GetLocalHostInformation@20 ENDP
_TEXT	ENDS
PUBLIC	_t1394_Get1394AddressFromDeviceObject@16
; Function compile flags: /Ogsy
;	COMDAT _t1394_Get1394AddressFromDeviceObject@16
_TEXT	SEGMENT
_Event$ = -28						; size = 16
_ioStatus$ = -12					; size = 8
_newIrp$ = -4						; size = 4
_DeviceObject$ = 8					; size = 4
_allocNewIrp$ = 11					; size = 1
_Irp$ = 12						; size = 4
_fulFlags$ = 16						; size = 4
_pNodeAddress$ = 20					; size = 4
_t1394_Get1394AddressFromDeviceObject@16 PROC NEAR	; COMDAT

; 288  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH

; 289  :     NTSTATUS            ntStatus = STATUS_SUCCESS;
; 290  :     PDEVICE_EXTENSION   deviceExtension = DeviceObject->DeviceExtension;

  00006	8b 45 08	 mov	 eax, DWORD PTR _DeviceObject$[ebp]
  00009	56		 push	 esi
  0000a	8b 70 28	 mov	 esi, DWORD PTR [eax+40]

; 291  :     PIRB                pIrb;
; 292  : 
; 293  :     PIRP                newIrp;
; 294  :     BOOLEAN             allocNewIrp = FALSE;
; 295  :     KEVENT              Event;
; 296  :     IO_STATUS_BLOCK     ioStatus;
; 297  :     
; 298  :     ENTER("t1394_Get1394AddressFromDeviceObject");
; 299  : 
; 300  :     TRACE(TL_TRACE, ("fulFlags = 0x%x\n", fulFlags));
; 301  : 
; 302  :     //
; 303  :     // If this is a UserMode request create a newIrp so that the request
; 304  :     // will be issued from KernelMode
; 305  :     //
; 306  :     if (Irp->RequestorMode == UserMode) {

  0000d	8b 45 0c	 mov	 eax, DWORD PTR _Irp$[ebp]
  00010	57		 push	 edi

; 307  : 
; 308  :         newIrp = IoBuildDeviceIoControlRequest (IOCTL_1394_CLASS, deviceExtension->StackDeviceObject, 
; 309  :                             NULL, 0, NULL, 0, TRUE, &Event, &ioStatus);

  00011	33 ff		 xor	 edi, edi
  00013	80 78 20 01	 cmp	 BYTE PTR [eax+32], 1
  00017	c6 45 0b 00	 mov	 BYTE PTR _allocNewIrp$[ebp], 0
  0001b	75 30		 jne	 SHORT $L8909
  0001d	8d 45 f4	 lea	 eax, DWORD PTR _ioStatus$[ebp]
  00020	50		 push	 eax
  00021	8d 45 e4	 lea	 eax, DWORD PTR _Event$[ebp]
  00024	50		 push	 eax
  00025	6a 01		 push	 1
  00027	57		 push	 edi
  00028	57		 push	 edi
  00029	57		 push	 edi
  0002a	57		 push	 edi
  0002b	ff 36		 push	 DWORD PTR [esi]
  0002d	68 1d 02 22 00	 push	 2228765			; 0022021dH
  00032	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoBuildDeviceIoControlRequest@36

; 310  : 
; 311  :         if (!newIrp) {

  00038	3b c7		 cmp	 eax, edi
  0003a	89 45 fc	 mov	 DWORD PTR _newIrp$[ebp], eax
  0003d	75 0a		 jne	 SHORT $L8912

; 312  : 
; 313  :             TRACE(TL_ERROR, ("Failed to allocate newIrp!\n"));       
; 314  :             ntStatus = STATUS_INSUFFICIENT_RESOURCES;

  0003f	be 9a 00 00 c0	 mov	 esi, -1073741670	; c000009aH

; 315  :             goto Exit_Get1394AddressFromDeviceObject;            

  00044	e9 af 00 00 00	 jmp	 $L8927
$L8912:

; 316  :         }
; 317  :         allocNewIrp = TRUE;

  00049	c6 45 0b 01	 mov	 BYTE PTR _allocNewIrp$[ebp], 1
$L8909:
  0004d	53		 push	 ebx

; 318  :     }
; 319  :     
; 320  :     pIrb = ExAllocatePool(NonPagedPool, sizeof(IRB));

  0004e	68 57 64 6d 20	 push	 544040023		; 206d6457H
  00053	68 58 01 00 00	 push	 344			; 00000158H
  00058	57		 push	 edi
  00059	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExAllocatePoolWithTag@12
  0005f	8b d8		 mov	 ebx, eax

; 321  : 
; 322  :     if (!pIrb) {

  00061	3b df		 cmp	 ebx, edi
  00063	75 07		 jne	 SHORT $L8916

; 323  : 
; 324  :         TRACE(TL_ERROR, ("Failed to allocate pIrb!\n"));
; 325  :         ntStatus = STATUS_INSUFFICIENT_RESOURCES;

  00065	be 9a 00 00 c0	 mov	 esi, -1073741670	; c000009aH

; 326  :         goto Exit_Get1394AddressFromDeviceObject;

  0006a	eb 76		 jmp	 SHORT $Exit_Get1394AddressFromDeviceObject$8914
$L8916:

; 327  :     } // if
; 328  : 
; 329  :     RtlZeroMemory (pIrb, sizeof (IRB));

  0006c	6a 56		 push	 86			; 00000056H
  0006e	33 c0		 xor	 eax, eax
  00070	59		 pop	 ecx
  00071	8b fb		 mov	 edi, ebx
  00073	f3 ab		 rep stosd

; 330  :     pIrb->FunctionNumber = REQUEST_GET_ADDR_FROM_DEVICE_OBJECT;
; 331  :     pIrb->Flags = 0;
; 332  :     pIrb->u.Get1394AddressFromDeviceObject.fulFlags = fulFlags;

  00075	8b 45 10	 mov	 eax, DWORD PTR _fulFlags$[ebp]
  00078	33 ff		 xor	 edi, edi

; 333  : 
; 334  :     //
; 335  :     // If we allocated this irp, submit it asynchronously and wait for its
; 336  :     // completion event to be signaled.  Otherwise submit it synchronously
; 337  :     //
; 338  :     if (allocNewIrp) {

  0007a	80 7d 0b 00	 cmp	 BYTE PTR _allocNewIrp$[ebp], 0
  0007e	c7 03 14 00 00
	00		 mov	 DWORD PTR [ebx], 20	; 00000014H
  00084	89 7b 04	 mov	 DWORD PTR [ebx+4], edi
  00087	89 43 48	 mov	 DWORD PTR [ebx+72], eax
  0008a	74 34		 je	 SHORT $L8919

; 339  : 
; 340  :         KeInitializeEvent (&Event, NotificationEvent, FALSE);

  0008c	57		 push	 edi
  0008d	57		 push	 edi
  0008e	8d 45 e4	 lea	 eax, DWORD PTR _Event$[ebp]
  00091	50		 push	 eax
  00092	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeInitializeEvent@12

; 341  :         ntStatus = t1394_SubmitIrpAsync (deviceExtension->StackDeviceObject, newIrp, pIrb);

  00098	53		 push	 ebx
  00099	ff 75 fc	 push	 DWORD PTR _newIrp$[ebp]
  0009c	ff 36		 push	 DWORD PTR [esi]
  0009e	e8 00 00 00 00	 call	 _t1394_SubmitIrpAsync@12
  000a3	8b f0		 mov	 esi, eax

; 342  : 
; 343  :         if (ntStatus == STATUS_PENDING) {

  000a5	81 fe 03 01 00
	00		 cmp	 esi, 259		; 00000103H
  000ab	75 20		 jne	 SHORT $L8923

; 344  :             KeWaitForSingleObject (&Event, Executive, KernelMode, FALSE, NULL); 

  000ad	57		 push	 edi
  000ae	57		 push	 edi
  000af	57		 push	 edi
  000b0	57		 push	 edi
  000b1	8d 45 e4	 lea	 eax, DWORD PTR _Event$[ebp]
  000b4	50		 push	 eax
  000b5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeWaitForSingleObject@20

; 345  :             ntStatus = ioStatus.Status;

  000bb	8b 75 f4	 mov	 esi, DWORD PTR _ioStatus$[ebp]

; 346  :         }
; 347  :     }
; 348  :     else {

  000be	eb 0d		 jmp	 SHORT $L8923
$L8919:

; 349  :         ntStatus = t1394_SubmitIrpSynch(deviceExtension->StackDeviceObject, Irp, pIrb);

  000c0	53		 push	 ebx
  000c1	ff 75 0c	 push	 DWORD PTR _Irp$[ebp]
  000c4	ff 36		 push	 DWORD PTR [esi]
  000c6	e8 00 00 00 00	 call	 _t1394_SubmitIrpSynch@12
  000cb	8b f0		 mov	 esi, eax
$L8923:

; 350  :     }
; 351  :     
; 352  :     if (NT_SUCCESS(ntStatus)) {

  000cd	3b f7		 cmp	 esi, edi
  000cf	7c 0a		 jl	 SHORT $L8925

; 353  : 
; 354  :         *pNodeAddress = pIrb->u.Get1394AddressFromDeviceObject.NodeAddress;

  000d1	66 8b 43 4c	 mov	 ax, WORD PTR [ebx+76]
  000d5	8b 4d 14	 mov	 ecx, DWORD PTR _pNodeAddress$[ebp]
  000d8	66 89 01	 mov	 WORD PTR [ecx], ax
$L8925:

; 355  : 
; 356  :         TRACE(TL_TRACE, ("NodeAddres.NA_Node_Number = 0x%x\n", pNodeAddress->NA_Node_Number));
; 357  :         TRACE(TL_TRACE, ("NodeAddres.NA_Bus_Number = 0x%x\n", pNodeAddress->NA_Bus_Number));
; 358  :     }
; 359  :     else {
; 360  : 
; 361  :         TRACE(TL_ERROR, ("SubmitIrpSync failed = 0x%x\n", ntStatus));
; 362  :     }
; 363  : 
; 364  :     ExFreePool(pIrb);

  000db	53		 push	 ebx
  000dc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePool@4
$Exit_Get1394AddressFromDeviceObject$8914:

; 365  : 
; 366  : Exit_Get1394AddressFromDeviceObject:
; 367  : 
; 368  :     if (allocNewIrp) 

  000e2	80 7d 0b 00	 cmp	 BYTE PTR _allocNewIrp$[ebp], 0
  000e6	5b		 pop	 ebx
  000e7	74 0f		 je	 SHORT $L8927

; 369  :         Irp->IoStatus = ioStatus;

  000e9	8b 4d f4	 mov	 ecx, DWORD PTR _ioStatus$[ebp]
  000ec	8b 45 0c	 mov	 eax, DWORD PTR _Irp$[ebp]
  000ef	89 48 18	 mov	 DWORD PTR [eax+24], ecx
  000f2	8b 4d f8	 mov	 ecx, DWORD PTR _ioStatus$[ebp+4]
  000f5	89 48 1c	 mov	 DWORD PTR [eax+28], ecx
$L8927:
  000f8	5f		 pop	 edi

; 370  :         
; 371  :     EXIT("t1394_Get1394AddressFromDeviceObject", ntStatus);
; 372  :     return(ntStatus);

  000f9	8b c6		 mov	 eax, esi
  000fb	5e		 pop	 esi

; 373  : } // t1394_Get1394AddressFromDeviceObject

  000fc	c9		 leave
  000fd	c2 10 00	 ret	 16			; 00000010H
_t1394_Get1394AddressFromDeviceObject@16 ENDP
_TEXT	ENDS
PUBLIC	_t1394_GetMaxSpeedBetweenDevices@24
; Function compile flags: /Ogsy
;	COMDAT _t1394_GetMaxSpeedBetweenDevices@24
_TEXT	SEGMENT
_Event$ = -28						; size = 16
_ioStatus$ = -12					; size = 8
_newIrp$ = -4						; size = 4
_DeviceObject$ = 8					; size = 4
_allocNewIrp$ = 11					; size = 1
_Irp$ = 12						; size = 4
_fulFlags$ = 16						; size = 4
_ulNumberOfDestinations$ = 20				; size = 4
_hDestinationDeviceObjects$ = 24			; size = 4
_fulSpeed$ = 28						; size = 4
_t1394_GetMaxSpeedBetweenDevices@24 PROC NEAR		; COMDAT

; 401  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH

; 402  :     NTSTATUS            ntStatus = STATUS_SUCCESS;
; 403  :     PDEVICE_EXTENSION   deviceExtension = DeviceObject->DeviceExtension;

  00006	8b 45 08	 mov	 eax, DWORD PTR _DeviceObject$[ebp]
  00009	53		 push	 ebx
  0000a	8b 58 28	 mov	 ebx, DWORD PTR [eax+40]

; 404  :     PIRB                pIrb;
; 405  :     ULONG               i;
; 406  : 
; 407  :     PIRP                newIrp;
; 408  :     BOOLEAN             allocNewIrp = FALSE;
; 409  :     KEVENT              Event;
; 410  :     IO_STATUS_BLOCK     ioStatus;
; 411  :     
; 412  :     ENTER("t1394_GetMaxSpeedBetweenDevices");
; 413  : 
; 414  :     TRACE(TL_TRACE, ("DeviceObject = 0x%x\n", DeviceObject));
; 415  :     TRACE(TL_TRACE, ("Irp = 0x%x\n", Irp));
; 416  :     TRACE(TL_TRACE, ("fulFlags = 0x%x\n", fulFlags));
; 417  :     TRACE(TL_TRACE, ("ulNumberOfDestinations = 0x%x\n", ulNumberOfDestinations));
; 418  : 
; 419  :     for (i=0; i<ulNumberOfDestinations; i++) {
; 420  : 
; 421  :         TRACE(TL_TRACE, ("hDestinationDeviceObjects[%d] = 0x%x\n", i, hDestinationDeviceObjects[i]));
; 422  :     }
; 423  : 
; 424  :     //
; 425  :     // If this is a UserMode request create a newIrp so that the request
; 426  :     // will be issued from KernelMode
; 427  :     //
; 428  :     if (Irp->RequestorMode == UserMode) {

  0000d	8b 45 0c	 mov	 eax, DWORD PTR _Irp$[ebp]
  00010	57		 push	 edi

; 429  : 
; 430  :         newIrp = IoBuildDeviceIoControlRequest (IOCTL_1394_CLASS, deviceExtension->StackDeviceObject, 
; 431  :                             NULL, 0, NULL, 0, TRUE, &Event, &ioStatus);

  00011	33 ff		 xor	 edi, edi
  00013	80 78 20 01	 cmp	 BYTE PTR [eax+32], 1
  00017	c6 45 0b 00	 mov	 BYTE PTR _allocNewIrp$[ebp], 0
  0001b	75 30		 jne	 SHORT $L8962
  0001d	8d 45 f4	 lea	 eax, DWORD PTR _ioStatus$[ebp]
  00020	50		 push	 eax
  00021	8d 45 e4	 lea	 eax, DWORD PTR _Event$[ebp]
  00024	50		 push	 eax
  00025	6a 01		 push	 1
  00027	57		 push	 edi
  00028	57		 push	 edi
  00029	57		 push	 edi
  0002a	57		 push	 edi
  0002b	ff 33		 push	 DWORD PTR [ebx]
  0002d	68 1d 02 22 00	 push	 2228765			; 0022021dH
  00032	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoBuildDeviceIoControlRequest@36

; 432  : 
; 433  :         if (!newIrp) {

  00038	3b c7		 cmp	 eax, edi
  0003a	89 45 fc	 mov	 DWORD PTR _newIrp$[ebp], eax
  0003d	75 0a		 jne	 SHORT $L8965

; 434  : 
; 435  :             TRACE(TL_ERROR, ("Failed to allocate newIrp!\n"));       
; 436  :             ntStatus = STATUS_INSUFFICIENT_RESOURCES;

  0003f	bb 9a 00 00 c0	 mov	 ebx, -1073741670	; c000009aH

; 437  :             goto Exit_GetMaxSpeedBetweenDevices;            

  00044	e9 d4 00 00 00	 jmp	 $L8984
$L8965:

; 438  :         }
; 439  :         allocNewIrp = TRUE;

  00049	c6 45 0b 01	 mov	 BYTE PTR _allocNewIrp$[ebp], 1
$L8962:
  0004d	56		 push	 esi

; 440  :     }
; 441  :     
; 442  :     pIrb = ExAllocatePool(NonPagedPool, sizeof(IRB));

  0004e	68 57 64 6d 20	 push	 544040023		; 206d6457H
  00053	68 58 01 00 00	 push	 344			; 00000158H
  00058	57		 push	 edi
  00059	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExAllocatePoolWithTag@12
  0005f	8b f0		 mov	 esi, eax

; 443  :     if (!pIrb) {

  00061	3b f7		 cmp	 esi, edi
  00063	75 0a		 jne	 SHORT $L8969

; 444  : 
; 445  :         TRACE(TL_ERROR, ("Failed to allocate pIrb!\n"));
; 446  :         ntStatus = STATUS_INSUFFICIENT_RESOURCES;

  00065	bb 9a 00 00 c0	 mov	 ebx, -1073741670	; c000009aH

; 447  :         goto Exit_GetMaxSpeedBetweenDevices;

  0006a	e9 98 00 00 00	 jmp	 $Exit_GetMaxSpeedBetweenDevices$8967
$L8969:

; 451  :     pIrb->FunctionNumber = REQUEST_GET_SPEED_BETWEEN_DEVICES;
; 452  :     pIrb->Flags = 0;
; 453  :     pIrb->u.GetMaxSpeedBetweenDevices.fulFlags = fulFlags;
; 454  :     pIrb->u.GetMaxSpeedBetweenDevices.ulNumberOfDestinations = ulNumberOfDestinations;

  0006f	8b 55 14	 mov	 edx, DWORD PTR _ulNumberOfDestinations$[ebp]
  00072	33 c0		 xor	 eax, eax
  00074	6a 56		 push	 86			; 00000056H
  00076	59		 pop	 ecx
  00077	8b fe		 mov	 edi, esi
  00079	f3 ab		 rep stosd
  0007b	8b 45 10	 mov	 eax, DWORD PTR _fulFlags$[ebp]
  0007e	33 ff		 xor	 edi, edi
  00080	89 46 48	 mov	 DWORD PTR [esi+72], eax

; 455  : 
; 456  :     for (i=0; i<ulNumberOfDestinations; i++) {

  00083	33 c0		 xor	 eax, eax
  00085	3b d7		 cmp	 edx, edi
  00087	c7 06 16 00 00
	00		 mov	 DWORD PTR [esi], 22	; 00000016H
  0008d	89 7e 04	 mov	 DWORD PTR [esi+4], edi
  00090	89 56 4c	 mov	 DWORD PTR [esi+76], edx
  00093	76 15		 jbe	 SHORT $L8974

; 448  :     } // if
; 449  : 
; 450  :     RtlZeroMemory (pIrb, sizeof (IRB));

  00095	8d 4e 50	 lea	 ecx, DWORD PTR [esi+80]
$L8972:

; 457  :     
; 458  :         pIrb->u.GetMaxSpeedBetweenDevices.hDestinationDeviceObjects[i] = hDestinationDeviceObjects[i];

  00098	8b 7d 18	 mov	 edi, DWORD PTR _hDestinationDeviceObjects$[ebp]
  0009b	8b 3c 87	 mov	 edi, DWORD PTR [edi+eax*4]
  0009e	89 39		 mov	 DWORD PTR [ecx], edi
  000a0	40		 inc	 eax
  000a1	83 c1 04	 add	 ecx, 4
  000a4	3b c2		 cmp	 eax, edx
  000a6	72 f0		 jb	 SHORT $L8972

; 455  : 
; 456  :     for (i=0; i<ulNumberOfDestinations; i++) {

  000a8	33 ff		 xor	 edi, edi
$L8974:

; 459  :     }
; 460  : 
; 461  :     //
; 462  :     // If we allocated this irp, submit it asynchronously and wait for its
; 463  :     // completion event to be signaled.  Otherwise submit it synchronously
; 464  :     //
; 465  :     if (allocNewIrp) {

  000aa	80 7d 0b 00	 cmp	 BYTE PTR _allocNewIrp$[ebp], 0
  000ae	74 34		 je	 SHORT $L8975

; 466  : 
; 467  :         KeInitializeEvent (&Event, NotificationEvent, FALSE);

  000b0	57		 push	 edi
  000b1	57		 push	 edi
  000b2	8d 45 e4	 lea	 eax, DWORD PTR _Event$[ebp]
  000b5	50		 push	 eax
  000b6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeInitializeEvent@12

; 468  :         ntStatus = t1394_SubmitIrpAsync (deviceExtension->StackDeviceObject, newIrp, pIrb);

  000bc	56		 push	 esi
  000bd	ff 75 fc	 push	 DWORD PTR _newIrp$[ebp]
  000c0	ff 33		 push	 DWORD PTR [ebx]
  000c2	e8 00 00 00 00	 call	 _t1394_SubmitIrpAsync@12
  000c7	8b d8		 mov	 ebx, eax

; 469  : 
; 470  :         if (ntStatus == STATUS_PENDING) {

  000c9	81 fb 03 01 00
	00		 cmp	 ebx, 259		; 00000103H
  000cf	75 20		 jne	 SHORT $L8979

; 471  :             KeWaitForSingleObject (&Event, Executive, KernelMode, FALSE, NULL); 

  000d1	57		 push	 edi
  000d2	57		 push	 edi
  000d3	57		 push	 edi
  000d4	57		 push	 edi
  000d5	8d 45 e4	 lea	 eax, DWORD PTR _Event$[ebp]
  000d8	50		 push	 eax
  000d9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeWaitForSingleObject@20

; 472  :             ntStatus = ioStatus.Status;

  000df	8b 5d f4	 mov	 ebx, DWORD PTR _ioStatus$[ebp]

; 473  :         }
; 474  :     }
; 475  :     else {

  000e2	eb 0d		 jmp	 SHORT $L8979
$L8975:

; 476  :         ntStatus = t1394_SubmitIrpSynch(deviceExtension->StackDeviceObject, Irp, pIrb);

  000e4	56		 push	 esi
  000e5	ff 75 0c	 push	 DWORD PTR _Irp$[ebp]
  000e8	ff 33		 push	 DWORD PTR [ebx]
  000ea	e8 00 00 00 00	 call	 _t1394_SubmitIrpSynch@12
  000ef	8b d8		 mov	 ebx, eax
$L8979:

; 477  :     }
; 478  :     
; 479  :     if (NT_SUCCESS(ntStatus)) {

  000f1	3b df		 cmp	 ebx, edi
  000f3	7c 0b		 jl	 SHORT $L8981

; 480  : 
; 481  :         *fulSpeed = pIrb->u.GetMaxSpeedBetweenDevices.fulSpeed;

  000f5	8b 86 50 01 00
	00		 mov	 eax, DWORD PTR [esi+336]
  000fb	8b 4d 1c	 mov	 ecx, DWORD PTR _fulSpeed$[ebp]
  000fe	89 01		 mov	 DWORD PTR [ecx], eax
$L8981:

; 482  : 
; 483  :         TRACE(TL_TRACE, ("fulSpeed = 0x%x\n", *fulSpeed));
; 484  :     }
; 485  :     else {
; 486  : 
; 487  :         TRACE(TL_ERROR, ("SubmitIrpSync failed = 0x%x\n", ntStatus));
; 488  :     }
; 489  : 
; 490  :     if (pIrb)
; 491  :         ExFreePool(pIrb);

  00100	56		 push	 esi
  00101	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePool@4
$Exit_GetMaxSpeedBetweenDevices$8967:

; 492  : 
; 493  : Exit_GetMaxSpeedBetweenDevices:
; 494  : 
; 495  :     if (allocNewIrp) 

  00107	80 7d 0b 00	 cmp	 BYTE PTR _allocNewIrp$[ebp], 0
  0010b	5e		 pop	 esi
  0010c	74 0f		 je	 SHORT $L8984

; 496  :         Irp->IoStatus = ioStatus;

  0010e	8b 4d f4	 mov	 ecx, DWORD PTR _ioStatus$[ebp]
  00111	8b 45 0c	 mov	 eax, DWORD PTR _Irp$[ebp]
  00114	89 48 18	 mov	 DWORD PTR [eax+24], ecx
  00117	8b 4d f8	 mov	 ecx, DWORD PTR _ioStatus$[ebp+4]
  0011a	89 48 1c	 mov	 DWORD PTR [eax+28], ecx
$L8984:
  0011d	5f		 pop	 edi

; 497  :         
; 498  :     EXIT("t1394_GetMaxSpeedBetweenDevices", ntStatus);
; 499  :     return(ntStatus);

  0011e	8b c3		 mov	 eax, ebx
  00120	5b		 pop	 ebx

; 500  : } // t1394_GetMaxSpeedBetweenDevices

  00121	c9		 leave
  00122	c2 18 00	 ret	 24			; 00000018H
_t1394_GetMaxSpeedBetweenDevices@24 ENDP
_TEXT	ENDS
PUBLIC	_t1394_SetDeviceXmitProperties@16
; Function compile flags: /Ogsy
;	COMDAT _t1394_SetDeviceXmitProperties@16
_TEXT	SEGMENT
_Event$ = -28						; size = 16
_ioStatus$ = -12					; size = 8
_newIrp$ = -4						; size = 4
_DeviceObject$ = 8					; size = 4
_allocNewIrp$ = 11					; size = 1
_Irp$ = 12						; size = 4
_fulSpeed$ = 16						; size = 4
_fulPriority$ = 20					; size = 4
_t1394_SetDeviceXmitProperties@16 PROC NEAR		; COMDAT

; 509  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH

; 510  :     NTSTATUS            ntStatus = STATUS_SUCCESS;
; 511  :     PDEVICE_EXTENSION   deviceExtension = DeviceObject->DeviceExtension;

  00006	8b 45 08	 mov	 eax, DWORD PTR _DeviceObject$[ebp]
  00009	53		 push	 ebx
  0000a	8b 58 28	 mov	 ebx, DWORD PTR [eax+40]

; 512  :     PIRB                pIrb;
; 513  : 
; 514  :     PIRP                newIrp;
; 515  :     BOOLEAN             allocNewIrp = FALSE;
; 516  :     KEVENT              Event;
; 517  :     IO_STATUS_BLOCK     ioStatus;
; 518  :     
; 519  :     ENTER("t1394_SetDeviceXmitProperties");
; 520  : 
; 521  :     TRACE(TL_TRACE, ("fulSpeed = 0x%x\n", fulSpeed));
; 522  :     TRACE(TL_TRACE, ("fulPriority = 0x%x\n", fulPriority));
; 523  : 
; 524  :     //
; 525  :     // If this is a UserMode request create a newIrp so that the request
; 526  :     // will be issued from KernelMode
; 527  :     //
; 528  :     if (Irp->RequestorMode == UserMode) {

  0000d	8b 45 0c	 mov	 eax, DWORD PTR _Irp$[ebp]
  00010	57		 push	 edi

; 529  : 
; 530  :         newIrp = IoBuildDeviceIoControlRequest (IOCTL_1394_CLASS, deviceExtension->StackDeviceObject, 
; 531  :                             NULL, 0, NULL, 0, TRUE, &Event, &ioStatus);

  00011	33 ff		 xor	 edi, edi
  00013	80 78 20 01	 cmp	 BYTE PTR [eax+32], 1
  00017	c6 45 0b 00	 mov	 BYTE PTR _allocNewIrp$[ebp], 0
  0001b	75 30		 jne	 SHORT $L9002
  0001d	8d 45 f4	 lea	 eax, DWORD PTR _ioStatus$[ebp]
  00020	50		 push	 eax
  00021	8d 45 e4	 lea	 eax, DWORD PTR _Event$[ebp]
  00024	50		 push	 eax
  00025	6a 01		 push	 1
  00027	57		 push	 edi
  00028	57		 push	 edi
  00029	57		 push	 edi
  0002a	57		 push	 edi
  0002b	ff 33		 push	 DWORD PTR [ebx]
  0002d	68 1d 02 22 00	 push	 2228765			; 0022021dH
  00032	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoBuildDeviceIoControlRequest@36

; 532  : 
; 533  :         if (!newIrp) {

  00038	3b c7		 cmp	 eax, edi
  0003a	89 45 fc	 mov	 DWORD PTR _newIrp$[ebp], eax
  0003d	75 0a		 jne	 SHORT $L9005

; 534  : 
; 535  :             TRACE(TL_ERROR, ("Failed to allocate newIrp!\n"));        
; 536  :             ntStatus = STATUS_INSUFFICIENT_RESOURCES;

  0003f	bb 9a 00 00 c0	 mov	 ebx, -1073741670	; c000009aH

; 537  :             goto Exit_SetDeviceXmitProperties;            

  00044	e9 a7 00 00 00	 jmp	 $L9019
$L9005:

; 538  :         }
; 539  :         allocNewIrp = TRUE;

  00049	c6 45 0b 01	 mov	 BYTE PTR _allocNewIrp$[ebp], 1
$L9002:
  0004d	56		 push	 esi

; 540  :     }
; 541  :     
; 542  :     pIrb = ExAllocatePool(NonPagedPool, sizeof(IRB));

  0004e	68 57 64 6d 20	 push	 544040023		; 206d6457H
  00053	68 58 01 00 00	 push	 344			; 00000158H
  00058	57		 push	 edi
  00059	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExAllocatePoolWithTag@12
  0005f	8b f0		 mov	 esi, eax

; 543  :     if (!pIrb) {

  00061	3b f7		 cmp	 esi, edi
  00063	75 07		 jne	 SHORT $L9009

; 544  : 
; 545  :         TRACE(TL_ERROR, ("Failed to allocate pIrb!\n"));
; 546  :         ntStatus = STATUS_INSUFFICIENT_RESOURCES;

  00065	bb 9a 00 00 c0	 mov	 ebx, -1073741670	; c000009aH

; 547  :         goto Exit_SetDeviceXmitProperties;

  0006a	eb 6e		 jmp	 SHORT $Exit_SetDeviceXmitProperties$9007
$L9009:

; 548  :     } // if
; 549  : 
; 550  :     RtlZeroMemory (pIrb, sizeof (IRB));

  0006c	33 c0		 xor	 eax, eax
  0006e	6a 56		 push	 86			; 00000056H
  00070	59		 pop	 ecx
  00071	8b fe		 mov	 edi, esi
  00073	f3 ab		 rep stosd

; 551  :     pIrb->FunctionNumber = REQUEST_SET_DEVICE_XMIT_PROPERTIES;
; 552  :     pIrb->Flags = 0;
; 553  :     pIrb->u.SetDeviceXmitProperties.fulSpeed = fulSpeed;

  00075	8b 45 10	 mov	 eax, DWORD PTR _fulSpeed$[ebp]
  00078	33 ff		 xor	 edi, edi

; 554  :     pIrb->u.SetDeviceXmitProperties.fulPriority = fulPriority;
; 555  : 
; 556  :     //
; 557  :     // If we allocated this irp, submit it asynchronously and wait for its
; 558  :     // completion event to be signaled.  Otherwise submit it synchronously
; 559  :     //
; 560  :     if (allocNewIrp) {

  0007a	80 7d 0b 00	 cmp	 BYTE PTR _allocNewIrp$[ebp], 0
  0007e	89 46 48	 mov	 DWORD PTR [esi+72], eax
  00081	8b 45 14	 mov	 eax, DWORD PTR _fulPriority$[ebp]
  00084	c7 06 17 00 00
	00		 mov	 DWORD PTR [esi], 23	; 00000017H
  0008a	89 7e 04	 mov	 DWORD PTR [esi+4], edi
  0008d	89 46 4c	 mov	 DWORD PTR [esi+76], eax
  00090	74 34		 je	 SHORT $L9012

; 561  : 
; 562  :         KeInitializeEvent (&Event, NotificationEvent, FALSE);

  00092	57		 push	 edi
  00093	57		 push	 edi
  00094	8d 45 e4	 lea	 eax, DWORD PTR _Event$[ebp]
  00097	50		 push	 eax
  00098	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeInitializeEvent@12

; 563  :         ntStatus = t1394_SubmitIrpAsync (deviceExtension->StackDeviceObject, newIrp, pIrb);

  0009e	56		 push	 esi
  0009f	ff 75 fc	 push	 DWORD PTR _newIrp$[ebp]
  000a2	ff 33		 push	 DWORD PTR [ebx]
  000a4	e8 00 00 00 00	 call	 _t1394_SubmitIrpAsync@12
  000a9	8b d8		 mov	 ebx, eax

; 564  : 
; 565  :         if (ntStatus == STATUS_PENDING) {

  000ab	81 fb 03 01 00
	00		 cmp	 ebx, 259		; 00000103H
  000b1	75 20		 jne	 SHORT $L9016

; 566  :             KeWaitForSingleObject (&Event, Executive, KernelMode, FALSE, NULL); 

  000b3	57		 push	 edi
  000b4	57		 push	 edi
  000b5	57		 push	 edi
  000b6	57		 push	 edi
  000b7	8d 45 e4	 lea	 eax, DWORD PTR _Event$[ebp]
  000ba	50		 push	 eax
  000bb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeWaitForSingleObject@20

; 567  :             ntStatus = ioStatus.Status;

  000c1	8b 5d f4	 mov	 ebx, DWORD PTR _ioStatus$[ebp]

; 568  :         }
; 569  :     }
; 570  :     else {

  000c4	eb 0d		 jmp	 SHORT $L9016
$L9012:

; 571  :         ntStatus = t1394_SubmitIrpSynch(deviceExtension->StackDeviceObject, Irp, pIrb);

  000c6	56		 push	 esi
  000c7	ff 75 0c	 push	 DWORD PTR _Irp$[ebp]
  000ca	ff 33		 push	 DWORD PTR [ebx]
  000cc	e8 00 00 00 00	 call	 _t1394_SubmitIrpSynch@12
  000d1	8b d8		 mov	 ebx, eax
$L9016:

; 572  :     }
; 573  :     
; 574  :     if (!NT_SUCCESS(ntStatus)) {
; 575  : 
; 576  :         TRACE(TL_ERROR, ("SubmitIrpSync failed = 0x%x\n", ntStatus));
; 577  :     }
; 578  : 
; 579  :     ExFreePool(pIrb);

  000d3	56		 push	 esi
  000d4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePool@4
$Exit_SetDeviceXmitProperties$9007:

; 580  : 
; 581  : Exit_SetDeviceXmitProperties:
; 582  : 
; 583  :     if (allocNewIrp) 

  000da	80 7d 0b 00	 cmp	 BYTE PTR _allocNewIrp$[ebp], 0
  000de	5e		 pop	 esi
  000df	74 0f		 je	 SHORT $L9019

; 584  :         Irp->IoStatus = ioStatus;

  000e1	8b 4d f4	 mov	 ecx, DWORD PTR _ioStatus$[ebp]
  000e4	8b 45 0c	 mov	 eax, DWORD PTR _Irp$[ebp]
  000e7	89 48 18	 mov	 DWORD PTR [eax+24], ecx
  000ea	8b 4d f8	 mov	 ecx, DWORD PTR _ioStatus$[ebp+4]
  000ed	89 48 1c	 mov	 DWORD PTR [eax+28], ecx
$L9019:
  000f0	5f		 pop	 edi

; 585  :         
; 586  :     EXIT("t1394_SetDeviceXmitProperties", ntStatus);
; 587  :     return(ntStatus);

  000f1	8b c3		 mov	 eax, ebx
  000f3	5b		 pop	 ebx

; 588  : } // t1394_SetDeviceXmitProperties

  000f4	c9		 leave
  000f5	c2 10 00	 ret	 16			; 00000010H
_t1394_SetDeviceXmitProperties@16 ENDP
_TEXT	ENDS
PUBLIC	_t1394_GetConfigurationInformation@8
; Function compile flags: /Ogsy
;	COMDAT _t1394_GetConfigurationInformation@8
_TEXT	SEGMENT
_DeviceObject$ = 8					; size = 4
_Irp$ = 12						; size = 4
_t1394_GetConfigurationInformation@8 PROC NEAR		; COMDAT

; 596  :     NTSTATUS            ntStatus = STATUS_SUCCESS;
; 597  :     PDEVICE_EXTENSION   deviceExtension = DeviceObject->DeviceExtension;
; 598  :     PIRB                pIrb;
; 599  : 
; 600  :     PIRP                newIrp;
; 601  :     BOOLEAN             allocNewIrp = FALSE;
; 602  :     KEVENT              Event;
; 603  :     IO_STATUS_BLOCK     ioStatus;
; 604  :     
; 605  :     ENTER("t1394_GetConfigurationInformation");
; 606  : /*
; 607  :         struct {
; 608  :             PCONFIG_ROM     ConfigRom;                          // Pointer to config rom
; 609  :             ULONG           UnitDirectoryBufferSize;
; 610  :             PVOID           UnitDirectory;                      // Pointer to unit directory
; 611  :             IO_ADDRESS      UnitDirectoryLocation;              // Starting Location of Unit Directory
; 612  :             ULONG           UnitDependentDirectoryBufferSize;
; 613  :             PVOID           UnitDependentDirectory;
; 614  :             IO_ADDRESS      UnitDependentDirectoryLocation;
; 615  :             ULONG           VendorLeafBufferSize;               // Size available to get vendor leafs
; 616  :             PTEXTUAL_LEAF   VendorLeaf;                         // Pointer to vendor leafs
; 617  :             ULONG           ModelLeafBufferSize;                // Size available to get model leafs
; 618  :             PTEXTUAL_LEAF   ModelLeaf;                          // Pointer to model leafs
; 619  :         } GetConfigurationInformation;
; 620  : */
; 621  :     return(STATUS_NOT_IMPLEMENTED);

  00000	b8 02 00 00 c0	 mov	 eax, -1073741822	; c0000002H

; 622  : 
; 623  :     //
; 624  :     // If this is a UserMode request create a newIrp so that the request
; 625  :     // will be issued from KernelMode
; 626  :     //
; 627  :     if (Irp->RequestorMode == UserMode) {
; 628  : 
; 629  :         newIrp = IoBuildDeviceIoControlRequest (IOCTL_1394_CLASS, deviceExtension->StackDeviceObject, 
; 630  :                             NULL, 0, NULL, 0, TRUE, &Event, &ioStatus);
; 631  : 
; 632  :         if (!newIrp) {
; 633  : 
; 634  :             TRACE(TL_ERROR, ("Failed to allocate newIrp!\n"));        
; 635  :             ntStatus = STATUS_INSUFFICIENT_RESOURCES;
; 636  :             goto Exit_GetConfigurationInformation;            
; 637  :         }
; 638  :         allocNewIrp = TRUE;
; 639  :     }
; 640  :     
; 641  :     pIrb = ExAllocatePool(NonPagedPool, sizeof(IRB));
; 642  :     if (!pIrb) {
; 643  : 
; 644  :         TRACE(TL_ERROR, ("Failed to allocate pIrb!\n"));
; 645  :         ntStatus = STATUS_INSUFFICIENT_RESOURCES;
; 646  :         goto Exit_GetConfigurationInformation;
; 647  :     } // if
; 648  : 
; 649  :     RtlZeroMemory (pIrb, sizeof (IRB));
; 650  :     pIrb->FunctionNumber = REQUEST_GET_CONFIGURATION_INFO;
; 651  :     pIrb->Flags = 0;
; 652  : 
; 653  :     //
; 654  :     // If we allocated this irp, submit it asynchronously and wait for its
; 655  :     // completion event to be signaled.  Otherwise submit it synchronously
; 656  :     //
; 657  :     if (allocNewIrp) {
; 658  : 
; 659  :         KeInitializeEvent (&Event, NotificationEvent, FALSE);
; 660  :         ntStatus = t1394_SubmitIrpAsync (deviceExtension->StackDeviceObject, newIrp, pIrb);
; 661  : 
; 662  :         if (ntStatus == STATUS_PENDING) {
; 663  :             KeWaitForSingleObject (&Event, Executive, KernelMode, FALSE, NULL); 
; 664  :             ntStatus = ioStatus.Status;
; 665  :         }
; 666  :     }
; 667  :     else {
; 668  :         ntStatus = t1394_SubmitIrpSynch(deviceExtension->StackDeviceObject, Irp, pIrb);
; 669  :     }
; 670  :     
; 671  :     if (NT_SUCCESS(ntStatus)) {
; 672  : 
; 673  :         TRACE(TL_TRACE, ("ConfigRom->CR_Info = 0x%x\n",
; 674  :             pIrb->u.GetConfigurationInformation.ConfigRom->CR_Info));
; 675  :         TRACE(TL_TRACE, ("ConfigRom->CR_Signiture = 0x%x\n",
; 676  :             pIrb->u.GetConfigurationInformation.ConfigRom->CR_Signiture));
; 677  :         TRACE(TL_TRACE, ("ConfigRom->CR_BusInfoBlockCaps = 0x%x\n",
; 678  :             pIrb->u.GetConfigurationInformation.ConfigRom->CR_BusInfoBlockCaps));
; 679  :         TRACE(TL_TRACE, ("ConfigRom->CR_Node_UniqueID[0] = 0x%x\n",
; 680  :             pIrb->u.GetConfigurationInformation.ConfigRom->CR_Node_UniqueID[0]));
; 681  :         TRACE(TL_TRACE, ("ConfigRom->CR_Node_UniqueID[1] = 0x%x\n",
; 682  :             pIrb->u.GetConfigurationInformation.ConfigRom->CR_Node_UniqueID[1]));
; 683  :         TRACE(TL_TRACE, ("ConfigRom->CR_Root_Info = 0x%x\n",
; 684  :             pIrb->u.GetConfigurationInformation.ConfigRom->CR_Root_Info));
; 685  : 
; 686  :         TRACE(TL_TRACE, ("UnitDirectoryBufferSize = 0x%x\n",
; 687  :             pIrb->u.GetConfigurationInformation.UnitDirectoryBufferSize));
; 688  :         TRACE(TL_TRACE, ("UnitDirectory = 0x%x\n", pIrb->u.GetConfigurationInformation.UnitDirectory));
; 689  :         TRACE(TL_TRACE, ("UnitDirectoryLocation.NA_Bus_Number = 0x%x\n",
; 690  :             pIrb->u.GetConfigurationInformation.UnitDirectoryLocation.IA_Destination_ID.NA_Bus_Number));
; 691  :         TRACE(TL_TRACE, ("UnitDirectoryLocation.NA_Node_Number = 0x%x\n",
; 692  :             pIrb->u.GetConfigurationInformation.UnitDirectoryLocation.IA_Destination_ID.NA_Node_Number));
; 693  :         TRACE(TL_TRACE, ("UnitDirectoryLocation.Off_High = 0x%x\n",
; 694  :             pIrb->u.GetConfigurationInformation.UnitDirectoryLocation.IA_Destination_Offset.Off_High));
; 695  :         TRACE(TL_TRACE, ("UnitDirectoryLocation.Off_Low = 0x%x\n",
; 696  :             pIrb->u.GetConfigurationInformation.UnitDirectoryLocation.IA_Destination_Offset.Off_Low));
; 697  : 
; 698  :         TRACE(TL_TRACE, ("UnitDependentDirectoryBufferSize = 0x%x\n",
; 699  :             pIrb->u.GetConfigurationInformation.UnitDependentDirectoryBufferSize));
; 700  :         TRACE(TL_TRACE, ("UnitDependentDirectory = 0x%x\n",
; 701  :             pIrb->u.GetConfigurationInformation.UnitDependentDirectory));
; 702  :         TRACE(TL_TRACE, ("UnitDependentDirectoryLocation.NA_Bus_Number = 0x%x\n",
; 703  :             pIrb->u.GetConfigurationInformation.UnitDependentDirectoryLocation.IA_Destination_ID.NA_Bus_Number));
; 704  :         TRACE(TL_TRACE, ("UnitDependentDirectoryLocation.NA_Node_Number = 0x%x\n",
; 705  :             pIrb->u.GetConfigurationInformation.UnitDependentDirectoryLocation.IA_Destination_ID.NA_Node_Number));
; 706  :         TRACE(TL_TRACE, ("UnitDependentDirectoryLocation.Off_High = 0x%x\n",
; 707  :             pIrb->u.GetConfigurationInformation.UnitDependentDirectoryLocation.IA_Destination_Offset.Off_High));
; 708  :         TRACE(TL_TRACE, ("UnitDependentDirectoryLocation.Off_Low = 0x%x\n",
; 709  :             pIrb->u.GetConfigurationInformation.UnitDependentDirectoryLocation.IA_Destination_Offset.Off_Low));
; 710  : 
; 711  :         TRACE(TL_TRACE, ("VendorLeafBufferSize = 0x%x\n",
; 712  :             pIrb->u.GetConfigurationInformation.VendorLeafBufferSize));
; 713  :         TRACE(TL_TRACE, ("VendorLeaf->TL_CRC = 0x%x\n",
; 714  :             pIrb->u.GetConfigurationInformation.VendorLeaf->TL_CRC));
; 715  :         TRACE(TL_TRACE, ("VendorLeaf->TL_Length = 0x%x\n",
; 716  :             pIrb->u.GetConfigurationInformation.VendorLeaf->TL_Length));
; 717  :         TRACE(TL_TRACE, ("VendorLeaf->TL_Spec_Id = 0x%x\n",
; 718  :             pIrb->u.GetConfigurationInformation.VendorLeaf->TL_Spec_Id));
; 719  :         TRACE(TL_TRACE, ("VendorLeaf->TL_Language_Id = 0x%x\n",
; 720  :             pIrb->u.GetConfigurationInformation.VendorLeaf->TL_Language_Id));
; 721  : 
; 722  :         TRACE(TL_TRACE, ("ModelLeafBufferSize = 0x%x\n",
; 723  :             pIrb->u.GetConfigurationInformation.ModelLeafBufferSize));
; 724  :         TRACE(TL_TRACE, ("ModelLeaf->TL_CRC = 0x%x\n",
; 725  :             pIrb->u.GetConfigurationInformation.ModelLeaf->TL_CRC));
; 726  :         TRACE(TL_TRACE, ("ModelLeaf->TL_Length = 0x%x\n",
; 727  :             pIrb->u.GetConfigurationInformation.ModelLeaf->TL_Length));
; 728  :         TRACE(TL_TRACE, ("ModelLeaf->TL_Spec_Id = 0x%x\n",
; 729  :             pIrb->u.GetConfigurationInformation.ModelLeaf->TL_Spec_Id));
; 730  :         TRACE(TL_TRACE, ("ModelLeaf->TL_Language_Id = 0x%x\n",
; 731  :             pIrb->u.GetConfigurationInformation.ModelLeaf->TL_Language_Id));
; 732  :     }
; 733  :     else {
; 734  : 
; 735  :         TRACE(TL_ERROR, ("SubmitIrpSync failed = 0x%x\n", ntStatus));
; 736  :     }
; 737  : 
; 738  :     if (pIrb)
; 739  :         ExFreePool(pIrb);
; 740  : 
; 741  : Exit_GetConfigurationInformation:
; 742  : 
; 743  :     if (allocNewIrp) 
; 744  :         Irp->IoStatus = ioStatus;
; 745  :         
; 746  :     EXIT("t1394_GetConfigurationInformation", ntStatus);
; 747  :     return(ntStatus);
; 748  : } // t1394_GetConfigurationInformation

  00005	c2 08 00	 ret	 8
_t1394_GetConfigurationInformation@8 ENDP
_TEXT	ENDS
PUBLIC	_t1394_BusReset@12
; Function compile flags: /Ogsy
;	COMDAT _t1394_BusReset@12
_TEXT	SEGMENT
_Event$ = -28						; size = 16
_ioStatus$ = -12					; size = 8
_newIrp$ = -4						; size = 4
_DeviceObject$ = 8					; size = 4
_allocNewIrp$ = 11					; size = 1
_Irp$ = 12						; size = 4
_fulFlags$ = 16						; size = 4
_t1394_BusReset@12 PROC NEAR				; COMDAT

; 756  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH

; 757  :     NTSTATUS            ntStatus = STATUS_SUCCESS;
; 758  :     PDEVICE_EXTENSION   deviceExtension = DeviceObject->DeviceExtension;

  00006	8b 45 08	 mov	 eax, DWORD PTR _DeviceObject$[ebp]
  00009	56		 push	 esi
  0000a	8b 70 28	 mov	 esi, DWORD PTR [eax+40]

; 759  :     PIRB                pIrb;
; 760  : 
; 761  :     PIRP                newIrp;
; 762  :     BOOLEAN             allocNewIrp = FALSE;
; 763  :     KEVENT              Event;
; 764  :     IO_STATUS_BLOCK     ioStatus;
; 765  :     
; 766  :     ENTER("t1394_BusReset");
; 767  : 
; 768  :     TRACE(TL_TRACE, ("fulFlags = 0x%x\n", fulFlags));
; 769  : 
; 770  :     //
; 771  :     // If this is a UserMode request create a newIrp so that the request
; 772  :     // will be issued from KernelMode
; 773  :     //
; 774  :     if (Irp->RequestorMode == UserMode) {

  0000d	8b 45 0c	 mov	 eax, DWORD PTR _Irp$[ebp]
  00010	57		 push	 edi

; 775  : 
; 776  :         newIrp = IoBuildDeviceIoControlRequest (IOCTL_1394_CLASS, deviceExtension->StackDeviceObject, 
; 777  :                             NULL, 0, NULL, 0, TRUE, &Event, &ioStatus);

  00011	33 ff		 xor	 edi, edi
  00013	80 78 20 01	 cmp	 BYTE PTR [eax+32], 1
  00017	c6 45 0b 00	 mov	 BYTE PTR _allocNewIrp$[ebp], 0
  0001b	75 30		 jne	 SHORT $L9069
  0001d	8d 45 f4	 lea	 eax, DWORD PTR _ioStatus$[ebp]
  00020	50		 push	 eax
  00021	8d 45 e4	 lea	 eax, DWORD PTR _Event$[ebp]
  00024	50		 push	 eax
  00025	6a 01		 push	 1
  00027	57		 push	 edi
  00028	57		 push	 edi
  00029	57		 push	 edi
  0002a	57		 push	 edi
  0002b	ff 36		 push	 DWORD PTR [esi]
  0002d	68 1d 02 22 00	 push	 2228765			; 0022021dH
  00032	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoBuildDeviceIoControlRequest@36

; 778  : 
; 779  :         if (!newIrp) {

  00038	3b c7		 cmp	 eax, edi
  0003a	89 45 fc	 mov	 DWORD PTR _newIrp$[ebp], eax
  0003d	75 0a		 jne	 SHORT $L9072

; 780  : 
; 781  :             TRACE(TL_ERROR, ("Failed to allocate newIrp!\n"));        
; 782  :             ntStatus = STATUS_INSUFFICIENT_RESOURCES;

  0003f	be 9a 00 00 c0	 mov	 esi, -1073741670	; c000009aH

; 783  :             goto Exit_BusReset;            

  00044	e9 a1 00 00 00	 jmp	 $L9086
$L9072:

; 784  :         }
; 785  :         allocNewIrp = TRUE;

  00049	c6 45 0b 01	 mov	 BYTE PTR _allocNewIrp$[ebp], 1
$L9069:
  0004d	53		 push	 ebx

; 786  :     }
; 787  :     
; 788  :     pIrb = ExAllocatePool(NonPagedPool, sizeof(IRB));

  0004e	68 57 64 6d 20	 push	 544040023		; 206d6457H
  00053	68 58 01 00 00	 push	 344			; 00000158H
  00058	57		 push	 edi
  00059	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExAllocatePoolWithTag@12
  0005f	8b d8		 mov	 ebx, eax

; 789  : 
; 790  :     if (!pIrb) {

  00061	3b df		 cmp	 ebx, edi
  00063	75 07		 jne	 SHORT $L9076

; 791  : 
; 792  :         TRACE(TL_ERROR, ("Failed to allocate pIrb!\n"));
; 793  :         ntStatus = STATUS_INSUFFICIENT_RESOURCES;

  00065	be 9a 00 00 c0	 mov	 esi, -1073741670	; c000009aH

; 794  :         goto Exit_BusReset;

  0006a	eb 68		 jmp	 SHORT $Exit_BusReset$9074
$L9076:

; 795  :     } // if
; 796  : 
; 797  :     RtlZeroMemory (pIrb, sizeof (IRB));

  0006c	6a 56		 push	 86			; 00000056H
  0006e	33 c0		 xor	 eax, eax
  00070	59		 pop	 ecx
  00071	8b fb		 mov	 edi, ebx
  00073	f3 ab		 rep stosd

; 798  :     pIrb->FunctionNumber = REQUEST_BUS_RESET;
; 799  :     pIrb->Flags = 0;
; 800  :     pIrb->u.BusReset.fulFlags = fulFlags;

  00075	8b 45 10	 mov	 eax, DWORD PTR _fulFlags$[ebp]
  00078	33 ff		 xor	 edi, edi

; 801  : 
; 802  :     //
; 803  :     // If we allocated this irp, submit it asynchronously and wait for its
; 804  :     // completion event to be signaled.  Otherwise submit it synchronously
; 805  :     //
; 806  :     if (allocNewIrp) {

  0007a	80 7d 0b 00	 cmp	 BYTE PTR _allocNewIrp$[ebp], 0
  0007e	c7 03 19 00 00
	00		 mov	 DWORD PTR [ebx], 25	; 00000019H
  00084	89 7b 04	 mov	 DWORD PTR [ebx+4], edi
  00087	89 43 48	 mov	 DWORD PTR [ebx+72], eax
  0008a	74 34		 je	 SHORT $L9079

; 807  : 
; 808  :         KeInitializeEvent (&Event, NotificationEvent, FALSE);

  0008c	57		 push	 edi
  0008d	57		 push	 edi
  0008e	8d 45 e4	 lea	 eax, DWORD PTR _Event$[ebp]
  00091	50		 push	 eax
  00092	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeInitializeEvent@12

; 809  :         ntStatus = t1394_SubmitIrpAsync (deviceExtension->StackDeviceObject, newIrp, pIrb);

  00098	53		 push	 ebx
  00099	ff 75 fc	 push	 DWORD PTR _newIrp$[ebp]
  0009c	ff 36		 push	 DWORD PTR [esi]
  0009e	e8 00 00 00 00	 call	 _t1394_SubmitIrpAsync@12
  000a3	8b f0		 mov	 esi, eax

; 810  : 
; 811  :         if (ntStatus == STATUS_PENDING) {

  000a5	81 fe 03 01 00
	00		 cmp	 esi, 259		; 00000103H
  000ab	75 20		 jne	 SHORT $L9083

; 812  :             KeWaitForSingleObject (&Event, Executive, KernelMode, FALSE, NULL); 

  000ad	57		 push	 edi
  000ae	57		 push	 edi
  000af	57		 push	 edi
  000b0	57		 push	 edi
  000b1	8d 45 e4	 lea	 eax, DWORD PTR _Event$[ebp]
  000b4	50		 push	 eax
  000b5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeWaitForSingleObject@20

; 813  :             ntStatus = ioStatus.Status;

  000bb	8b 75 f4	 mov	 esi, DWORD PTR _ioStatus$[ebp]

; 814  :         }
; 815  :     }
; 816  :     else {

  000be	eb 0d		 jmp	 SHORT $L9083
$L9079:

; 817  :         ntStatus = t1394_SubmitIrpSynch(deviceExtension->StackDeviceObject, Irp, pIrb);

  000c0	53		 push	 ebx
  000c1	ff 75 0c	 push	 DWORD PTR _Irp$[ebp]
  000c4	ff 36		 push	 DWORD PTR [esi]
  000c6	e8 00 00 00 00	 call	 _t1394_SubmitIrpSynch@12
  000cb	8b f0		 mov	 esi, eax
$L9083:

; 818  :     }
; 819  :     
; 820  :     if (!NT_SUCCESS(ntStatus)) {
; 821  : 
; 822  :         TRACE(TL_ERROR, ("SubmitIrpSync failed = 0x%x\n", ntStatus));
; 823  :     }
; 824  : 
; 825  :     ExFreePool(pIrb);

  000cd	53		 push	 ebx
  000ce	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePool@4
$Exit_BusReset$9074:

; 826  : 
; 827  : Exit_BusReset:
; 828  : 
; 829  :     if (allocNewIrp) 

  000d4	80 7d 0b 00	 cmp	 BYTE PTR _allocNewIrp$[ebp], 0
  000d8	5b		 pop	 ebx
  000d9	74 0f		 je	 SHORT $L9086

; 830  :         Irp->IoStatus = ioStatus;

  000db	8b 4d f4	 mov	 ecx, DWORD PTR _ioStatus$[ebp]
  000de	8b 45 0c	 mov	 eax, DWORD PTR _Irp$[ebp]
  000e1	89 48 18	 mov	 DWORD PTR [eax+24], ecx
  000e4	8b 4d f8	 mov	 ecx, DWORD PTR _ioStatus$[ebp+4]
  000e7	89 48 1c	 mov	 DWORD PTR [eax+28], ecx
$L9086:
  000ea	5f		 pop	 edi

; 831  :         
; 832  :     EXIT("t1394_BusReset", ntStatus);
; 833  :     return(ntStatus);

  000eb	8b c6		 mov	 eax, esi
  000ed	5e		 pop	 esi

; 834  : } // t1394_BusReset

  000ee	c9		 leave
  000ef	c2 0c 00	 ret	 12			; 0000000cH
_t1394_BusReset@12 ENDP
_TEXT	ENDS
PUBLIC	_t1394_GetGenerationCount@12
; Function compile flags: /Ogsy
;	COMDAT _t1394_GetGenerationCount@12
_TEXT	SEGMENT
_Event$ = -28						; size = 16
_ioStatus$ = -12					; size = 8
_newIrp$ = -4						; size = 4
_DeviceObject$ = 8					; size = 4
_allocNewIrp$ = 11					; size = 1
_Irp$ = 12						; size = 4
_GenerationCount$ = 16					; size = 4
_t1394_GetGenerationCount@12 PROC NEAR			; COMDAT

; 842  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH

; 843  :     NTSTATUS            ntStatus = STATUS_SUCCESS;
; 844  :     PDEVICE_EXTENSION   deviceExtension = DeviceObject->DeviceExtension;

  00006	8b 45 08	 mov	 eax, DWORD PTR _DeviceObject$[ebp]
  00009	53		 push	 ebx

; 845  :     PIRB                pIrb;
; 846  : 
; 847  :     PIRP                newIrp;
; 848  :     BOOLEAN             allocNewIrp = FALSE;
; 849  :     KEVENT              Event;
; 850  :     IO_STATUS_BLOCK     ioStatus;
; 851  :     
; 852  :     ENTER("t1394_GetGenerationCount");
; 853  : 
; 854  :     //
; 855  :     // If we were not passed an Irp or this is a UserMode request create a newIrp 
; 856  :     // so that the request will be issued from KernelMode
; 857  :     //
; 858  :     if (!Irp || Irp->RequestorMode == UserMode) {

  0000a	8b 5d 0c	 mov	 ebx, DWORD PTR _Irp$[ebp]
  0000d	56		 push	 esi
  0000e	8b 70 28	 mov	 esi, DWORD PTR [eax+40]
  00011	57		 push	 edi
  00012	33 ff		 xor	 edi, edi
  00014	3b df		 cmp	 ebx, edi
  00016	c6 45 0b 00	 mov	 BYTE PTR _allocNewIrp$[ebp], 0
  0001a	74 06		 je	 SHORT $L9103
  0001c	80 7b 20 01	 cmp	 BYTE PTR [ebx+32], 1
  00020	75 30		 jne	 SHORT $L10718
$L9103:

; 859  : 
; 860  :         newIrp = IoBuildDeviceIoControlRequest (IOCTL_1394_CLASS, deviceExtension->StackDeviceObject, 
; 861  :                             NULL, 0, NULL, 0, TRUE, &Event, &ioStatus);

  00022	8d 45 f4	 lea	 eax, DWORD PTR _ioStatus$[ebp]
  00025	50		 push	 eax
  00026	8d 45 e4	 lea	 eax, DWORD PTR _Event$[ebp]
  00029	50		 push	 eax
  0002a	6a 01		 push	 1
  0002c	57		 push	 edi
  0002d	57		 push	 edi
  0002e	57		 push	 edi
  0002f	57		 push	 edi
  00030	ff 36		 push	 DWORD PTR [esi]
  00032	68 1d 02 22 00	 push	 2228765			; 0022021dH
  00037	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoBuildDeviceIoControlRequest@36

; 862  : 
; 863  :         if (!newIrp) {

  0003d	3b c7		 cmp	 eax, edi
  0003f	89 45 fc	 mov	 DWORD PTR _newIrp$[ebp], eax
  00042	75 0a		 jne	 SHORT $L9106

; 864  : 
; 865  :             TRACE(TL_ERROR, ("Failed to allocate newIrp!\n"));      
; 866  :             ntStatus = STATUS_INSUFFICIENT_RESOURCES;

  00044	be 9a 00 00 c0	 mov	 esi, -1073741670	; c000009aH

; 867  :             goto Exit_GetGenerationCount;            

  00049	e9 9f 00 00 00	 jmp	 $Exit_GetGenerationCount$9108
$L9106:

; 868  :         }
; 869  :         allocNewIrp = TRUE;

  0004e	c6 45 0b 01	 mov	 BYTE PTR _allocNewIrp$[ebp], 1
$L10718:

; 870  :     }
; 871  : 
; 872  :     pIrb = ExAllocatePool(NonPagedPool, sizeof(IRB));

  00052	68 57 64 6d 20	 push	 544040023		; 206d6457H
  00057	68 58 01 00 00	 push	 344			; 00000158H
  0005c	57		 push	 edi
  0005d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExAllocatePoolWithTag@12
  00063	8b d8		 mov	 ebx, eax

; 873  : 
; 874  :     if (!pIrb) {

  00065	3b df		 cmp	 ebx, edi
  00067	75 07		 jne	 SHORT $L9110

; 875  : 
; 876  :         TRACE(TL_ERROR, ("Failed to allocate pIrb!\n"));
; 877  :         ntStatus = STATUS_INSUFFICIENT_RESOURCES;

  00069	be 9a 00 00 c0	 mov	 esi, -1073741670	; c000009aH

; 878  :         goto Exit_GetGenerationCount;

  0006e	eb 7a		 jmp	 SHORT $L10719
$L9110:

; 879  :     } // if
; 880  : 
; 881  :     RtlZeroMemory (pIrb, sizeof (IRB));

  00070	6a 56		 push	 86			; 00000056H
  00072	33 c0		 xor	 eax, eax
  00074	59		 pop	 ecx
  00075	8b fb		 mov	 edi, ebx
  00077	f3 ab		 rep stosd

; 882  :     pIrb->FunctionNumber = REQUEST_GET_GENERATION_COUNT;
; 883  :     pIrb->Flags = 0;

  00079	33 ff		 xor	 edi, edi

; 884  : 
; 885  :     //
; 886  :     // If we allocated this irp, submit it asynchronously and wait for its
; 887  :     // completion event to be signaled.  Otherwise submit it synchronously
; 888  :     //
; 889  :     if (allocNewIrp) {

  0007b	80 7d 0b 00	 cmp	 BYTE PTR _allocNewIrp$[ebp], 0
  0007f	c7 03 1a 00 00
	00		 mov	 DWORD PTR [ebx], 26	; 0000001aH
  00085	89 7b 04	 mov	 DWORD PTR [ebx+4], edi
  00088	74 3e		 je	 SHORT $L9113

; 890  : 
; 891  :         KeInitializeEvent (&Event, NotificationEvent, FALSE);

  0008a	57		 push	 edi
  0008b	57		 push	 edi
  0008c	8d 45 e4	 lea	 eax, DWORD PTR _Event$[ebp]
  0008f	50		 push	 eax
  00090	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeInitializeEvent@12

; 892  :         ntStatus = t1394_SubmitIrpAsync (deviceExtension->StackDeviceObject, newIrp, pIrb);

  00096	53		 push	 ebx
  00097	ff 75 fc	 push	 DWORD PTR _newIrp$[ebp]
  0009a	ff 36		 push	 DWORD PTR [esi]
  0009c	e8 00 00 00 00	 call	 _t1394_SubmitIrpAsync@12
  000a1	8b f0		 mov	 esi, eax

; 893  : 
; 894  :         if ((ntStatus == STATUS_PENDING) && (KeGetCurrentIrql() < DISPATCH_LEVEL)) {

  000a3	81 fe 03 01 00
	00		 cmp	 esi, 259		; 00000103H
  000a9	75 2a		 jne	 SHORT $L9117
  000ab	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeGetCurrentIrql@0
  000b1	3c 02		 cmp	 al, 2
  000b3	73 24		 jae	 SHORT $L10717

; 895  :             KeWaitForSingleObject (&Event, Executive, KernelMode, FALSE, NULL); 

  000b5	57		 push	 edi
  000b6	57		 push	 edi
  000b7	57		 push	 edi
  000b8	57		 push	 edi
  000b9	8d 45 e4	 lea	 eax, DWORD PTR _Event$[ebp]
  000bc	50		 push	 eax
  000bd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeWaitForSingleObject@20

; 896  :             ntStatus = ioStatus.Status;

  000c3	8b 75 f4	 mov	 esi, DWORD PTR _ioStatus$[ebp]

; 897  :         }
; 898  :     }
; 899  :     else {

  000c6	eb 0d		 jmp	 SHORT $L9117
$L9113:

; 900  :         ntStatus = t1394_SubmitIrpSynch(deviceExtension->StackDeviceObject, Irp, pIrb);

  000c8	53		 push	 ebx
  000c9	ff 75 0c	 push	 DWORD PTR _Irp$[ebp]
  000cc	ff 36		 push	 DWORD PTR [esi]
  000ce	e8 00 00 00 00	 call	 _t1394_SubmitIrpSynch@12
  000d3	8b f0		 mov	 esi, eax
$L9117:

; 901  :     }
; 902  :     
; 903  :     if (NT_SUCCESS(ntStatus)) {

  000d5	3b f7		 cmp	 esi, edi
  000d7	7c 08		 jl	 SHORT $L9119
$L10717:

; 904  : 
; 905  :         *GenerationCount = pIrb->u.GetGenerationCount.GenerationCount;

  000d9	8b 43 48	 mov	 eax, DWORD PTR [ebx+72]
  000dc	8b 4d 10	 mov	 ecx, DWORD PTR _GenerationCount$[ebp]
  000df	89 01		 mov	 DWORD PTR [ecx], eax
$L9119:

; 906  :         TRACE(TL_TRACE, ("GenerationCount = 0x%x\n", *GenerationCount));
; 907  :     }
; 908  :     else {
; 909  : 
; 910  :         TRACE(TL_ERROR, ("SubmitIrpSync failed = 0x%x\n", ntStatus));
; 911  :     }
; 912  : 
; 913  :     ExFreePool(pIrb);

  000e1	53		 push	 ebx
  000e2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePool@4
  000e8	33 ff		 xor	 edi, edi
$L10719:
  000ea	8b 5d 0c	 mov	 ebx, DWORD PTR _Irp$[ebp]
$Exit_GetGenerationCount$9108:

; 914  : 
; 915  : Exit_GetGenerationCount:
; 916  : 
; 917  :     if (Irp && allocNewIrp) 

  000ed	3b df		 cmp	 ebx, edi
  000ef	74 12		 je	 SHORT $L9121
  000f1	80 7d 0b 00	 cmp	 BYTE PTR _allocNewIrp$[ebp], 0
  000f5	74 0c		 je	 SHORT $L9121

; 918  :         Irp->IoStatus = ioStatus;

  000f7	8b 45 f4	 mov	 eax, DWORD PTR _ioStatus$[ebp]
  000fa	89 43 18	 mov	 DWORD PTR [ebx+24], eax
  000fd	8b 45 f8	 mov	 eax, DWORD PTR _ioStatus$[ebp+4]
  00100	89 43 1c	 mov	 DWORD PTR [ebx+28], eax
$L9121:
  00103	5f		 pop	 edi

; 919  :         
; 920  :     EXIT("t1394_GetGenerationCount", ntStatus);
; 921  :     return(ntStatus);

  00104	8b c6		 mov	 eax, esi
  00106	5e		 pop	 esi
  00107	5b		 pop	 ebx

; 922  : } // t1394_GetGenerationCount

  00108	c9		 leave
  00109	c2 0c 00	 ret	 12			; 0000000cH
_t1394_GetGenerationCount@12 ENDP
_TEXT	ENDS
PUBLIC	_t1394_SendPhyConfigurationPacket@16
; Function compile flags: /Ogsy
;	COMDAT _t1394_SendPhyConfigurationPacket@16
_TEXT	SEGMENT
_Event$ = -28						; size = 16
_ioStatus$ = -12					; size = 8
_newIrp$ = -4						; size = 4
_DeviceObject$ = 8					; size = 4
_allocNewIrp$ = 11					; size = 1
_Irp$ = 12						; size = 4
_PhyConfigurationPacket$ = 16				; size = 8
_t1394_SendPhyConfigurationPacket@16 PROC NEAR		; COMDAT

; 930  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH

; 931  :     NTSTATUS            ntStatus = STATUS_SUCCESS;
; 932  :     PDEVICE_EXTENSION   deviceExtension = DeviceObject->DeviceExtension;

  00006	8b 45 08	 mov	 eax, DWORD PTR _DeviceObject$[ebp]
  00009	53		 push	 ebx
  0000a	8b 58 28	 mov	 ebx, DWORD PTR [eax+40]

; 933  :     PIRB                pIrb;
; 934  : 
; 935  :     PIRP                newIrp;
; 936  :     BOOLEAN             allocNewIrp = FALSE;
; 937  :     KEVENT              Event;
; 938  :     IO_STATUS_BLOCK     ioStatus;
; 939  :     
; 940  :     ENTER("t1394_SendPhyConfigurationPacket");
; 941  : 
; 942  :     TRACE(TL_TRACE, ("PCP_Phys_ID = 0x%x\n", PhyConfigurationPacket.PCP_Phys_ID));
; 943  :     TRACE(TL_TRACE, ("PCP_Packet_ID = 0x%x\n", PhyConfigurationPacket.PCP_Packet_ID));
; 944  :     TRACE(TL_TRACE, ("PCP_Gap_Count = 0x%x\n", PhyConfigurationPacket.PCP_Gap_Count));
; 945  :     TRACE(TL_TRACE, ("PCP_Set_Gap_Count = 0x%x\n", PhyConfigurationPacket.PCP_Set_Gap_Count));
; 946  :     TRACE(TL_TRACE, ("PCP_Force_Root = 0x%x\n", PhyConfigurationPacket.PCP_Force_Root));
; 947  :     TRACE(TL_TRACE, ("PCP_Reserved1 = 0x%x\n", PhyConfigurationPacket.PCP_Reserved1));
; 948  :     TRACE(TL_TRACE, ("PCP_Reserved2 = 0x%x\n", PhyConfigurationPacket.PCP_Reserved2));
; 949  :     TRACE(TL_TRACE, ("PCP_Inverse = 0x%x\n", PhyConfigurationPacket.PCP_Inverse));
; 950  : 
; 951  :     //
; 952  :     // If this is a UserMode request create a newIrp so that the request
; 953  :     // will be issued from KernelMode
; 954  :     //
; 955  :     if (Irp->RequestorMode == UserMode) {

  0000d	8b 45 0c	 mov	 eax, DWORD PTR _Irp$[ebp]
  00010	57		 push	 edi

; 956  : 
; 957  :         newIrp = IoBuildDeviceIoControlRequest (IOCTL_1394_CLASS, deviceExtension->StackDeviceObject, 
; 958  :                             NULL, 0, NULL, 0, TRUE, &Event, &ioStatus);

  00011	33 ff		 xor	 edi, edi
  00013	80 78 20 01	 cmp	 BYTE PTR [eax+32], 1
  00017	c6 45 0b 00	 mov	 BYTE PTR _allocNewIrp$[ebp], 0
  0001b	75 30		 jne	 SHORT $L9137
  0001d	8d 45 f4	 lea	 eax, DWORD PTR _ioStatus$[ebp]
  00020	50		 push	 eax
  00021	8d 45 e4	 lea	 eax, DWORD PTR _Event$[ebp]
  00024	50		 push	 eax
  00025	6a 01		 push	 1
  00027	57		 push	 edi
  00028	57		 push	 edi
  00029	57		 push	 edi
  0002a	57		 push	 edi
  0002b	ff 33		 push	 DWORD PTR [ebx]
  0002d	68 1d 02 22 00	 push	 2228765			; 0022021dH
  00032	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoBuildDeviceIoControlRequest@36

; 959  : 
; 960  :         if (!newIrp) {

  00038	3b c7		 cmp	 eax, edi
  0003a	89 45 fc	 mov	 DWORD PTR _newIrp$[ebp], eax
  0003d	75 0a		 jne	 SHORT $L9140

; 961  : 
; 962  :             TRACE(TL_ERROR, ("Failed to allocate newIrp!\n"));        
; 963  :             ntStatus = STATUS_INSUFFICIENT_RESOURCES;

  0003f	bb 9a 00 00 c0	 mov	 ebx, -1073741670	; c000009aH

; 964  :             goto Exit_SendPhyConfigurationPacket;            

  00044	e9 a7 00 00 00	 jmp	 $L9155
$L9140:

; 965  :         }
; 966  :         allocNewIrp = TRUE;

  00049	c6 45 0b 01	 mov	 BYTE PTR _allocNewIrp$[ebp], 1
$L9137:
  0004d	56		 push	 esi

; 967  :     }
; 968  :     
; 969  :     pIrb = ExAllocatePool(NonPagedPool, sizeof(IRB));

  0004e	68 57 64 6d 20	 push	 544040023		; 206d6457H
  00053	68 58 01 00 00	 push	 344			; 00000158H
  00058	57		 push	 edi
  00059	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExAllocatePoolWithTag@12
  0005f	8b f0		 mov	 esi, eax

; 970  : 
; 971  :     if (!pIrb) {

  00061	3b f7		 cmp	 esi, edi
  00063	75 07		 jne	 SHORT $L9144

; 972  : 
; 973  :         TRACE(TL_ERROR, ("Failed to allocate pIrb!\n"));
; 974  :         ntStatus = STATUS_INSUFFICIENT_RESOURCES;

  00065	bb 9a 00 00 c0	 mov	 ebx, -1073741670	; c000009aH

; 975  :         goto Exit_SendPhyConfigurationPacket;

  0006a	eb 6e		 jmp	 SHORT $Exit_SendPhyConfigurationPacket$9142
$L9144:

; 976  :     } // if
; 977  : 
; 978  :     RtlZeroMemory (pIrb, sizeof (IRB));

  0006c	33 c0		 xor	 eax, eax
  0006e	6a 56		 push	 86			; 00000056H
  00070	59		 pop	 ecx
  00071	8b fe		 mov	 edi, esi
  00073	f3 ab		 rep stosd

; 979  :     pIrb->FunctionNumber = REQUEST_SEND_PHY_CONFIG_PACKET;
; 980  :     pIrb->Flags = 0;
; 981  :     pIrb->u.SendPhyConfigurationPacket.PhyConfigurationPacket = PhyConfigurationPacket;

  00075	8b 45 10	 mov	 eax, DWORD PTR _PhyConfigurationPacket$[ebp]
  00078	33 ff		 xor	 edi, edi

; 982  : 
; 983  :     //
; 984  :     // If we allocated this irp, submit it asynchronously and wait for its
; 985  :     // completion event to be signaled.  Otherwise submit it synchronously
; 986  :     //
; 987  :     if (allocNewIrp) {

  0007a	80 7d 0b 00	 cmp	 BYTE PTR _allocNewIrp$[ebp], 0
  0007e	89 46 48	 mov	 DWORD PTR [esi+72], eax
  00081	8b 45 14	 mov	 eax, DWORD PTR _PhyConfigurationPacket$[ebp+4]
  00084	c7 06 1b 00 00
	00		 mov	 DWORD PTR [esi], 27	; 0000001bH
  0008a	89 7e 04	 mov	 DWORD PTR [esi+4], edi
  0008d	89 46 4c	 mov	 DWORD PTR [esi+76], eax
  00090	74 34		 je	 SHORT $L9147

; 988  : 
; 989  :         KeInitializeEvent (&Event, NotificationEvent, FALSE);

  00092	57		 push	 edi
  00093	57		 push	 edi
  00094	8d 45 e4	 lea	 eax, DWORD PTR _Event$[ebp]
  00097	50		 push	 eax
  00098	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeInitializeEvent@12

; 990  :         ntStatus = t1394_SubmitIrpAsync (deviceExtension->StackDeviceObject, newIrp, pIrb);

  0009e	56		 push	 esi
  0009f	ff 75 fc	 push	 DWORD PTR _newIrp$[ebp]
  000a2	ff 33		 push	 DWORD PTR [ebx]
  000a4	e8 00 00 00 00	 call	 _t1394_SubmitIrpAsync@12
  000a9	8b d8		 mov	 ebx, eax

; 991  : 
; 992  :         if (ntStatus == STATUS_PENDING) {

  000ab	81 fb 03 01 00
	00		 cmp	 ebx, 259		; 00000103H
  000b1	75 20		 jne	 SHORT $L9151

; 993  :             KeWaitForSingleObject (&Event, Executive, KernelMode, FALSE, NULL); 

  000b3	57		 push	 edi
  000b4	57		 push	 edi
  000b5	57		 push	 edi
  000b6	57		 push	 edi
  000b7	8d 45 e4	 lea	 eax, DWORD PTR _Event$[ebp]
  000ba	50		 push	 eax
  000bb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeWaitForSingleObject@20

; 994  :             ntStatus = ioStatus.Status;

  000c1	8b 5d f4	 mov	 ebx, DWORD PTR _ioStatus$[ebp]

; 995  :         }
; 996  :     }
; 997  :     else {

  000c4	eb 0d		 jmp	 SHORT $L9151
$L9147:

; 998  :         ntStatus = t1394_SubmitIrpSynch(deviceExtension->StackDeviceObject, Irp, pIrb);

  000c6	56		 push	 esi
  000c7	ff 75 0c	 push	 DWORD PTR _Irp$[ebp]
  000ca	ff 33		 push	 DWORD PTR [ebx]
  000cc	e8 00 00 00 00	 call	 _t1394_SubmitIrpSynch@12
  000d1	8b d8		 mov	 ebx, eax
$L9151:

; 999  :     }
; 1000 :     
; 1001 :     if (!NT_SUCCESS(ntStatus)) {
; 1002 : 
; 1003 :         TRACE(TL_ERROR, ("SubmitIrpSync failed = 0x%x\n", ntStatus));
; 1004 :     }
; 1005 : 
; 1006 :     if (pIrb)
; 1007 :         ExFreePool(pIrb);

  000d3	56		 push	 esi
  000d4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePool@4
$Exit_SendPhyConfigurationPacket$9142:

; 1008 : 
; 1009 : Exit_SendPhyConfigurationPacket:
; 1010 : 
; 1011 :     if (allocNewIrp) 

  000da	80 7d 0b 00	 cmp	 BYTE PTR _allocNewIrp$[ebp], 0
  000de	5e		 pop	 esi
  000df	74 0f		 je	 SHORT $L9155

; 1012 :         Irp->IoStatus = ioStatus;

  000e1	8b 4d f4	 mov	 ecx, DWORD PTR _ioStatus$[ebp]
  000e4	8b 45 0c	 mov	 eax, DWORD PTR _Irp$[ebp]
  000e7	89 48 18	 mov	 DWORD PTR [eax+24], ecx
  000ea	8b 4d f8	 mov	 ecx, DWORD PTR _ioStatus$[ebp+4]
  000ed	89 48 1c	 mov	 DWORD PTR [eax+28], ecx
$L9155:
  000f0	5f		 pop	 edi

; 1013 : 
; 1014 :     EXIT("t1394_SendPhyConfigurationPacket", ntStatus);
; 1015 :     return(ntStatus);

  000f1	8b c3		 mov	 eax, ebx
  000f3	5b		 pop	 ebx

; 1016 : } // t1394_SendPhyConfigurationPacket

  000f4	c9		 leave
  000f5	c2 10 00	 ret	 16			; 00000010H
_t1394_SendPhyConfigurationPacket@16 ENDP
_TEXT	ENDS
PUBLIC	_t1394_SetLocalHostProperties@16
EXTRN	__imp__MmBuildMdlForNonPagedPool@4:NEAR
EXTRN	__imp__IoAllocateMdl@20:NEAR
; Function compile flags: /Ogsy
;	COMDAT _t1394_SetLocalHostProperties@16
_TEXT	SEGMENT
_Event$ = -40						; size = 16
_ioStatus$ = -24					; size = 8
_newIrp$ = -16						; size = 4
_pIrb$ = -12						; size = 4
_R0_SetLocalHostProps3$ = -8				; size = 4
_deviceExtension$ = -4					; size = 4
_ntStatus$ = -4						; size = 4
_DeviceObject$ = 8					; size = 4
_allocNewIrp$ = 11					; size = 1
_Irp$ = 12						; size = 4
_nLevel$ = 16						; size = 4
tv386 = 20						; size = 4
_CromData$ = 20						; size = 4
_Information$ = 20					; size = 4
_t1394_SetLocalHostProperties@16 PROC NEAR		; COMDAT

; 1025 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H

; 1026 :     NTSTATUS            ntStatus = STATUS_SUCCESS;
; 1027 :     PDEVICE_EXTENSION   deviceExtension = DeviceObject->DeviceExtension;

  00006	8b 45 08	 mov	 eax, DWORD PTR _DeviceObject$[ebp]
  00009	56		 push	 esi
  0000a	8b 70 28	 mov	 esi, DWORD PTR [eax+40]

; 1028 :     PIRB                pIrb;
; 1029 : 
; 1030 :     PSET_LOCAL_HOST_PROPS3  R0_SetLocalHostProps3;
; 1031 :     PCROM_DATA              CromData;
; 1032 : 
; 1033 :     PIRP                newIrp;
; 1034 :     BOOLEAN             allocNewIrp = FALSE;
; 1035 :     KEVENT              Event;
; 1036 :     IO_STATUS_BLOCK     ioStatus;
; 1037 :     
; 1038 :     ENTER("t1394_SetLocalHostProperties");
; 1039 : 
; 1040 :     //
; 1041 :     // If this is a UserMode request create a newIrp so that the request
; 1042 :     // will be issued from KernelMode
; 1043 :     //
; 1044 :     if (Irp->RequestorMode == UserMode) {

  0000d	8b 45 0c	 mov	 eax, DWORD PTR _Irp$[ebp]
  00010	57		 push	 edi

; 1045 : 
; 1046 :         newIrp = IoBuildDeviceIoControlRequest (IOCTL_1394_CLASS, deviceExtension->StackDeviceObject, 
; 1047 :                             NULL, 0, NULL, 0, TRUE, &Event, &ioStatus);

  00011	33 ff		 xor	 edi, edi
  00013	80 78 20 01	 cmp	 BYTE PTR [eax+32], 1
  00017	89 75 fc	 mov	 DWORD PTR _deviceExtension$[ebp], esi
  0001a	c6 45 0b 00	 mov	 BYTE PTR _allocNewIrp$[ebp], 0
  0001e	75 32		 jne	 SHORT $L9175
  00020	8d 45 e8	 lea	 eax, DWORD PTR _ioStatus$[ebp]
  00023	50		 push	 eax
  00024	8d 45 d8	 lea	 eax, DWORD PTR _Event$[ebp]
  00027	50		 push	 eax
  00028	6a 01		 push	 1
  0002a	57		 push	 edi
  0002b	57		 push	 edi
  0002c	57		 push	 edi
  0002d	57		 push	 edi
  0002e	ff 36		 push	 DWORD PTR [esi]
  00030	68 1d 02 22 00	 push	 2228765			; 0022021dH
  00035	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoBuildDeviceIoControlRequest@36

; 1048 : 
; 1049 :         if (!newIrp) {

  0003b	3b c7		 cmp	 eax, edi
  0003d	89 45 f0	 mov	 DWORD PTR _newIrp$[ebp], eax
  00040	75 0c		 jne	 SHORT $L9178

; 1050 : 
; 1051 :             TRACE(TL_ERROR, ("Failed to allocate newIrp!\n"));        
; 1052 :             ntStatus = STATUS_INSUFFICIENT_RESOURCES;

  00042	c7 45 fc 9a 00
	00 c0		 mov	 DWORD PTR _ntStatus$[ebp], -1073741670 ; c000009aH

; 1053 :             goto Exit_SetLocalHostProperties;            

  00049	e9 a9 02 00 00	 jmp	 $L10746
$L9178:

; 1054 :         }
; 1055 :         allocNewIrp = TRUE;

  0004e	c6 45 0b 01	 mov	 BYTE PTR _allocNewIrp$[ebp], 1
$L9175:
  00052	53		 push	 ebx

; 1056 :     }
; 1057 :     
; 1058 :     pIrb = ExAllocatePool(NonPagedPool, sizeof(IRB));

  00053	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__ExAllocatePoolWithTag@12
  00059	68 57 64 6d 20	 push	 544040023		; 206d6457H
  0005e	68 58 01 00 00	 push	 344			; 00000158H
  00063	57		 push	 edi
  00064	ff d3		 call	 ebx
  00066	8b d0		 mov	 edx, eax

; 1059 : 
; 1060 :     if (!pIrb) {

  00068	3b d7		 cmp	 edx, edi
  0006a	89 55 f4	 mov	 DWORD PTR _pIrb$[ebp], edx

; 1061 : 
; 1062 :         TRACE(TL_ERROR, ("Failed to allocate pIrb!\n"));
; 1063 :         ntStatus = STATUS_INSUFFICIENT_RESOURCES;
; 1064 :         goto Exit_SetLocalHostProperties;

  0006d	0f 84 ef 00 00
	00		 je	 $L10752

; 1065 :     } // if
; 1066 : 
; 1067 :     RtlZeroMemory (pIrb, sizeof (IRB));

  00073	33 c0		 xor	 eax, eax
  00075	6a 56		 push	 86			; 00000056H
  00077	59		 pop	 ecx
  00078	8b fa		 mov	 edi, edx
  0007a	f3 ab		 rep stosd

; 1068 :     pIrb->FunctionNumber = REQUEST_SET_LOCAL_HOST_PROPERTIES;
; 1069 :     pIrb->Flags = 0;

  0007c	21 42 04	 and	 DWORD PTR [edx+4], eax

; 1070 :     pIrb->u.SetLocalHostProperties.nLevel = nLevel;

  0007f	8b 45 10	 mov	 eax, DWORD PTR _nLevel$[ebp]

; 1071 : 
; 1072 :     TRACE(TL_TRACE, ("nLevel = 0x%x\n", nLevel));
; 1073 :     TRACE(TL_TRACE, ("Information = 0x%x\n", Information));
; 1074 : 
; 1075 :     if (nLevel == SET_LOCAL_HOST_PROPERTIES_GAP_COUNT) {

  00082	83 f8 02	 cmp	 eax, 2
  00085	c7 02 1f 00 00
	00		 mov	 DWORD PTR [edx], 31	; 0000001fH
  0008b	89 42 48	 mov	 DWORD PTR [edx+72], eax
  0008e	75 52		 jne	 SHORT $L9185

; 1076 : 
; 1077 :         PSET_LOCAL_HOST_PROPS2  SetLocalHostProps2;
; 1078 : 
; 1079 :         SetLocalHostProps2 = (PSET_LOCAL_HOST_PROPS2)Information;
; 1080 : 
; 1081 :         TRACE(TL_TRACE, ("GapCountLowerBound = 0x%x\n", SetLocalHostProps2->GapCountLowerBound));
; 1082 : 
; 1083 :         pIrb->u.SetLocalHostProperties.Information = Information;

  00090	8b 45 14	 mov	 eax, DWORD PTR _Information$[ebp]
  00093	89 42 4c	 mov	 DWORD PTR [edx+76], eax
$L10740:

; 1167 : 
; 1168 :             TRACE(TL_TRACE, ("Mdl = 0x%x\n", R0_SetLocalHostProps3->Mdl));
; 1169 :         }
; 1170 :         else if (SetLocalHostProps3->fulFlags == SLHP_FLAG_REMOVE_CROM_DATA) {
; 1171 : 
; 1172 :             TRACE(TL_TRACE, ("hCromData = 0x%x\n", R0_SetLocalHostProps3->hCromData));
; 1173 :         }
; 1174 : 
; 1175 :         pIrb->u.SetLocalHostProperties.Information = (PVOID)R0_SetLocalHostProps3;

  00096	8b 5d 14	 mov	 ebx, DWORD PTR _CromData$[ebp]
$L9189:

; 1176 :     }
; 1177 : 
; 1178 :     //
; 1179 :     // If we allocated this irp, submit it asynchronously and wait for its
; 1180 :     // completion event to be signaled.  Otherwise submit it synchronously
; 1181 :     //
; 1182 :     if (allocNewIrp) {

  00099	80 7d 0b 00	 cmp	 BYTE PTR _allocNewIrp$[ebp], 0
  0009d	0f 84 19 01 00
	00		 je	 $L9212

; 1183 : 
; 1184 :         KeInitializeEvent (&Event, NotificationEvent, FALSE);

  000a3	33 ff		 xor	 edi, edi
  000a5	57		 push	 edi
  000a6	57		 push	 edi
  000a7	8d 45 d8	 lea	 eax, DWORD PTR _Event$[ebp]
  000aa	50		 push	 eax
  000ab	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeInitializeEvent@12

; 1185 :         ntStatus = t1394_SubmitIrpAsync (deviceExtension->StackDeviceObject, newIrp, pIrb);

  000b1	ff 75 f4	 push	 DWORD PTR _pIrb$[ebp]
  000b4	ff 75 f0	 push	 DWORD PTR _newIrp$[ebp]
  000b7	ff 36		 push	 DWORD PTR [esi]
  000b9	e8 00 00 00 00	 call	 _t1394_SubmitIrpAsync@12

; 1186 : 
; 1187 :         if (ntStatus == STATUS_PENDING) {

  000be	3d 03 01 00 00	 cmp	 eax, 259		; 00000103H
  000c3	89 45 fc	 mov	 DWORD PTR _ntStatus$[ebp], eax
  000c6	0f 85 00 01 00
	00		 jne	 $L9216

; 1188 :             KeWaitForSingleObject (&Event, Executive, KernelMode, FALSE, NULL); 

  000cc	57		 push	 edi
  000cd	57		 push	 edi
  000ce	57		 push	 edi
  000cf	57		 push	 edi
  000d0	8d 45 d8	 lea	 eax, DWORD PTR _Event$[ebp]
  000d3	50		 push	 eax
  000d4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeWaitForSingleObject@20

; 1189 :             ntStatus = ioStatus.Status;

  000da	8b 45 e8	 mov	 eax, DWORD PTR _ioStatus$[ebp]

; 1190 :         }
; 1191 :     }
; 1192 :     else {

  000dd	e9 e7 00 00 00	 jmp	 $L10749
$L9185:

; 1084 :     }
; 1085 :     else if (nLevel == SET_LOCAL_HOST_PROPERTIES_MODIFY_CROM) {

  000e2	83 f8 03	 cmp	 eax, 3
  000e5	75 af		 jne	 SHORT $L10740

; 1086 : 
; 1087 :         PSET_LOCAL_HOST_PROPS3  SetLocalHostProps3;
; 1088 : 
; 1089 :         SetLocalHostProps3 = (PSET_LOCAL_HOST_PROPS3)Information;
; 1090 : 
; 1091 :         TRACE(TL_TRACE, ("fulFlags = 0x%x\n", SetLocalHostProps3->fulFlags));
; 1092 :         TRACE(TL_TRACE, ("hCromData = 0x%x\n", SetLocalHostProps3->hCromData));
; 1093 :         TRACE(TL_TRACE, ("nLength = 0x%x\n", SetLocalHostProps3->nLength));
; 1094 : 
; 1095 :         // since we need to create a mdl, we'll create another setlocalhostprops3
; 1096 :         // and pass that down to the bus driver
; 1097 :         R0_SetLocalHostProps3 = ExAllocatePool(NonPagedPool, sizeof(SET_LOCAL_HOST_PROPS3));

  000e7	68 57 64 6d 20	 push	 544040023		; 206d6457H
  000ec	6a 10		 push	 16			; 00000010H
  000ee	6a 00		 push	 0
  000f0	ff d3		 call	 ebx

; 1098 : 
; 1099 :         if (!R0_SetLocalHostProps3) {

  000f2	85 c0		 test	 eax, eax
  000f4	89 45 f8	 mov	 DWORD PTR _R0_SetLocalHostProps3$[ebp], eax
  000f7	75 0b		 jne	 SHORT $L9193

; 1100 : 
; 1101 :             TRACE(TL_ERROR, ("Failed to allocate R0_SetLocalHostProps3!\n"));
; 1102 :             if (pIrb)
; 1103 :                 ExFreePool(pIrb);

  000f9	ff 75 f4	 push	 DWORD PTR _pIrb$[ebp]
  000fc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePool@4

; 1104 : 
; 1105 :             ntStatus = STATUS_INSUFFICIENT_RESOURCES;
; 1106 :             goto Exit_SetLocalHostProperties;

  00102	eb 5e		 jmp	 SHORT $L10752
$L9193:

; 1107 :         } // if
; 1108 : 
; 1109 :         TRACE(TL_TRACE, ("R0_SetLocalHostProps3 = 0x%x\n", R0_SetLocalHostProps3));
; 1110 : 
; 1111 :         // copy over the contents...
; 1112 :         RtlCopyMemory( R0_SetLocalHostProps3, 
; 1113 :                        SetLocalHostProps3, 
; 1114 :                        sizeof(SET_LOCAL_HOST_PROPS3)
; 1115 :                        );

  00104	8b 75 14	 mov	 esi, DWORD PTR _Information$[ebp]
  00107	8b f8		 mov	 edi, eax
  00109	a5		 movsd
  0010a	a5		 movsd
  0010b	a5		 movsd
  0010c	a5		 movsd

; 1116 : 
; 1117 :         // branch, depending if we are adding or removing
; 1118 :         if (R0_SetLocalHostProps3->fulFlags == SLHP_FLAG_ADD_CROM_DATA) {

  0010d	83 38 01	 cmp	 DWORD PTR [eax], 1
  00110	0f 85 93 00 00
	00		 jne	 $L10739

; 1119 : 
; 1120 :             // we are adding an entry. let's get our crom data struct...
; 1121 :             CromData = ExAllocatePool(NonPagedPool, sizeof(CROM_DATA));

  00116	68 57 64 6d 20	 push	 544040023		; 206d6457H
  0011b	6a 14		 push	 20			; 00000014H
  0011d	6a 00		 push	 0
  0011f	ff d3		 call	 ebx
  00121	8b d8		 mov	 ebx, eax

; 1122 : 
; 1123 :             if (!CromData) {

  00123	85 db		 test	 ebx, ebx
  00125	75 10		 jne	 SHORT $L9199

; 1124 : 
; 1125 :                 TRACE(TL_ERROR, ("Failed to allocate CromData!\n"));
; 1126 :                 if (pIrb)
; 1127 :                     ExFreePool(pIrb);

  00127	ff 75 f4	 push	 DWORD PTR _pIrb$[ebp]
  0012a	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__ExFreePool@4
  00130	ff d6		 call	 esi

; 1128 : 
; 1129 :                 if (R0_SetLocalHostProps3)
; 1130 :                     ExFreePool(R0_SetLocalHostProps3);

  00132	ff 75 f8	 push	 DWORD PTR _R0_SetLocalHostProps3$[ebp]

; 1131 : 
; 1132 :                 ntStatus = STATUS_INSUFFICIENT_RESOURCES;
; 1133 :                 goto Exit_SetLocalHostProperties;

  00135	eb 29		 jmp	 SHORT $L10751
$L9199:

; 1134 :             }
; 1135 : 
; 1136 :             // let's allocate our buffer...
; 1137 :             CromData->Buffer = ExAllocatePool(NonPagedPool, R0_SetLocalHostProps3->nLength);

  00137	8b 7d f8	 mov	 edi, DWORD PTR _R0_SetLocalHostProps3$[ebp]
  0013a	68 57 64 6d 20	 push	 544040023		; 206d6457H
  0013f	ff 77 08	 push	 DWORD PTR [edi+8]
  00142	6a 00		 push	 0
  00144	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExAllocatePoolWithTag@12

; 1138 : 
; 1139 :             TRACE(TL_TRACE, ("CromData->Buffer = 0x%x\n", CromData->Buffer));
; 1140 : 
; 1141 :             if (!CromData->Buffer) {

  0014a	85 c0		 test	 eax, eax
  0014c	89 43 0c	 mov	 DWORD PTR [ebx+12], eax
  0014f	75 1d		 jne	 SHORT $L9203

; 1142 : 
; 1143 :                 TRACE(TL_ERROR, ("Failed to allocate CromData->Buffer!\n"));
; 1144 :                 if (pIrb)
; 1145 :                     ExFreePool(pIrb);

  00151	ff 75 f4	 push	 DWORD PTR _pIrb$[ebp]
  00154	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__ExFreePool@4
  0015a	ff d6		 call	 esi

; 1146 : 
; 1147 :                 if (R0_SetLocalHostProps3)
; 1148 :                     ExFreePool(R0_SetLocalHostProps3);

  0015c	57		 push	 edi
  0015d	ff d6		 call	 esi

; 1149 : 
; 1150 :                 if (CromData)
; 1151 :                     ExFreePool(CromData);

  0015f	53		 push	 ebx
$L10751:
  00160	ff d6		 call	 esi
$L10752:

; 1152 : 
; 1153 :                 ntStatus = STATUS_INSUFFICIENT_RESOURCES;

  00162	c7 45 fc 9a 00
	00 c0		 mov	 DWORD PTR _ntStatus$[ebp], -1073741670 ; c000009aH

; 1154 :                 goto Exit_SetLocalHostProperties;

  00169	e9 73 01 00 00	 jmp	 $Exit_SetLocalHostProperties$9180
$L9203:

; 1155 :             }
; 1156 : 
; 1157 :             // copy over contents (mdl == ring 3 buffer)
; 1158 :             RtlCopyMemory(CromData->Buffer, &SetLocalHostProps3->Mdl, SetLocalHostProps3->nLength);

  0016e	8b 55 14	 mov	 edx, DWORD PTR _Information$[ebp]
  00171	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  00174	8b f8		 mov	 edi, eax
  00176	8b c1		 mov	 eax, ecx
  00178	c1 e9 02	 shr	 ecx, 2
  0017b	8d 72 0c	 lea	 esi, DWORD PTR [edx+12]
  0017e	f3 a5		 rep movsd
  00180	8b c8		 mov	 ecx, eax

; 1159 : 
; 1160 :             R0_SetLocalHostProps3->Mdl = IoAllocateMdl (CromData->Buffer,
; 1161 :                                                         R0_SetLocalHostProps3->nLength,
; 1162 :                                                         FALSE,
; 1163 :                                                         FALSE,
; 1164 :                                                         NULL);

  00182	33 c0		 xor	 eax, eax
  00184	50		 push	 eax
  00185	50		 push	 eax
  00186	83 e1 03	 and	 ecx, 3
  00189	f3 a4		 rep movsb
  0018b	8b 75 f8	 mov	 esi, DWORD PTR _R0_SetLocalHostProps3$[ebp]
  0018e	50		 push	 eax
  0018f	ff 76 08	 push	 DWORD PTR [esi+8]
  00192	ff 73 0c	 push	 DWORD PTR [ebx+12]
  00195	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoAllocateMdl@20

; 1165 : 
; 1166 :             MmBuildMdlForNonPagedPool(R0_SetLocalHostProps3->Mdl);

  0019b	50		 push	 eax
  0019c	89 46 0c	 mov	 DWORD PTR [esi+12], eax
  0019f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MmBuildMdlForNonPagedPool@4
  001a5	8b c6		 mov	 eax, esi
  001a7	eb 03		 jmp	 SHORT $L9197
$L10739:
  001a9	8b 5d 14	 mov	 ebx, DWORD PTR _CromData$[ebp]
$L9197:

; 1167 : 
; 1168 :             TRACE(TL_TRACE, ("Mdl = 0x%x\n", R0_SetLocalHostProps3->Mdl));
; 1169 :         }
; 1170 :         else if (SetLocalHostProps3->fulFlags == SLHP_FLAG_REMOVE_CROM_DATA) {
; 1171 : 
; 1172 :             TRACE(TL_TRACE, ("hCromData = 0x%x\n", R0_SetLocalHostProps3->hCromData));
; 1173 :         }
; 1174 : 
; 1175 :         pIrb->u.SetLocalHostProperties.Information = (PVOID)R0_SetLocalHostProps3;

  001ac	8b 4d f4	 mov	 ecx, DWORD PTR _pIrb$[ebp]
  001af	8b 75 fc	 mov	 esi, DWORD PTR _deviceExtension$[ebp]
  001b2	89 41 4c	 mov	 DWORD PTR [ecx+76], eax
  001b5	8b d1		 mov	 edx, ecx
  001b7	e9 dd fe ff ff	 jmp	 $L9189
$L9212:

; 1193 :         ntStatus = t1394_SubmitIrpSynch(deviceExtension->StackDeviceObject, Irp, pIrb);

  001bc	52		 push	 edx
  001bd	ff 75 0c	 push	 DWORD PTR _Irp$[ebp]
  001c0	ff 36		 push	 DWORD PTR [esi]
  001c2	e8 00 00 00 00	 call	 _t1394_SubmitIrpSynch@12
  001c7	33 ff		 xor	 edi, edi
$L10749:
  001c9	89 45 fc	 mov	 DWORD PTR _ntStatus$[ebp], eax
$L9216:

; 1194 :     }
; 1195 : 
; 1196 :     if (!NT_SUCCESS(ntStatus)) {

  001cc	39 7d fc	 cmp	 DWORD PTR _ntStatus$[ebp], edi
  001cf	7d 3b		 jge	 SHORT $L9218

; 1197 : 
; 1198 :         if (nLevel == SET_LOCAL_HOST_PROPERTIES_MODIFY_CROM) {

  001d1	83 7d 10 03	 cmp	 DWORD PTR _nLevel$[ebp], 3
  001d5	0f 85 fd 00 00
	00		 jne	 $L10745

; 1199 : 
; 1200 :             if (R0_SetLocalHostProps3->fulFlags == SLHP_FLAG_ADD_CROM_DATA) {

  001db	8b 75 f8	 mov	 esi, DWORD PTR _R0_SetLocalHostProps3$[ebp]
  001de	83 3e 01	 cmp	 DWORD PTR [esi], 1
  001e1	75 23		 jne	 SHORT $L10742

; 1201 : 
; 1202 :                 if (R0_SetLocalHostProps3->Mdl)

  001e3	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  001e6	3b c7		 cmp	 eax, edi
  001e8	74 07		 je	 SHORT $L10741

; 1203 :                     ExFreePool(R0_SetLocalHostProps3->Mdl);

  001ea	50		 push	 eax
  001eb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePool@4
$L10741:

; 1204 : 
; 1205 :                 if (CromData->Buffer)

  001f1	8b 43 0c	 mov	 eax, DWORD PTR [ebx+12]
  001f4	3b c7		 cmp	 eax, edi
  001f6	74 07		 je	 SHORT $L10747

; 1206 :                     ExFreePool(CromData->Buffer);

  001f8	50		 push	 eax
  001f9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePool@4
$L10747:

; 1207 : 
; 1208 :                 if (CromData)
; 1209 :                     ExFreePool(CromData);

  001ff	53		 push	 ebx
  00200	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePool@4
$L10742:

; 1210 :             }
; 1211 : 
; 1212 :             if (R0_SetLocalHostProps3)
; 1213 :                 ExFreePool(R0_SetLocalHostProps3);

  00206	56		 push	 esi

; 1214 :         }
; 1215 : 
; 1216 :         TRACE(TL_ERROR, ("SubmitIrpSync failed = 0x%x\n", ntStatus));
; 1217 :     }
; 1218 :     else {

  00207	e9 c6 00 00 00	 jmp	 $L10750
$L9218:

; 1219 : 
; 1220 :         if (nLevel == SET_LOCAL_HOST_PROPERTIES_MODIFY_CROM) {

  0020c	83 7d 10 03	 cmp	 DWORD PTR _nLevel$[ebp], 3
  00210	0f 85 c2 00 00
	00		 jne	 $L10745

; 1221 : 
; 1222 :             KIRQL           Irql;
; 1223 : 
; 1224 :             // branch, depending if we are adding or removing
; 1225 :             if (R0_SetLocalHostProps3->fulFlags == SLHP_FLAG_ADD_CROM_DATA) {

  00216	8b 7d f8	 mov	 edi, DWORD PTR _R0_SetLocalHostProps3$[ebp]
  00219	8b 07		 mov	 eax, DWORD PTR [edi]
  0021b	83 f8 01	 cmp	 eax, 1
  0021e	75 43		 jne	 SHORT $L9228

; 1226 : 
; 1227 :                 PSET_LOCAL_HOST_PROPS3  SetLocalHostProps3;
; 1228 : 
; 1229 :                 SetLocalHostProps3 = Information;
; 1230 :                 SetLocalHostProps3->hCromData = R0_SetLocalHostProps3->hCromData;
; 1231 : 
; 1232 :                 TRACE(TL_TRACE, ("hCromData = 0x%x\n", SetLocalHostProps3->hCromData));
; 1233 : 
; 1234 :                 if (CromData) {

  00220	85 db		 test	 ebx, ebx
  00222	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00225	8b 4d 14	 mov	 ecx, DWORD PTR _Information$[ebp]
  00228	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  0022b	0f 84 a0 00 00
	00		 je	 $L10744

; 1235 : 
; 1236 :                     CromData->hCromData = SetLocalHostProps3->hCromData;

  00231	89 43 08	 mov	 DWORD PTR [ebx+8], eax

; 1237 :                     CromData->pMdl = R0_SetLocalHostProps3->Mdl;

  00234	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]

; 1238 : 
; 1239 :                     // need to add to our list...
; 1240 :                     KeAcquireSpinLock(&deviceExtension->CromSpinLock, &Irql);

  00237	8d 7e 18	 lea	 edi, DWORD PTR [esi+24]
  0023a	8b cf		 mov	 ecx, edi
  0023c	89 43 10	 mov	 DWORD PTR [ebx+16], eax
  0023f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@KfAcquireSpinLock@4

; 1241 :                     InsertHeadList(&deviceExtension->CromData, &CromData->CromList);

  00245	8d 4e 40	 lea	 ecx, DWORD PTR [esi+64]
  00248	8b 31		 mov	 esi, DWORD PTR [ecx]
  0024a	89 4b 04	 mov	 DWORD PTR [ebx+4], ecx
  0024d	89 33		 mov	 DWORD PTR [ebx], esi
  0024f	89 5e 04	 mov	 DWORD PTR [esi+4], ebx
  00252	89 19		 mov	 DWORD PTR [ecx], ebx

; 1242 :                     KeReleaseSpinLock(&deviceExtension->CromSpinLock, Irql);

  00254	8a d0		 mov	 dl, al
  00256	8b cf		 mov	 ecx, edi
  00258	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@KfReleaseSpinLock@8

; 1243 :                 }
; 1244 :             }
; 1245 :             else if (R0_SetLocalHostProps3->fulFlags == SLHP_FLAG_REMOVE_CROM_DATA) {

  0025e	8b 7d f8	 mov	 edi, DWORD PTR _R0_SetLocalHostProps3$[ebp]
  00261	eb 6e		 jmp	 SHORT $L10744
$L9228:
  00263	83 f8 02	 cmp	 eax, 2
  00266	75 69		 jne	 SHORT $L10744

; 1246 : 
; 1247 :                 // have to find our struct...
; 1248 :                 KeAcquireSpinLock(&deviceExtension->CromSpinLock, &Irql);

  00268	8d 4e 18	 lea	 ecx, DWORD PTR [esi+24]
  0026b	89 4d 14	 mov	 DWORD PTR tv386[ebp], ecx
  0026e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@KfAcquireSpinLock@4

; 1249 : 
; 1250 :                 CromData = (PCROM_DATA) deviceExtension->CromData.Flink;

  00274	83 c6 40	 add	 esi, 64			; 00000040H
  00277	8b 1e		 mov	 ebx, DWORD PTR [esi]

; 1251 : 
; 1252 :                 while (CromData) {

  00279	85 db		 test	 ebx, ebx
  0027b	74 22		 je	 SHORT $L9236
  0027d	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
$L9235:

; 1253 : 
; 1254 :                     if (CromData->hCromData == R0_SetLocalHostProps3->hCromData) {

  00280	39 4b 08	 cmp	 DWORD PTR [ebx+8], ecx
  00283	74 0c		 je	 SHORT $L10736

; 1258 :                     }
; 1259 :                     else if (CromData->CromList.Flink == &deviceExtension->CromData) {

  00285	8b 1b		 mov	 ebx, DWORD PTR [ebx]
  00287	3b de		 cmp	 ebx, esi
  00289	74 12		 je	 SHORT $L10737

; 1251 : 
; 1252 :                 while (CromData) {

  0028b	85 db		 test	 ebx, ebx
  0028d	75 f1		 jne	 SHORT $L9235

; 1258 :                     }
; 1259 :                     else if (CromData->CromList.Flink == &deviceExtension->CromData) {

  0028f	eb 0e		 jmp	 SHORT $L9236
$L10736:

; 1255 : 
; 1256 :                         RemoveEntryList(&CromData->CromList);

  00291	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  00293	8b 73 04	 mov	 esi, DWORD PTR [ebx+4]
  00296	89 0e		 mov	 DWORD PTR [esi], ecx
  00298	89 71 04	 mov	 DWORD PTR [ecx+4], esi

; 1257 :                         break;

  0029b	eb 02		 jmp	 SHORT $L9236
$L10737:

; 1260 : 
; 1261 :                         CromData = NULL;

  0029d	33 db		 xor	 ebx, ebx
$L9236:

; 1262 :                         break;
; 1263 :                     }
; 1264 :                     else
; 1265 :                         CromData = (PCROM_DATA)CromData->CromList.Flink;
; 1266 :                 }
; 1267 : 
; 1268 :                 KeReleaseSpinLock(&deviceExtension->CromSpinLock, Irql);

  0029f	8b 4d 14	 mov	 ecx, DWORD PTR tv386[ebp]
  002a2	8a d0		 mov	 dl, al
  002a4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@KfReleaseSpinLock@8

; 1269 : 
; 1270 :                 if (CromData) {

  002aa	85 db		 test	 ebx, ebx
  002ac	74 23		 je	 SHORT $L10744

; 1271 : 
; 1272 :                     if (CromData->Buffer)

  002ae	8b 43 0c	 mov	 eax, DWORD PTR [ebx+12]
  002b1	85 c0		 test	 eax, eax
  002b3	74 07		 je	 SHORT $L10743

; 1273 :                         ExFreePool(CromData->Buffer);

  002b5	50		 push	 eax
  002b6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePool@4
$L10743:

; 1274 : 
; 1275 :                     if (CromData->pMdl)

  002bc	8b 43 10	 mov	 eax, DWORD PTR [ebx+16]
  002bf	85 c0		 test	 eax, eax
  002c1	74 07		 je	 SHORT $L10748

; 1276 :                         ExFreePool(CromData->pMdl);

  002c3	50		 push	 eax
  002c4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePool@4
$L10748:

; 1277 : 
; 1278 :                     ExFreePool(CromData);

  002ca	53		 push	 ebx
  002cb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePool@4
$L10744:

; 1279 :                 }
; 1280 :             }
; 1281 : 
; 1282 :             if (R0_SetLocalHostProps3)
; 1283 :                 ExFreePool(R0_SetLocalHostProps3);

  002d1	57		 push	 edi
$L10750:
  002d2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePool@4
$L10745:

; 1284 :         }
; 1285 :     }
; 1286 : 
; 1287 :     if (pIrb)
; 1288 :         ExFreePool(pIrb);

  002d8	ff 75 f4	 push	 DWORD PTR _pIrb$[ebp]
  002db	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePool@4
$Exit_SetLocalHostProperties$9180:

; 1289 : 
; 1290 : Exit_SetLocalHostProperties:
; 1291 : 
; 1292 :     if (allocNewIrp) 

  002e1	80 7d 0b 00	 cmp	 BYTE PTR _allocNewIrp$[ebp], 0
  002e5	5b		 pop	 ebx
  002e6	74 0f		 je	 SHORT $L10746

; 1293 :         Irp->IoStatus = ioStatus;

  002e8	8b 4d e8	 mov	 ecx, DWORD PTR _ioStatus$[ebp]
  002eb	8b 45 0c	 mov	 eax, DWORD PTR _Irp$[ebp]
  002ee	89 48 18	 mov	 DWORD PTR [eax+24], ecx
  002f1	8b 4d ec	 mov	 ecx, DWORD PTR _ioStatus$[ebp+4]
  002f4	89 48 1c	 mov	 DWORD PTR [eax+28], ecx
$L10746:

; 1294 :         
; 1295 :     EXIT("t1394_SetLocalHostProperties", ntStatus);
; 1296 :     return(ntStatus);

  002f7	8b 45 fc	 mov	 eax, DWORD PTR _ntStatus$[ebp]
  002fa	5f		 pop	 edi
  002fb	5e		 pop	 esi

; 1297 : } // t1394_SetLocalHostProperties

  002fc	c9		 leave
  002fd	c2 10 00	 ret	 16			; 00000010H
_t1394_SetLocalHostProperties@16 ENDP
_TEXT	ENDS
PUBLIC	_t1394_BusResetRoutine@4
EXTRN	__imp_@InterlockedExchange@8:NEAR
EXTRN	_IoAllocateWorkItem@4:NEAR
EXTRN	_IoQueueWorkItem@16:NEAR
; Function compile flags: /Ogsy
;	COMDAT _t1394_BusResetRoutine@4
_TEXT	SEGMENT
_Context$ = 8						; size = 4
_t1394_BusResetRoutine@4 PROC NEAR			; COMDAT

; 1304 :     PDEVICE_OBJECT      DeviceObject 	= Context;
; 1305 :     PDEVICE_EXTENSION   deviceExtension = DeviceObject->DeviceExtension;

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _Context$[esp-4]
  00004	56		 push	 esi
  00005	8b 70 28	 mov	 esi, DWORD PTR [eax+40]

; 1306 : 	PIO_WORKITEM		ioWorkItem		= NULL;
; 1307 : 	NTSTATUS            ntStatus 		= STATUS_SUCCESS;
; 1308 :     PBUS_RESET_IRP      BusResetIrp		= NULL;
; 1309 :     PDRIVER_CANCEL      prevCancel 		= NULL;
; 1310 :     KIRQL               Irql;
; 1311 : 
; 1312 :     ENTER("t1394_BusResetRoutine");
; 1313 : 
; 1314 :     TRACE(TL_TRACE, ("Context = 0x%x\n", Context));
; 1315 : 
; 1316 : 	// make sure our device is still around
; 1317 :     if (deviceExtension->bShutdown)

  00008	80 7e 28 00	 cmp	 BYTE PTR [esi+40], 0
  0000c	75 70		 jne	 SHORT $Exit_BusResetRoutine$9264

; 1318 :     {
; 1319 :         goto Exit_BusResetRoutine;
; 1320 :     }
; 1321 : 
; 1322 : 	// need to update the generation count, queue a work item to do that
; 1323 : 	ioWorkItem = IoAllocateWorkItem (DeviceObject);

  0000e	50		 push	 eax
  0000f	e8 00 00 00 00	 call	 _IoAllocateWorkItem@4

; 1324 : 	if (!ioWorkItem)

  00014	85 c0		 test	 eax, eax
  00016	74 66		 je	 SHORT $Exit_BusResetRoutine$9264
  00018	53		 push	 ebx
  00019	55		 push	 ebp

; 1325 : 	{
; 1326 : 		TRACE(TL_ERROR, ("t1394_BusResetRoutine: Failed to allocate work item!\n"));
; 1327 : 		goto Exit_BusResetRoutine;
; 1328 : 	}
; 1329 : 
; 1330 : 	IoQueueWorkItem (ioWorkItem,
; 1331 : 						t1394_UpdateGenerationCount,
; 1332 : 						DelayedWorkQueue,
; 1333 : 						ioWorkItem);

  0001a	50		 push	 eax
  0001b	6a 01		 push	 1
  0001d	68 00 00 00 00	 push	 OFFSET FLAT:_t1394_UpdateGenerationCount@8
  00022	50		 push	 eax
  00023	e8 00 00 00 00	 call	 _IoQueueWorkItem@16

; 1334 : 
; 1335 :     // if we have any bus reset notify irps, then nows the time to complete them
; 1336 :     KeAcquireSpinLock(&deviceExtension->ResetSpinLock, &Irql);

  00028	8d 6e 14	 lea	 ebp, DWORD PTR [esi+20]
  0002b	8b cd		 mov	 ecx, ebp
  0002d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@KfAcquireSpinLock@4

; 1337 :     while (!IsListEmpty(&deviceExtension->BusResetIrps)) 

  00033	83 c6 38	 add	 esi, 56			; 00000038H
  00036	39 36		 cmp	 DWORD PTR [esi], esi
  00038	8a d8		 mov	 bl, al
  0003a	74 36		 je	 SHORT $L9268
  0003c	57		 push	 edi
$L9267:

; 1338 :     {
; 1339 :         // get the irp off of the list
; 1340 :         BusResetIrp = (PBUS_RESET_IRP)RemoveHeadList(&deviceExtension->BusResetIrps);

  0003d	8b 3e		 mov	 edi, DWORD PTR [esi]
  0003f	8b 07		 mov	 eax, DWORD PTR [edi]
  00041	89 06		 mov	 DWORD PTR [esi], eax
  00043	89 70 04	 mov	 DWORD PTR [eax+4], esi

; 1341 : 
; 1342 :         TRACE(TL_TRACE, ("BusResetIrp = 0x%x\n", BusResetIrp));
; 1343 : 
; 1344 :         // make this irp non-cancelable...
; 1345 :         prevCancel = IoSetCancelRoutine(BusResetIrp->Irp, NULL);

  00046	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  00049	83 c1 38	 add	 ecx, 56			; 00000038H
  0004c	33 d2		 xor	 edx, edx
  0004e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@InterlockedExchange@8

; 1346 : 
; 1347 :         TRACE(TL_TRACE, ("Completing BusResetIrp->Irp = 0x%x\n", BusResetIrp->Irp));
; 1348 : 
; 1349 :         // and complete it...
; 1350 :         BusResetIrp->Irp->IoStatus.Status = STATUS_SUCCESS;

  00054	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  00057	83 60 18 00	 and	 DWORD PTR [eax+24], 0

; 1351 :         IoCompleteRequest(BusResetIrp->Irp, IO_NO_INCREMENT);

  0005b	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  0005e	32 d2		 xor	 dl, dl
  00060	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@IofCompleteRequest@8

; 1352 :         ExFreePool(BusResetIrp);

  00066	57		 push	 edi
  00067	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePool@4
  0006d	39 36		 cmp	 DWORD PTR [esi], esi
  0006f	75 cc		 jne	 SHORT $L9267
  00071	5f		 pop	 edi
$L9268:

; 1353 :     }
; 1354 :     KeReleaseSpinLock(&deviceExtension->ResetSpinLock, Irql);

  00072	8a d3		 mov	 dl, bl
  00074	8b cd		 mov	 ecx, ebp
  00076	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@KfReleaseSpinLock@8
  0007c	5d		 pop	 ebp
  0007d	5b		 pop	 ebx
$Exit_BusResetRoutine$9264:
  0007e	5e		 pop	 esi

; 1355 : 
; 1356 : Exit_BusResetRoutine:
; 1357 : 
; 1358 :     EXIT("t1394_BusResetRoutine", ntStatus);
; 1359 : } // t1394_BusResetRoutine

  0007f	c2 04 00	 ret	 4
_t1394_BusResetRoutine@4 ENDP
_TEXT	ENDS
PUBLIC	_t1394_BusResetNotification@12
; Function compile flags: /Ogsy
;	COMDAT _t1394_BusResetNotification@12
_TEXT	SEGMENT
_Event$ = -32						; size = 16
_ioStatus$ = -16					; size = 8
_newIrp$ = -8						; size = 4
_allocNewIrp$ = -1					; size = 1
_DeviceObject$ = 8					; size = 4
_Irp$ = 12						; size = 4
_fulFlags$ = 16						; size = 4
_t1394_BusResetNotification@12 PROC NEAR		; COMDAT

; 1368 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H

; 1369 :     NTSTATUS            ntStatus = STATUS_SUCCESS;
; 1370 :     PDEVICE_EXTENSION   deviceExtension = DeviceObject->DeviceExtension;

  00006	8b 45 08	 mov	 eax, DWORD PTR _DeviceObject$[ebp]
  00009	53		 push	 ebx
  0000a	8b 58 28	 mov	 ebx, DWORD PTR [eax+40]

; 1371 :     PIRB                pIrb;
; 1372 : 
; 1373 :     PIRP                newIrp;
; 1374 :     BOOLEAN             allocNewIrp = FALSE;
; 1375 :     KEVENT              Event;
; 1376 :     IO_STATUS_BLOCK     ioStatus;
; 1377 :     
; 1378 :     ENTER("t1394_BusResetNotification");
; 1379 : 
; 1380 :     TRACE(TL_TRACE, ("fulFlags = 0x%x\n", fulFlags));
; 1381 : 
; 1382 :     //
; 1383 :     // If this is a UserMode request create a newIrp so that the request
; 1384 :     // will be issued from KernelMode
; 1385 :     //
; 1386 :     if (Irp->RequestorMode == UserMode) {

  0000d	8b 45 0c	 mov	 eax, DWORD PTR _Irp$[ebp]
  00010	57		 push	 edi

; 1387 : 
; 1388 :         newIrp = IoBuildDeviceIoControlRequest (IOCTL_1394_CLASS, deviceExtension->StackDeviceObject, 
; 1389 :                             NULL, 0, NULL, 0, TRUE, &Event, &ioStatus);

  00011	33 ff		 xor	 edi, edi
  00013	80 78 20 01	 cmp	 BYTE PTR [eax+32], 1
  00017	c6 45 ff 00	 mov	 BYTE PTR _allocNewIrp$[ebp], 0
  0001b	75 30		 jne	 SHORT $L9295
  0001d	8d 45 f0	 lea	 eax, DWORD PTR _ioStatus$[ebp]
  00020	50		 push	 eax
  00021	8d 45 e0	 lea	 eax, DWORD PTR _Event$[ebp]
  00024	50		 push	 eax
  00025	6a 01		 push	 1
  00027	57		 push	 edi
  00028	57		 push	 edi
  00029	57		 push	 edi
  0002a	57		 push	 edi
  0002b	ff 33		 push	 DWORD PTR [ebx]
  0002d	68 1d 02 22 00	 push	 2228765			; 0022021dH
  00032	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoBuildDeviceIoControlRequest@36

; 1390 : 
; 1391 :         if (!newIrp) {

  00038	3b c7		 cmp	 eax, edi
  0003a	89 45 f8	 mov	 DWORD PTR _newIrp$[ebp], eax
  0003d	75 0a		 jne	 SHORT $L9298

; 1392 : 
; 1393 :             TRACE(TL_ERROR, ("Failed to allocate newIrp!\n"));        
; 1394 :             ntStatus = STATUS_INSUFFICIENT_RESOURCES;

  0003f	bb 9a 00 00 c0	 mov	 ebx, -1073741670	; c000009aH

; 1395 :             goto Exit_BusResetNotification;            

  00044	e9 ae 00 00 00	 jmp	 $L9313
$L9298:

; 1396 :         }
; 1397 :         allocNewIrp = TRUE;

  00049	c6 45 ff 01	 mov	 BYTE PTR _allocNewIrp$[ebp], 1
$L9295:
  0004d	56		 push	 esi

; 1398 :     }
; 1399 :     
; 1400 :     pIrb = ExAllocatePool(NonPagedPool, sizeof(IRB));

  0004e	68 57 64 6d 20	 push	 544040023		; 206d6457H
  00053	68 58 01 00 00	 push	 344			; 00000158H
  00058	57		 push	 edi
  00059	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExAllocatePoolWithTag@12
  0005f	8b f0		 mov	 esi, eax

; 1401 : 
; 1402 :     if (!pIrb) {

  00061	3b f7		 cmp	 esi, edi
  00063	75 07		 jne	 SHORT $L9302

; 1403 : 
; 1404 :         TRACE(TL_ERROR, ("Failed to allocate pIrb!\n"));
; 1405 :         ntStatus = STATUS_INSUFFICIENT_RESOURCES;

  00065	bb 9a 00 00 c0	 mov	 ebx, -1073741670	; c000009aH

; 1406 :         goto Exit_BusResetNotification;

  0006a	eb 75		 jmp	 SHORT $Exit_BusResetNotification$9300
$L9302:

; 1407 :     } // if
; 1408 : 
; 1409 :     RtlZeroMemory (pIrb, sizeof (IRB));

  0006c	33 c0		 xor	 eax, eax
  0006e	6a 56		 push	 86			; 00000056H
  00070	59		 pop	 ecx
  00071	8b fe		 mov	 edi, esi
  00073	f3 ab		 rep stosd

; 1410 :     pIrb->FunctionNumber = REQUEST_BUS_RESET_NOTIFICATION;
; 1411 :     pIrb->Flags = 0;
; 1412 :     pIrb->u.BusResetNotification.fulFlags = fulFlags;

  00075	8b 45 10	 mov	 eax, DWORD PTR _fulFlags$[ebp]
  00078	33 ff		 xor	 edi, edi

; 1413 :     pIrb->u.BusResetNotification.ResetRoutine = t1394_BusResetRoutine;
; 1414 :     pIrb->u.BusResetNotification.ResetContext = DeviceObject;
; 1415 : 
; 1416 :     //
; 1417 :     // If we allocated this irp, submit it asynchronously and wait for its
; 1418 :     // completion event to be signaled.  Otherwise submit it synchronously
; 1419 :     //
; 1420 :     if (allocNewIrp) {

  0007a	80 7d ff 00	 cmp	 BYTE PTR _allocNewIrp$[ebp], 0
  0007e	89 46 48	 mov	 DWORD PTR [esi+72], eax
  00081	8b 45 08	 mov	 eax, DWORD PTR _DeviceObject$[ebp]
  00084	c7 06 1d 00 00
	00		 mov	 DWORD PTR [esi], 29	; 0000001dH
  0008a	89 7e 04	 mov	 DWORD PTR [esi+4], edi
  0008d	c7 46 4c 00 00
	00 00		 mov	 DWORD PTR [esi+76], OFFSET FLAT:_t1394_BusResetRoutine@4
  00094	89 46 50	 mov	 DWORD PTR [esi+80], eax
  00097	74 34		 je	 SHORT $L9305

; 1421 : 
; 1422 :         KeInitializeEvent (&Event, NotificationEvent, FALSE);

  00099	57		 push	 edi
  0009a	57		 push	 edi
  0009b	8d 45 e0	 lea	 eax, DWORD PTR _Event$[ebp]
  0009e	50		 push	 eax
  0009f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeInitializeEvent@12

; 1423 :         ntStatus = t1394_SubmitIrpAsync (deviceExtension->StackDeviceObject, newIrp, pIrb);

  000a5	56		 push	 esi
  000a6	ff 75 f8	 push	 DWORD PTR _newIrp$[ebp]
  000a9	ff 33		 push	 DWORD PTR [ebx]
  000ab	e8 00 00 00 00	 call	 _t1394_SubmitIrpAsync@12
  000b0	8b d8		 mov	 ebx, eax

; 1424 : 
; 1425 :         if (ntStatus == STATUS_PENDING) {

  000b2	81 fb 03 01 00
	00		 cmp	 ebx, 259		; 00000103H
  000b8	75 20		 jne	 SHORT $L9309

; 1426 :             KeWaitForSingleObject (&Event, Executive, KernelMode, FALSE, NULL); 

  000ba	57		 push	 edi
  000bb	57		 push	 edi
  000bc	57		 push	 edi
  000bd	57		 push	 edi
  000be	8d 45 e0	 lea	 eax, DWORD PTR _Event$[ebp]
  000c1	50		 push	 eax
  000c2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeWaitForSingleObject@20

; 1427 :             ntStatus = ioStatus.Status;

  000c8	8b 5d f0	 mov	 ebx, DWORD PTR _ioStatus$[ebp]

; 1428 :         }
; 1429 :     }
; 1430 :     else {

  000cb	eb 0d		 jmp	 SHORT $L9309
$L9305:

; 1431 :         ntStatus = t1394_SubmitIrpSynch(deviceExtension->StackDeviceObject, Irp, pIrb);

  000cd	56		 push	 esi
  000ce	ff 75 0c	 push	 DWORD PTR _Irp$[ebp]
  000d1	ff 33		 push	 DWORD PTR [ebx]
  000d3	e8 00 00 00 00	 call	 _t1394_SubmitIrpSynch@12
  000d8	8b d8		 mov	 ebx, eax
$L9309:

; 1432 :     }
; 1433 :     
; 1434 :     if (!NT_SUCCESS(ntStatus)) {
; 1435 : 
; 1436 :         TRACE(TL_ERROR, ("SubmitIrpSync failed = 0x%x\n", ntStatus));
; 1437 :     }
; 1438 : 
; 1439 :     if (pIrb)
; 1440 :         ExFreePool(pIrb);

  000da	56		 push	 esi
  000db	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePool@4
$Exit_BusResetNotification$9300:

; 1441 : 
; 1442 : Exit_BusResetNotification:
; 1443 : 
; 1444 :     if (allocNewIrp) 

  000e1	80 7d ff 00	 cmp	 BYTE PTR _allocNewIrp$[ebp], 0
  000e5	5e		 pop	 esi
  000e6	74 0f		 je	 SHORT $L9313

; 1445 :         Irp->IoStatus = ioStatus;

  000e8	8b 4d f0	 mov	 ecx, DWORD PTR _ioStatus$[ebp]
  000eb	8b 45 0c	 mov	 eax, DWORD PTR _Irp$[ebp]
  000ee	89 48 18	 mov	 DWORD PTR [eax+24], ecx
  000f1	8b 4d f4	 mov	 ecx, DWORD PTR _ioStatus$[ebp+4]
  000f4	89 48 1c	 mov	 DWORD PTR [eax+28], ecx
$L9313:
  000f7	5f		 pop	 edi

; 1446 :         
; 1447 :     EXIT("t1394_BusResetNotification", ntStatus);
; 1448 :     return(ntStatus);

  000f8	8b c3		 mov	 eax, ebx
  000fa	5b		 pop	 ebx

; 1449 : } // t1394_BusResetNotification

  000fb	c9		 leave
  000fc	c2 0c 00	 ret	 12			; 0000000cH
_t1394_BusResetNotification@12 ENDP
_TEXT	ENDS
PUBLIC	_t1394_AllocateAddressRange@44
; Function compile flags: /Ogsy
; File d:\srv03rtm\drivers\wdm\1394\tools\test\driver\common\asyncapi.c
;	COMDAT _t1394_AllocateAddressRange@44
_TEXT	SEGMENT
_Event$ = -36						; size = 16
_ioStatus$ = -20					; size = 8
_newIrp$ = -12						; size = 4
_deviceExtension$ = -8					; size = 4
_pAsyncAddressData$ = -4				; size = 4
_DeviceObject$ = 8					; size = 4
_allocNewIrp$ = 11					; size = 1
_Irp$ = 12						; size = 4
_fulAllocateFlags$ = 16					; size = 4
_fulFlags$ = 20						; size = 4
_ntStatus$ = 24						; size = 4
_nLength$ = 24						; size = 4
tv407 = 28						; size = 4
_MaxSegmentSize$ = 28					; size = 4
_fulAccessType$ = 32					; size = 4
_fulNotificationOptions$ = 36				; size = 4
_Required1394Offset$ = 40				; size = 4
_phAddressRange$ = 44					; size = 4
_Data$ = 48						; size = 4
_t1394_AllocateAddressRange@44 PROC NEAR		; COMDAT

; 36   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H

; 37   :     NTSTATUS                ntStatus        = STATUS_SUCCESS;
; 38   :     PDEVICE_EXTENSION       deviceExtension = DeviceObject->DeviceExtension;

  00006	8b 45 08	 mov	 eax, DWORD PTR _DeviceObject$[ebp]
  00009	8b 40 28	 mov	 eax, DWORD PTR [eax+40]
  0000c	56		 push	 esi

; 39   :     PIRB                    pIrb            = NULL;
; 40   :     PASYNC_ADDRESS_DATA     pAsyncAddressData;
; 41   :     KIRQL                   Irql;
; 42   :     ULONG                   nPages;
; 43   : 
; 44   :     PIRP                    newIrp;
; 45   :     BOOLEAN                 allocNewIrp = FALSE;
; 46   :     KEVENT                  Event;
; 47   :     IO_STATUS_BLOCK         ioStatus;
; 48   :     
; 49   :     ENTER("t1394_AllocateAddressRange");
; 50   : 
; 51   :     TRACE(TL_TRACE, ("fulAllocateFlags = 0x%x\n", fulAllocateFlags));
; 52   :     TRACE(TL_TRACE, ("fulFlags = 0x%x\n", fulFlags));
; 53   :     TRACE(TL_TRACE, ("nLength = 0x%x\n", nLength));
; 54   :     TRACE(TL_TRACE, ("MaxSegmentSize = 0x%x\n", MaxSegmentSize));
; 55   :     TRACE(TL_TRACE, ("fulAccessType = 0x%x\n", fulAccessType));
; 56   :     TRACE(TL_TRACE, ("fulNotificationOptions = 0x%x\n", fulNotificationOptions));
; 57   :     TRACE(TL_TRACE, ("Required1394Offset->Off_High = 0x%x\n", Required1394Offset->Off_High));
; 58   :     TRACE(TL_TRACE, ("Required1394Offset->Off_Low = 0x%x\n", Required1394Offset->Off_Low));
; 59   :     TRACE(TL_TRACE, ("Data = 0x%x\n", Data));
; 60   : 
; 61   :     if (nLength == 0) {

  0000d	33 f6		 xor	 esi, esi
  0000f	39 75 18	 cmp	 DWORD PTR _nLength$[ebp], esi
  00012	89 45 f8	 mov	 DWORD PTR _deviceExtension$[ebp], eax
  00015	c6 45 0b 00	 mov	 BYTE PTR _allocNewIrp$[ebp], 0
  00019	75 0c		 jne	 SHORT $L9350

; 62   : 
; 63   :         TRACE(TL_ERROR, ("Invalid nLength!\n"));
; 64   :         ntStatus = STATUS_INVALID_PARAMETER;

  0001b	c7 45 18 0d 00
	00 c0		 mov	 DWORD PTR _ntStatus$[ebp], -1073741811 ; c000000dH

; 65   :         goto Exit_AllocateAddressRange;

  00022	e9 91 02 00 00	 jmp	 $L10782
$L9350:

; 66   :     }
; 67   : 
; 68   :     //
; 69   :     // If this is a UserMode request create a newIrp so that the request
; 70   :     // will be issued from KernelMode
; 71   :     //
; 72   :     if (Irp->RequestorMode == UserMode) {

  00027	8b 4d 0c	 mov	 ecx, DWORD PTR _Irp$[ebp]
  0002a	80 79 20 01	 cmp	 BYTE PTR [ecx+32], 1
  0002e	75 32		 jne	 SHORT $L10778

; 73   : 
; 74   :         newIrp = IoBuildDeviceIoControlRequest (IOCTL_1394_CLASS, deviceExtension->StackDeviceObject, 
; 75   :                             NULL, 0, NULL, 0, TRUE, &Event, &ioStatus);

  00030	8d 4d ec	 lea	 ecx, DWORD PTR _ioStatus$[ebp]
  00033	51		 push	 ecx
  00034	8d 4d dc	 lea	 ecx, DWORD PTR _Event$[ebp]
  00037	51		 push	 ecx
  00038	6a 01		 push	 1
  0003a	56		 push	 esi
  0003b	56		 push	 esi
  0003c	56		 push	 esi
  0003d	56		 push	 esi
  0003e	ff 30		 push	 DWORD PTR [eax]
  00040	68 1d 02 22 00	 push	 2228765			; 0022021dH
  00045	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoBuildDeviceIoControlRequest@36

; 76   : 
; 77   :         if (!newIrp) {

  0004b	3b c6		 cmp	 eax, esi
  0004d	89 45 f4	 mov	 DWORD PTR _newIrp$[ebp], eax
  00050	75 0c		 jne	 SHORT $L9356

; 78   : 
; 79   :             TRACE(TL_ERROR, ("Failed to allocate newIrp!\n"));        
; 80   :             ntStatus = STATUS_INSUFFICIENT_RESOURCES;

  00052	c7 45 18 9a 00
	00 c0		 mov	 DWORD PTR _ntStatus$[ebp], -1073741670 ; c000009aH

; 81   :             goto Exit_AllocateAddressRange;            

  00059	e9 5a 02 00 00	 jmp	 $L10782
$L9356:

; 82   :         }
; 83   :         allocNewIrp = TRUE;

  0005e	c6 45 0b 01	 mov	 BYTE PTR _allocNewIrp$[ebp], 1
$L10778:
  00062	53		 push	 ebx
  00063	57		 push	 edi

; 84   :     }
; 85   : 
; 86   :     pIrb = ExAllocatePool(NonPagedPool, sizeof(IRB));

  00064	bf 57 64 6d 20	 mov	 edi, 544040023		; 206d6457H
  00069	57		 push	 edi
  0006a	68 58 01 00 00	 push	 344			; 00000158H
  0006f	56		 push	 esi
  00070	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__ExAllocatePoolWithTag@12
  00076	ff d6		 call	 esi
  00078	8b d8		 mov	 ebx, eax

; 87   :     
; 88   :     if (!pIrb) {

  0007a	85 db		 test	 ebx, ebx

; 89   : 
; 90   :         TRACE(TL_ERROR, ("Failed to allocate pIrb!\n"));
; 91   :         ntStatus = STATUS_INSUFFICIENT_RESOURCES;
; 92   :         goto Exit_AllocateAddressRange;

  0007c	0f 84 a9 00 00
	00		 je	 $L10788

; 93   :     } // if
; 94   : 
; 95   :     pAsyncAddressData = ExAllocatePool(NonPagedPool, sizeof(ASYNC_ADDRESS_DATA));

  00082	57		 push	 edi
  00083	6a 24		 push	 36			; 00000024H
  00085	6a 00		 push	 0
  00087	ff d6		 call	 esi
  00089	8b f8		 mov	 edi, eax

; 96   : 
; 97   :     if (!pAsyncAddressData) {

  0008b	85 ff		 test	 edi, edi
  0008d	89 7d fc	 mov	 DWORD PTR _pAsyncAddressData$[ebp], edi

; 98   : 
; 99   :         TRACE(TL_ERROR, ("Failed to allocate pAsyncAddressData!\n"));
; 100  :         ntStatus = STATUS_INSUFFICIENT_RESOURCES;
; 101  :         goto Exit_AllocateAddressRange;

  00090	0f 84 95 00 00
	00		 je	 $L10788

; 102  :     }
; 103  : 
; 104  :     pAsyncAddressData->Buffer = ExAllocatePool(NonPagedPool, nLength);

  00096	68 57 64 6d 20	 push	 544040023		; 206d6457H
  0009b	ff 75 18	 push	 DWORD PTR _nLength$[ebp]
  0009e	6a 00		 push	 0
  000a0	ff d6		 call	 esi

; 105  : 
; 106  :     TRACE(TL_TRACE, ("pAsyncAddressData->Buffer = 0x%x\n", pAsyncAddressData->Buffer));
; 107  : 
; 108  :     if (!pAsyncAddressData->Buffer) {

  000a2	85 c0		 test	 eax, eax
  000a4	89 47 0c	 mov	 DWORD PTR [edi+12], eax

; 109  : 
; 110  :         TRACE(TL_ERROR, ("Failed to allocate Buffer!\n"));
; 111  :         if (pAsyncAddressData)
; 112  :             ExFreePool(pAsyncAddressData);
; 113  : 
; 114  :         ntStatus = STATUS_INSUFFICIENT_RESOURCES;
; 115  :         goto Exit_AllocateAddressRange;

  000a7	74 7b		 je	 SHORT $L10783

; 116  :     }
; 117  : 
; 118  :     // we need to know how big our address range buffer will be, depends on maxSegmentSize
; 119  :     if ((0 == MaxSegmentSize) || (PAGE_SIZE == MaxSegmentSize))

  000a9	83 7d 1c 00	 cmp	 DWORD PTR _MaxSegmentSize$[ebp], 0
  000ad	74 18		 je	 SHORT $L9368
  000af	81 7d 1c 00 10
	00 00		 cmp	 DWORD PTR _MaxSegmentSize$[ebp], 4096 ; 00001000H
  000b6	74 0f		 je	 SHORT $L9368

; 122  :     }
; 123  :     else
; 124  :     {
; 125  :         // check to see if MaxSegmentSize divides nLength evenly or not
; 126  :         nPages = (nLength % MaxSegmentSize) ? nLength / MaxSegmentSize + 1 : nLength / MaxSegmentSize;

  000b8	8b 45 18	 mov	 eax, DWORD PTR _nLength$[ebp]
  000bb	33 d2		 xor	 edx, edx
  000bd	f7 75 1c	 div	 DWORD PTR _MaxSegmentSize$[ebp]
  000c0	85 d2		 test	 edx, edx
  000c2	74 18		 je	 SHORT $L9371
  000c4	40		 inc	 eax
  000c5	eb 15		 jmp	 SHORT $L9371
$L9368:

; 120  :     {
; 121  :         nPages = ADDRESS_AND_SIZE_TO_SPAN_PAGES(Data, nLength);

  000c7	8b 45 30	 mov	 eax, DWORD PTR _Data$[ebp]
  000ca	8b 4d 18	 mov	 ecx, DWORD PTR _nLength$[ebp]
  000cd	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  000d2	8d 84 08 ff 0f
	00 00		 lea	 eax, DWORD PTR [eax+ecx+4095]
  000d9	c1 e8 0c	 shr	 eax, 12			; 0000000cH
$L9371:

; 127  :     }
; 128  : 
; 129  :     TRACE(TL_TRACE, ("nPages = 0x%x\n", nPages));
; 130  : 
; 131  :     pAsyncAddressData->AddressRange = ExAllocatePool(NonPagedPool, sizeof(ADDRESS_RANGE)*nPages);

  000dc	68 57 64 6d 20	 push	 544040023		; 206d6457H
  000e1	c1 e0 03	 shl	 eax, 3
  000e4	50		 push	 eax
  000e5	6a 00		 push	 0
  000e7	ff d6		 call	 esi

; 132  : 
; 133  :     if (!pAsyncAddressData->AddressRange) {

  000e9	33 f6		 xor	 esi, esi
  000eb	3b c6		 cmp	 eax, esi
  000ed	89 47 18	 mov	 DWORD PTR [edi+24], eax

; 134  : 
; 135  :         TRACE(TL_ERROR, ("Failed to allocate AddressRange!\n"));
; 136  :         if (pAsyncAddressData->Buffer)
; 137  :             ExFreePool(pAsyncAddressData->Buffer);
; 138  : 
; 139  :         if (pAsyncAddressData)
; 140  :             ExFreePool(pAsyncAddressData);
; 141  : 
; 142  :         ntStatus = STATUS_INSUFFICIENT_RESOURCES;
; 143  :         goto Exit_AllocateAddressRange;

  000f0	74 24		 je	 SHORT $L10780

; 144  :     }
; 145  : 
; 146  :     pAsyncAddressData->pMdl = IoAllocateMdl (pAsyncAddressData->Buffer,
; 147  :                                              nLength,
; 148  :                                              FALSE,
; 149  :                                              FALSE,
; 150  :                                              NULL);

  000f2	56		 push	 esi
  000f3	56		 push	 esi
  000f4	56		 push	 esi
  000f5	ff 75 18	 push	 DWORD PTR _nLength$[ebp]
  000f8	ff 77 0c	 push	 DWORD PTR [edi+12]
  000fb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoAllocateMdl@20

; 151  : 
; 152  :     if (!pAsyncAddressData->pMdl) {

  00101	3b c6		 cmp	 eax, esi
  00103	89 47 20	 mov	 DWORD PTR [edi+32], eax
  00106	75 2f		 jne	 SHORT $L9378

; 153  : 
; 154  :         TRACE(TL_ERROR, ("Failed to create pMdl!\n"));
; 155  :         if (pAsyncAddressData->AddressRange)

  00108	8b 47 18	 mov	 eax, DWORD PTR [edi+24]
  0010b	3b c6		 cmp	 eax, esi
  0010d	74 07		 je	 SHORT $L10780

; 156  :             ExFreePool(pAsyncAddressData->AddressRange);

  0010f	50		 push	 eax
  00110	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePool@4
$L10780:

; 157  : 
; 158  :         if (pAsyncAddressData->Buffer)

  00116	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
  00119	3b c6		 cmp	 eax, esi
  0011b	74 07		 je	 SHORT $L10783

; 159  :             ExFreePool(pAsyncAddressData->Buffer);

  0011d	50		 push	 eax
  0011e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePool@4
$L10783:

; 160  : 
; 161  :         if (pAsyncAddressData)
; 162  :             ExFreePool(pAsyncAddressData);

  00124	57		 push	 edi
  00125	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePool@4
$L10788:

; 163  : 
; 164  :         ntStatus = STATUS_INSUFFICIENT_RESOURCES;

  0012b	c7 45 18 9a 00
	00 c0		 mov	 DWORD PTR _ntStatus$[ebp], -1073741670 ; c000009aH

; 165  :         goto Exit_AllocateAddressRange;

  00132	e9 5f 01 00 00	 jmp	 $Exit_AllocateAddressRange$9352
$L9378:

; 166  :     }
; 167  : 
; 168  :     MmBuildMdlForNonPagedPool(pAsyncAddressData->pMdl);

  00137	50		 push	 eax
  00138	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MmBuildMdlForNonPagedPool@4

; 169  : 
; 170  :     TRACE(TL_TRACE, ("pMdl = 0x%x\n", pAsyncAddressData->pMdl));
; 171  : 
; 172  :     // copy over the contents of data to our driver buffer
; 173  :     RtlCopyMemory(pAsyncAddressData->Buffer, Data, nLength);

  0013e	8b 7f 0c	 mov	 edi, DWORD PTR [edi+12]
  00141	8b 4d 18	 mov	 ecx, DWORD PTR _nLength$[ebp]
  00144	8b 75 30	 mov	 esi, DWORD PTR _Data$[ebp]
  00147	8b c1		 mov	 eax, ecx
  00149	c1 e9 02	 shr	 ecx, 2
  0014c	f3 a5		 rep movsd
  0014e	8b c8		 mov	 ecx, eax
  00150	83 e1 03	 and	 ecx, 3
  00153	f3 a4		 rep movsb

; 174  :     pAsyncAddressData->nLength = nLength;

  00155	8b 75 fc	 mov	 esi, DWORD PTR _pAsyncAddressData$[ebp]
  00158	8b d0		 mov	 edx, eax
  0015a	89 56 10	 mov	 DWORD PTR [esi+16], edx

; 175  : 
; 176  :     RtlZeroMemory (pIrb, sizeof (IRB));

  0015d	33 c0		 xor	 eax, eax

; 177  :     pIrb->FunctionNumber = REQUEST_ALLOCATE_ADDRESS_RANGE;
; 178  :     pIrb->Flags = 0;
; 179  :     pIrb->u.AllocateAddressRange.Mdl = pAsyncAddressData->pMdl;
; 180  :     pIrb->u.AllocateAddressRange.fulFlags = fulFlags;
; 181  :     pIrb->u.AllocateAddressRange.nLength = nLength;
; 182  :     pIrb->u.AllocateAddressRange.MaxSegmentSize = MaxSegmentSize;
; 183  :     pIrb->u.AllocateAddressRange.fulAccessType = fulAccessType;
; 184  :     pIrb->u.AllocateAddressRange.fulNotificationOptions = fulNotificationOptions;
; 185  : 
; 186  : //    if (bUseCallback) {
; 187  : 
; 188  : //        pIrb->u.AllocateAddressRange.Callback = t1394_AllocateAddressRange_Callback;
; 189  : //        pIrb->u.AllocateAddressRange.Context = deviceExtension;
; 190  : //    }
; 191  : //    else {
; 192  : 
; 193  :         pIrb->u.AllocateAddressRange.Callback = NULL;
; 194  :         pIrb->u.AllocateAddressRange.Context = NULL;
; 195  : //    }
; 196  : 
; 197  :     pIrb->u.AllocateAddressRange.Required1394Offset = *Required1394Offset;
; 198  :     pIrb->u.AllocateAddressRange.FifoSListHead = NULL;
; 199  :     pIrb->u.AllocateAddressRange.FifoSpinLock = NULL;
; 200  :     pIrb->u.AllocateAddressRange.AddressesReturned = 0;
; 201  :     pIrb->u.AllocateAddressRange.p1394AddressRange = pAsyncAddressData->AddressRange;
; 202  :     pIrb->u.AllocateAddressRange.DeviceExtension = deviceExtension;
; 203  : 
; 204  :     //
; 205  :     // If we allocated this irp, submit it asynchronously and wait for its
; 206  :     // completion event to be signaled.  Otherwise submit it synchronously
; 207  :     //
; 208  :     if (allocNewIrp) {

  0015f	38 45 0b	 cmp	 BYTE PTR _allocNewIrp$[ebp], al
  00162	6a 56		 push	 86			; 00000056H
  00164	59		 pop	 ecx
  00165	8b fb		 mov	 edi, ebx
  00167	f3 ab		 rep stosd
  00169	8b 7d f8	 mov	 edi, DWORD PTR _deviceExtension$[ebp]
  0016c	c7 03 11 00 00
	00		 mov	 DWORD PTR [ebx], 17	; 00000011H
  00172	89 43 04	 mov	 DWORD PTR [ebx+4], eax
  00175	8b 4e 20	 mov	 ecx, DWORD PTR [esi+32]
  00178	89 4b 48	 mov	 DWORD PTR [ebx+72], ecx
  0017b	8b 4d 14	 mov	 ecx, DWORD PTR _fulFlags$[ebp]
  0017e	89 4b 4c	 mov	 DWORD PTR [ebx+76], ecx
  00181	8b 4d 1c	 mov	 ecx, DWORD PTR _MaxSegmentSize$[ebp]
  00184	89 4b 54	 mov	 DWORD PTR [ebx+84], ecx
  00187	8b 4d 20	 mov	 ecx, DWORD PTR _fulAccessType$[ebp]
  0018a	89 4b 58	 mov	 DWORD PTR [ebx+88], ecx
  0018d	8b 4d 24	 mov	 ecx, DWORD PTR _fulNotificationOptions$[ebp]
  00190	89 4b 5c	 mov	 DWORD PTR [ebx+92], ecx
  00193	8b 4d 28	 mov	 ecx, DWORD PTR _Required1394Offset$[ebp]
  00196	89 53 50	 mov	 DWORD PTR [ebx+80], edx
  00199	89 43 60	 mov	 DWORD PTR [ebx+96], eax
  0019c	89 43 64	 mov	 DWORD PTR [ebx+100], eax
  0019f	8b 11		 mov	 edx, DWORD PTR [ecx]
  001a1	89 53 68	 mov	 DWORD PTR [ebx+104], edx
  001a4	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  001a7	89 4b 6c	 mov	 DWORD PTR [ebx+108], ecx
  001aa	89 43 70	 mov	 DWORD PTR [ebx+112], eax
  001ad	89 43 74	 mov	 DWORD PTR [ebx+116], eax
  001b0	89 43 78	 mov	 DWORD PTR [ebx+120], eax
  001b3	8b 4e 18	 mov	 ecx, DWORD PTR [esi+24]
  001b6	89 4b 7c	 mov	 DWORD PTR [ebx+124], ecx
  001b9	89 bb 84 00 00
	00		 mov	 DWORD PTR [ebx+132], edi
  001bf	74 36		 je	 SHORT $L9388

; 209  : 
; 210  :         KeInitializeEvent (&Event, NotificationEvent, FALSE);

  001c1	50		 push	 eax
  001c2	50		 push	 eax
  001c3	8d 45 dc	 lea	 eax, DWORD PTR _Event$[ebp]
  001c6	50		 push	 eax
  001c7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeInitializeEvent@12

; 211  :         ntStatus = t1394_SubmitIrpAsync (deviceExtension->StackDeviceObject, newIrp, pIrb);

  001cd	53		 push	 ebx
  001ce	ff 75 f4	 push	 DWORD PTR _newIrp$[ebp]
  001d1	ff 37		 push	 DWORD PTR [edi]
  001d3	e8 00 00 00 00	 call	 _t1394_SubmitIrpAsync@12

; 212  : 
; 213  :         if (ntStatus == STATUS_PENDING) {

  001d8	3d 03 01 00 00	 cmp	 eax, 259		; 00000103H
  001dd	89 45 18	 mov	 DWORD PTR _ntStatus$[ebp], eax
  001e0	75 23		 jne	 SHORT $L9392

; 214  :             KeWaitForSingleObject (&Event, Executive, KernelMode, FALSE, NULL); 

  001e2	33 c0		 xor	 eax, eax
  001e4	50		 push	 eax
  001e5	50		 push	 eax
  001e6	50		 push	 eax
  001e7	50		 push	 eax
  001e8	8d 45 dc	 lea	 eax, DWORD PTR _Event$[ebp]
  001eb	50		 push	 eax
  001ec	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeWaitForSingleObject@20

; 215  :             ntStatus = ioStatus.Status;

  001f2	8b 45 ec	 mov	 eax, DWORD PTR _ioStatus$[ebp]

; 216  :         }
; 217  :     }
; 218  :     else {

  001f5	eb 0b		 jmp	 SHORT $L10786
$L9388:

; 219  :     
; 220  :         ntStatus = t1394_SubmitIrpSynch(deviceExtension->StackDeviceObject, Irp, pIrb);

  001f7	53		 push	 ebx
  001f8	ff 75 0c	 push	 DWORD PTR _Irp$[ebp]
  001fb	ff 37		 push	 DWORD PTR [edi]
  001fd	e8 00 00 00 00	 call	 _t1394_SubmitIrpSynch@12
$L10786:
  00202	89 45 18	 mov	 DWORD PTR _ntStatus$[ebp], eax
$L9392:

; 221  :     }
; 222  : 
; 223  :     if (NT_SUCCESS(ntStatus)) {

  00205	83 7d 18 00	 cmp	 DWORD PTR _ntStatus$[ebp], 0
  00209	7c 5a		 jl	 SHORT $L9394

; 224  : 
; 225  :         ULONG   i;
; 226  : 
; 227  :         // save off info into our struct...
; 228  :         pAsyncAddressData->DeviceExtension = deviceExtension;

  0020b	89 7e 08	 mov	 DWORD PTR [esi+8], edi

; 229  :         pAsyncAddressData->nAddressesReturned = pIrb->u.AllocateAddressRange.AddressesReturned;

  0020e	8b 43 78	 mov	 eax, DWORD PTR [ebx+120]
  00211	89 46 14	 mov	 DWORD PTR [esi+20], eax

; 230  : //        pAsyncAddressData->AddressRange = pIrb->u.AllocateAddressRange.p1394AddressRange;
; 231  :         pAsyncAddressData->hAddressRange = pIrb->u.AllocateAddressRange.hAddressRange;

  00214	8b 83 80 00 00
	00		 mov	 eax, DWORD PTR [ebx+128]

; 232  : 
; 233  :         // add our struct to the list...
; 234  :         KeAcquireSpinLock(&deviceExtension->AsyncSpinLock, &Irql);

  0021a	8d 4f 1c	 lea	 ecx, DWORD PTR [edi+28]
  0021d	89 46 1c	 mov	 DWORD PTR [esi+28], eax
  00220	89 4d 1c	 mov	 DWORD PTR tv407[ebp], ecx
  00223	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@KfAcquireSpinLock@4

; 235  :         InsertHeadList(&deviceExtension->AsyncAddressData, &pAsyncAddressData->AsyncAddressList);

  00229	83 c7 48	 add	 edi, 72			; 00000048H
  0022c	8b 0f		 mov	 ecx, DWORD PTR [edi]
  0022e	89 0e		 mov	 DWORD PTR [esi], ecx
  00230	89 7e 04	 mov	 DWORD PTR [esi+4], edi
  00233	89 71 04	 mov	 DWORD PTR [ecx+4], esi

; 236  :         KeReleaseSpinLock(&deviceExtension->AsyncSpinLock, Irql);

  00236	8b 4d 1c	 mov	 ecx, DWORD PTR tv407[ebp]
  00239	8a d0		 mov	 dl, al
  0023b	89 37		 mov	 DWORD PTR [edi], esi
  0023d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@KfReleaseSpinLock@8

; 237  : 
; 238  :         *phAddressRange = pIrb->u.AllocateAddressRange.hAddressRange;

  00243	8b 83 80 00 00
	00		 mov	 eax, DWORD PTR [ebx+128]
  00249	8b 4d 2c	 mov	 ecx, DWORD PTR _phAddressRange$[ebp]
  0024c	89 01		 mov	 DWORD PTR [ecx], eax

; 239  : 
; 240  :         TRACE(TL_TRACE, ("AddressesReturned = 0x%x\n", pIrb->u.AllocateAddressRange.AddressesReturned));
; 241  :         TRACE(TL_TRACE, ("hAddressRange = 0x%x\n", *phAddressRange));
; 242  : 
; 243  :         for (i=0; i < pIrb->u.AllocateAddressRange.AddressesReturned; i++) {
; 244  : 
; 245  :             TRACE(TL_TRACE, ("Off_High = 0x%x\n", pAsyncAddressData->AddressRange[0].AR_Off_High));
; 246  :             TRACE(TL_TRACE, ("Off_Low = 0x%x\n", pAsyncAddressData->AddressRange[0].AR_Off_Low));
; 247  :         }
; 248  : 
; 249  :         Required1394Offset->Off_High = pIrb->u.AllocateAddressRange.p1394AddressRange[0].AR_Off_High;

  0024e	8b 43 7c	 mov	 eax, DWORD PTR [ebx+124]
  00251	66 8b 08	 mov	 cx, WORD PTR [eax]
  00254	8b 45 28	 mov	 eax, DWORD PTR _Required1394Offset$[ebp]
  00257	66 89 08	 mov	 WORD PTR [eax], cx

; 250  :         Required1394Offset->Off_Low = pIrb->u.AllocateAddressRange.p1394AddressRange[0].AR_Off_Low;

  0025a	8b 4b 7c	 mov	 ecx, DWORD PTR [ebx+124]
  0025d	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00260	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 251  :     }
; 252  :     else {

  00263	eb 31		 jmp	 SHORT $Exit_AllocateAddressRange$9352
$L9394:

; 253  :         TRACE(TL_ERROR, ("SubmitIrpSync failed = 0x%x\n", ntStatus));
; 254  :         // need to free a few things...
; 255  :         if (pAsyncAddressData->pMdl)

  00265	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  00268	85 c0		 test	 eax, eax
  0026a	74 07		 je	 SHORT $L9400

; 256  :             IoFreeMdl(pAsyncAddressData->pMdl);

  0026c	50		 push	 eax
  0026d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoFreeMdl@4
$L9400:

; 257  : 
; 258  :         if (pAsyncAddressData->Buffer)

  00273	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00276	85 c0		 test	 eax, eax
  00278	74 07		 je	 SHORT $L10781

; 259  :             ExFreePool(pAsyncAddressData->Buffer);

  0027a	50		 push	 eax
  0027b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePool@4
$L10781:

; 260  : 
; 261  :         if (pAsyncAddressData->AddressRange)

  00281	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  00284	85 c0		 test	 eax, eax
  00286	74 07		 je	 SHORT $L10784

; 262  :             ExFreePool(pAsyncAddressData->AddressRange);

  00288	50		 push	 eax
  00289	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePool@4
$L10784:

; 263  : 
; 264  :         if (pAsyncAddressData)
; 265  :             ExFreePool(pAsyncAddressData);

  0028f	56		 push	 esi
  00290	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePool@4
$Exit_AllocateAddressRange$9352:

; 266  :     }
; 267  : 
; 268  : Exit_AllocateAddressRange:
; 269  : 
; 270  :     if (allocNewIrp) 

  00296	80 7d 0b 00	 cmp	 BYTE PTR _allocNewIrp$[ebp], 0
  0029a	74 0f		 je	 SHORT $L9404

; 271  :         Irp->IoStatus = ioStatus;

  0029c	8b 4d ec	 mov	 ecx, DWORD PTR _ioStatus$[ebp]
  0029f	8b 45 0c	 mov	 eax, DWORD PTR _Irp$[ebp]
  002a2	89 48 18	 mov	 DWORD PTR [eax+24], ecx
  002a5	8b 4d f0	 mov	 ecx, DWORD PTR _ioStatus$[ebp+4]
  002a8	89 48 1c	 mov	 DWORD PTR [eax+28], ecx
$L9404:

; 272  : 
; 273  :     if (pIrb)

  002ab	85 db		 test	 ebx, ebx
  002ad	74 07		 je	 SHORT $L10785

; 274  :         ExFreePool(pIrb);

  002af	53		 push	 ebx
  002b0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePool@4
$L10785:
  002b6	5f		 pop	 edi
  002b7	5b		 pop	 ebx
$L10782:

; 275  : 
; 276  :     EXIT("t1394_AllocateAddressRange", ntStatus);
; 277  :     return(ntStatus);

  002b8	8b 45 18	 mov	 eax, DWORD PTR _ntStatus$[ebp]
  002bb	5e		 pop	 esi

; 278  : } // t1394_AllocateAddressRange

  002bc	c9		 leave
  002bd	c2 2c 00	 ret	 44			; 0000002cH
_t1394_AllocateAddressRange@44 ENDP
_TEXT	ENDS
PUBLIC	_t1394_FreeAddressRange@12
; Function compile flags: /Ogsy
;	COMDAT _t1394_FreeAddressRange@12
_TEXT	SEGMENT
_Event$ = -36						; size = 16
_ioStatus$ = -20					; size = 8
_newIrp$ = -12						; size = 4
_deviceExtension$ = -8					; size = 4
tv234 = -4						; size = 4
_DeviceObject$ = 8					; size = 4
_allocNewIrp$ = 11					; size = 1
_Irp$ = 12						; size = 4
_hAddressRange$ = 16					; size = 4
_t1394_FreeAddressRange@12 PROC NEAR			; COMDAT

; 286  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H

; 287  :     NTSTATUS                ntStatus = STATUS_SUCCESS;
; 288  :     PDEVICE_EXTENSION       deviceExtension = DeviceObject->DeviceExtension;

  00006	8b 45 08	 mov	 eax, DWORD PTR _DeviceObject$[ebp]
  00009	56		 push	 esi
  0000a	57		 push	 edi
  0000b	8b 78 28	 mov	 edi, DWORD PTR [eax+40]

; 289  :     PIRB                    pIrb;
; 290  :     KIRQL                   Irql;
; 291  :     PASYNC_ADDRESS_DATA     AsyncAddressData;
; 292  : 
; 293  :     PIRP                    newIrp;
; 294  :     BOOLEAN                 allocNewIrp = FALSE;
; 295  :     KEVENT                  Event;
; 296  :     IO_STATUS_BLOCK         ioStatus;
; 297  :     
; 298  :     ENTER("t1394_FreeAddressRange");
; 299  : 
; 300  :     TRACE(TL_TRACE, ("hAddressRange = 0x%x\n", hAddressRange));
; 301  : 
; 302  :     //
; 303  :     // If this is a UserMode request create a newIrp so that the request
; 304  :     // will be issued from KernelMode
; 305  :     //
; 306  :     if (Irp->RequestorMode == UserMode) {

  0000e	8b 45 0c	 mov	 eax, DWORD PTR _Irp$[ebp]
  00011	80 78 20 01	 cmp	 BYTE PTR [eax+32], 1
  00015	89 7d f8	 mov	 DWORD PTR _deviceExtension$[ebp], edi
  00018	c6 45 0b 00	 mov	 BYTE PTR _allocNewIrp$[ebp], 0
  0001c	75 32		 jne	 SHORT $L10804

; 307  : 
; 308  :         newIrp = IoBuildDeviceIoControlRequest (IOCTL_1394_CLASS, deviceExtension->StackDeviceObject, 
; 309  :                             NULL, 0, NULL, 0, TRUE, &Event, &ioStatus);

  0001e	8d 45 ec	 lea	 eax, DWORD PTR _ioStatus$[ebp]
  00021	50		 push	 eax
  00022	8d 45 dc	 lea	 eax, DWORD PTR _Event$[ebp]
  00025	50		 push	 eax
  00026	6a 01		 push	 1
  00028	33 f6		 xor	 esi, esi
  0002a	56		 push	 esi
  0002b	56		 push	 esi
  0002c	56		 push	 esi
  0002d	56		 push	 esi
  0002e	ff 37		 push	 DWORD PTR [edi]
  00030	68 1d 02 22 00	 push	 2228765			; 0022021dH
  00035	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoBuildDeviceIoControlRequest@36

; 310  : 
; 311  :         if (!newIrp) {

  0003b	3b c6		 cmp	 eax, esi
  0003d	89 45 f4	 mov	 DWORD PTR _newIrp$[ebp], eax
  00040	75 0a		 jne	 SHORT $L9426

; 312  : 
; 313  :             TRACE(TL_ERROR, ("Failed to allocate newIrp!\n"));        
; 314  :             ntStatus = STATUS_INSUFFICIENT_RESOURCES;

  00042	bf 9a 00 00 c0	 mov	 edi, -1073741670	; c000009aH

; 315  :             goto Exit_FreeAddressRange;            

  00047	e9 5b 01 00 00	 jmp	 $L9461
$L9426:

; 316  :         }
; 317  :         allocNewIrp = TRUE;

  0004c	c6 45 0b 01	 mov	 BYTE PTR _allocNewIrp$[ebp], 1
$L10804:
  00050	53		 push	 ebx

; 318  :     }
; 319  :     
; 320  :     // have to find our struct...
; 321  :     KeAcquireSpinLock(&deviceExtension->AsyncSpinLock, &Irql);

  00051	8d 5f 1c	 lea	 ebx, DWORD PTR [edi+28]
  00054	8b cb		 mov	 ecx, ebx
  00056	89 5d fc	 mov	 DWORD PTR tv234[ebp], ebx
  00059	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@KfAcquireSpinLock@4

; 322  : 
; 323  :     AsyncAddressData = (PASYNC_ADDRESS_DATA) deviceExtension->AsyncAddressData.Flink;

  0005f	83 c7 48	 add	 edi, 72			; 00000048H
  00062	8b 37		 mov	 esi, DWORD PTR [edi]
  00064	eb 0e		 jmp	 SHORT $L10806
$L9431:

; 326  : 
; 327  :         if (AsyncAddressData->hAddressRange == hAddressRange) {

  00066	8b 4d 10	 mov	 ecx, DWORD PTR _hAddressRange$[ebp]
  00069	39 4e 1c	 cmp	 DWORD PTR [esi+28], ecx
  0006c	74 0c		 je	 SHORT $L10802

; 331  :         }
; 332  :         else if (AsyncAddressData->AsyncAddressList.Flink == &deviceExtension->AsyncAddressData) {

  0006e	8b 36		 mov	 esi, DWORD PTR [esi]
  00070	3b f7		 cmp	 esi, edi
  00072	74 12		 je	 SHORT $L10803
$L10806:

; 324  : 
; 325  :     while (AsyncAddressData) {

  00074	85 f6		 test	 esi, esi
  00076	75 ee		 jne	 SHORT $L9431

; 331  :         }
; 332  :         else if (AsyncAddressData->AsyncAddressList.Flink == &deviceExtension->AsyncAddressData) {

  00078	eb 0e		 jmp	 SHORT $L9432
$L10802:

; 328  : 
; 329  :             RemoveEntryList(&AsyncAddressData->AsyncAddressList);

  0007a	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0007c	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0007f	89 0a		 mov	 DWORD PTR [edx], ecx
  00081	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 330  :             break;

  00084	eb 02		 jmp	 SHORT $L9432
$L10803:

; 333  : 
; 334  :             AsyncAddressData = NULL;

  00086	33 f6		 xor	 esi, esi
$L9432:

; 335  :             break;
; 336  :         }
; 337  :         else
; 338  :             AsyncAddressData = (PASYNC_ADDRESS_DATA)AsyncAddressData->AsyncAddressList.Flink;
; 339  :     }
; 340  : 
; 341  :     KeReleaseSpinLock(&deviceExtension->AsyncSpinLock, Irql);

  00088	8a d0		 mov	 dl, al
  0008a	8b cb		 mov	 ecx, ebx
  0008c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@KfReleaseSpinLock@8

; 342  : 
; 343  :     // never found an entry...
; 344  :     if (!AsyncAddressData) {

  00092	85 f6		 test	 esi, esi

; 345  : 
; 346  :         ntStatus = STATUS_INVALID_PARAMETER;
; 347  :         goto Exit_FreeAddressRange;

  00094	0f 84 f2 00 00
	00		 je	 $L9441

; 348  :     }
; 349  : 
; 350  :     // lets verify we have the right one, if not, we bail...
; 351  :     if (AsyncAddressData->hAddressRange == hAddressRange) {

  0009a	8b 45 10	 mov	 eax, DWORD PTR _hAddressRange$[ebp]
  0009d	39 46 1c	 cmp	 DWORD PTR [esi+28], eax
  000a0	0f 85 e6 00 00
	00		 jne	 $L9441

; 352  : 
; 353  :         // got it, lets free it...
; 354  : 
; 355  :         pIrb = ExAllocatePool(NonPagedPool, sizeof(IRB));

  000a6	68 57 64 6d 20	 push	 544040023		; 206d6457H
  000ab	68 58 01 00 00	 push	 344			; 00000158H
  000b0	6a 00		 push	 0
  000b2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExAllocatePoolWithTag@12
  000b8	8b d8		 mov	 ebx, eax

; 356  : 
; 357  :         if (!pIrb) {

  000ba	85 db		 test	 ebx, ebx
  000bc	75 2a		 jne	 SHORT $L9443

; 358  : 
; 359  :             TRACE(TL_ERROR, ("Failed to allocate pIrb!\n"));
; 360  :             // we need to add this back into our list since we were
; 361  :             // unable to free it...
; 362  :             KeAcquireSpinLock(&deviceExtension->AsyncSpinLock, &Irql);

  000be	8b 4d fc	 mov	 ecx, DWORD PTR tv234[ebp]
  000c1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@KfAcquireSpinLock@4

; 363  :             InsertHeadList(&deviceExtension->AsyncAddressData, &AsyncAddressData->AsyncAddressList);

  000c7	8b 0f		 mov	 ecx, DWORD PTR [edi]
  000c9	89 0e		 mov	 DWORD PTR [esi], ecx
  000cb	89 7e 04	 mov	 DWORD PTR [esi+4], edi
  000ce	89 71 04	 mov	 DWORD PTR [ecx+4], esi

; 364  :             KeReleaseSpinLock(&deviceExtension->AsyncSpinLock, Irql);

  000d1	8b 4d fc	 mov	 ecx, DWORD PTR tv234[ebp]
  000d4	8a d0		 mov	 dl, al
  000d6	89 37		 mov	 DWORD PTR [edi], esi
  000d8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@KfReleaseSpinLock@8

; 365  : 
; 366  :             ntStatus = STATUS_INSUFFICIENT_RESOURCES;

  000de	bf 9a 00 00 c0	 mov	 edi, -1073741670	; c000009aH

; 367  :             goto Exit_FreeAddressRange;

  000e3	e9 a9 00 00 00	 jmp	 $Exit_FreeAddressRange$9428
$L9443:

; 368  :         } // if
; 369  : 
; 370  :         RtlZeroMemory (pIrb, sizeof (IRB));

  000e8	33 c0		 xor	 eax, eax
  000ea	6a 56		 push	 86			; 00000056H
  000ec	59		 pop	 ecx
  000ed	8b fb		 mov	 edi, ebx
  000ef	f3 ab		 rep stosd

; 371  :         pIrb->FunctionNumber = REQUEST_FREE_ADDRESS_RANGE;
; 372  :         pIrb->Flags = 0;
; 373  :         pIrb->u.FreeAddressRange.nAddressesToFree = AsyncAddressData->nAddressesReturned;
; 374  :         pIrb->u.FreeAddressRange.p1394AddressRange = AsyncAddressData->AddressRange;
; 375  :         pIrb->u.FreeAddressRange.pAddressRange = &AsyncAddressData->hAddressRange;
; 376  :         pIrb->u.FreeAddressRange.DeviceExtension = (PVOID)deviceExtension;

  000f1	8b 7d f8	 mov	 edi, DWORD PTR _deviceExtension$[ebp]
  000f4	33 c9		 xor	 ecx, ecx

; 377  : 
; 378  :         //
; 379  :         // If we allocated this irp, submit it asynchronously and wait for its
; 380  :         // completion event to be signaled.  Otherwise submit it synchronously
; 381  :         //
; 382  :         if (allocNewIrp) {

  000f6	38 4d 0b	 cmp	 BYTE PTR _allocNewIrp$[ebp], cl
  000f9	c7 03 12 00 00
	00		 mov	 DWORD PTR [ebx], 18	; 00000012H
  000ff	89 4b 04	 mov	 DWORD PTR [ebx+4], ecx
  00102	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00105	89 43 48	 mov	 DWORD PTR [ebx+72], eax
  00108	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  0010b	89 43 4c	 mov	 DWORD PTR [ebx+76], eax
  0010e	8d 46 1c	 lea	 eax, DWORD PTR [esi+28]
  00111	89 43 50	 mov	 DWORD PTR [ebx+80], eax
  00114	89 7b 54	 mov	 DWORD PTR [ebx+84], edi
  00117	74 36		 je	 SHORT $L9447

; 383  : 
; 384  :             KeInitializeEvent (&Event, NotificationEvent, FALSE);

  00119	51		 push	 ecx
  0011a	51		 push	 ecx
  0011b	8d 45 dc	 lea	 eax, DWORD PTR _Event$[ebp]
  0011e	50		 push	 eax
  0011f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeInitializeEvent@12

; 385  :             ntStatus = t1394_SubmitIrpAsync (deviceExtension->StackDeviceObject, newIrp, pIrb);

  00125	53		 push	 ebx
  00126	ff 75 f4	 push	 DWORD PTR _newIrp$[ebp]
  00129	ff 37		 push	 DWORD PTR [edi]
  0012b	e8 00 00 00 00	 call	 _t1394_SubmitIrpAsync@12
  00130	8b f8		 mov	 edi, eax

; 386  : 
; 387  :             if (ntStatus == STATUS_PENDING) {

  00132	81 ff 03 01 00
	00		 cmp	 edi, 259		; 00000103H
  00138	75 22		 jne	 SHORT $L10805

; 388  :                 KeWaitForSingleObject (&Event, Executive, KernelMode, FALSE, NULL); 

  0013a	33 c0		 xor	 eax, eax
  0013c	50		 push	 eax
  0013d	50		 push	 eax
  0013e	50		 push	 eax
  0013f	50		 push	 eax
  00140	8d 45 dc	 lea	 eax, DWORD PTR _Event$[ebp]
  00143	50		 push	 eax
  00144	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeWaitForSingleObject@20

; 389  :                 ntStatus = ioStatus.Status;

  0014a	8b 7d ec	 mov	 edi, DWORD PTR _ioStatus$[ebp]

; 390  :             }
; 391  :         }
; 392  :         else {

  0014d	eb 0d		 jmp	 SHORT $L10805
$L9447:

; 393  :         
; 394  :             ntStatus = t1394_SubmitIrpSynch(deviceExtension->StackDeviceObject, Irp, pIrb);

  0014f	53		 push	 ebx
  00150	ff 75 0c	 push	 DWORD PTR _Irp$[ebp]
  00153	ff 37		 push	 DWORD PTR [edi]
  00155	e8 00 00 00 00	 call	 _t1394_SubmitIrpSynch@12
  0015a	8b f8		 mov	 edi, eax
$L10805:

; 395  :         }
; 396  :         
; 397  :         if (!NT_SUCCESS(ntStatus)) {
; 398  : 
; 399  :             TRACE(TL_ERROR, ("SubmitIrpSync failed = 0x%x\n", ntStatus));
; 400  :         }
; 401  : 
; 402  :         if (pIrb)
; 403  :             ExFreePool(pIrb);

  0015c	53		 push	 ebx
  0015d	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__ExFreePool@4
  00163	ff d3		 call	 ebx

; 404  : 
; 405  :         // need to free up everything associated with this allocate...
; 406  :         if (AsyncAddressData->pMdl)

  00165	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  00168	85 c0		 test	 eax, eax
  0016a	74 07		 je	 SHORT $L9455

; 407  :             IoFreeMdl(AsyncAddressData->pMdl);

  0016c	50		 push	 eax
  0016d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoFreeMdl@4
$L9455:

; 408  : 
; 409  :         if (AsyncAddressData->Buffer)

  00173	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00176	85 c0		 test	 eax, eax
  00178	74 03		 je	 SHORT $L9456

; 410  :             ExFreePool(AsyncAddressData->Buffer);

  0017a	50		 push	 eax
  0017b	ff d3		 call	 ebx
$L9456:

; 411  : 
; 412  :         if (AsyncAddressData->AddressRange)

  0017d	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  00180	85 c0		 test	 eax, eax
  00182	74 03		 je	 SHORT $L9457

; 413  :             ExFreePool(AsyncAddressData->AddressRange);

  00184	50		 push	 eax
  00185	ff d3		 call	 ebx
$L9457:

; 414  : 
; 415  :         if (AsyncAddressData)
; 416  :             ExFreePool(AsyncAddressData);

  00187	56		 push	 esi
  00188	ff d3		 call	 ebx

; 417  : 
; 418  :     }
; 419  :     else {

  0018a	eb 05		 jmp	 SHORT $Exit_FreeAddressRange$9428
$L9441:

; 420  : 
; 421  :         // we couldn't match the handles!
; 422  :         TRACE(TL_ERROR, ("Invalid handle = 0x%x", hAddressRange));
; 423  :         ntStatus = STATUS_INVALID_PARAMETER;

  0018c	bf 0d 00 00 c0	 mov	 edi, -1073741811	; c000000dH
$Exit_FreeAddressRange$9428:

; 424  :         goto Exit_FreeAddressRange;
; 425  :     }
; 426  : 
; 427  : 
; 428  : Exit_FreeAddressRange:
; 429  : 
; 430  :     if (allocNewIrp) 

  00191	80 7d 0b 00	 cmp	 BYTE PTR _allocNewIrp$[ebp], 0
  00195	5b		 pop	 ebx
  00196	74 0f		 je	 SHORT $L9461

; 431  :         Irp->IoStatus = ioStatus;

  00198	8b 4d ec	 mov	 ecx, DWORD PTR _ioStatus$[ebp]
  0019b	8b 45 0c	 mov	 eax, DWORD PTR _Irp$[ebp]
  0019e	89 48 18	 mov	 DWORD PTR [eax+24], ecx
  001a1	8b 4d f0	 mov	 ecx, DWORD PTR _ioStatus$[ebp+4]
  001a4	89 48 1c	 mov	 DWORD PTR [eax+28], ecx
$L9461:

; 432  :             
; 433  :     EXIT("t1394_FreeAddressRange", ntStatus);
; 434  :     return(ntStatus);

  001a7	8b c7		 mov	 eax, edi
  001a9	5f		 pop	 edi
  001aa	5e		 pop	 esi

; 435  : } // t1394_FreeAddressRange

  001ab	c9		 leave
  001ac	c2 0c 00	 ret	 12			; 0000000cH
_t1394_FreeAddressRange@12 ENDP
_TEXT	ENDS
PUBLIC	_t1394_AsyncRead@48
; Function compile flags: /Ogsy
;	COMDAT _t1394_AsyncRead@48
_TEXT	SEGMENT
_Event$ = -32						; size = 16
_ioStatus$ = -16					; size = 8
_newIrp$ = -8						; size = 4
_deviceExtension$ = -4					; size = 4
_DeviceObject$ = 8					; size = 4
_allocNewIrp$ = 11					; size = 1
_Irp$ = 12						; size = 4
_NextDeviceObject$ = 16					; size = 4
_ntStatus$ = 16						; size = 4
_bRawMode$ = 16						; size = 4
_bGetGeneration$ = 20					; size = 4
_DestinationAddress$ = 24				; size = 12
_nNumberOfBytesToRead$ = 36				; size = 4
_nBlockSize$ = 40					; size = 4
_fulFlags$ = 44						; size = 4
_ulGeneration$ = 48					; size = 4
_Data$ = 52						; size = 4
_t1394_AsyncRead@48 PROC NEAR				; COMDAT

; 574  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H

; 575  :     NTSTATUS            ntStatus = STATUS_SUCCESS;
; 576  :     PDEVICE_EXTENSION   deviceExtension = DeviceObject->DeviceExtension;

  00006	8b 45 08	 mov	 eax, DWORD PTR _DeviceObject$[ebp]
  00009	8b 40 28	 mov	 eax, DWORD PTR [eax+40]
  0000c	56		 push	 esi

; 577  :     PIRB                pIrb;
; 578  :     PMDL                pMdl;
; 579  : 
; 580  :     PDEVICE_OBJECT      NextDeviceObject;
; 581  :     PIRP                newIrp;
; 582  :     BOOLEAN             allocNewIrp = FALSE;
; 583  :     KEVENT              Event;
; 584  :     IO_STATUS_BLOCK     ioStatus;
; 585  : 
; 586  :     ENTER("t1394_AsyncRead");
; 587  : 
; 588  :     TRACE(TL_TRACE, ("bRawMode = %d\n", bRawMode));
; 589  :     TRACE(TL_TRACE, ("bGetGeneration = %d\n", bGetGeneration));
; 590  :     TRACE(TL_TRACE, ("DestinationAddress.IA_Destination_ID.NA_Bus_Number = 0x%x\n", DestinationAddress.IA_Destination_ID.NA_Bus_Number));
; 591  :     TRACE(TL_TRACE, ("DestinationAddress.IA_Destination_ID.NA_Node_Number = 0x%x\n", DestinationAddress.IA_Destination_ID.NA_Node_Number));
; 592  :     TRACE(TL_TRACE, ("DestinationAddress.IA_Destination_Offset.Off_High = 0x%x\n", DestinationAddress.IA_Destination_Offset.Off_High));
; 593  :     TRACE(TL_TRACE, ("DestinationAddress.IA_Destination_Offset.Off_Low = 0x%x\n", DestinationAddress.IA_Destination_Offset.Off_Low));
; 594  :     TRACE(TL_TRACE, ("nNumberOfBytesToRead = 0x%x\n", nNumberOfBytesToRead));
; 595  :     TRACE(TL_TRACE, ("nBlockSize = 0x%x\n", nBlockSize));
; 596  :     TRACE(TL_TRACE, ("fulFlags = 0x%x\n", fulFlags));
; 597  :     TRACE(TL_TRACE, ("ulGeneration = 0x%x\n", ulGeneration));
; 598  :     TRACE(TL_TRACE, ("Data = 0x%x\n", Data));
; 599  : 
; 600  :     //
; 601  :     // get the location of the next device object in the stack
; 602  :     //
; 603  :     if (bRawMode) {

  0000d	33 f6		 xor	 esi, esi
  0000f	39 75 10	 cmp	 DWORD PTR _bRawMode$[ebp], esi
  00012	57		 push	 edi
  00013	89 45 fc	 mov	 DWORD PTR _deviceExtension$[ebp], eax
  00016	c6 45 0b 00	 mov	 BYTE PTR _allocNewIrp$[ebp], 0
  0001a	74 05		 je	 SHORT $L9560

; 604  :         NextDeviceObject = deviceExtension->PortDeviceObject;

  0001c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 605  :     }
; 606  :     else {

  0001f	eb 02		 jmp	 SHORT $L10811
$L9560:

; 607  :         NextDeviceObject = deviceExtension->StackDeviceObject;

  00021	8b 00		 mov	 eax, DWORD PTR [eax]
$L10811:

; 608  :     }
; 609  : 
; 610  :     //
; 611  :     // If this is a UserMode request create a newIrp so that the request
; 612  :     // will be issued from KernelMode
; 613  :     //
; 614  :     if (Irp->RequestorMode == UserMode) {

  00023	8b 7d 0c	 mov	 edi, DWORD PTR _Irp$[ebp]
  00026	80 7f 20 01	 cmp	 BYTE PTR [edi+32], 1
  0002a	89 45 10	 mov	 DWORD PTR _NextDeviceObject$[ebp], eax
  0002d	75 33		 jne	 SHORT $L10809

; 615  : 
; 616  :         newIrp = IoBuildDeviceIoControlRequest (IOCTL_1394_CLASS, NextDeviceObject, 
; 617  :                             NULL, 0, NULL, 0, TRUE, &Event, &ioStatus);

  0002f	8d 45 f0	 lea	 eax, DWORD PTR _ioStatus$[ebp]
  00032	50		 push	 eax
  00033	8d 45 e0	 lea	 eax, DWORD PTR _Event$[ebp]
  00036	50		 push	 eax
  00037	6a 01		 push	 1
  00039	56		 push	 esi
  0003a	56		 push	 esi
  0003b	56		 push	 esi
  0003c	56		 push	 esi
  0003d	ff 75 10	 push	 DWORD PTR _NextDeviceObject$[ebp]
  00040	68 1d 02 22 00	 push	 2228765			; 0022021dH
  00045	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoBuildDeviceIoControlRequest@36

; 618  : 
; 619  :         if (!newIrp) {

  0004b	3b c6		 cmp	 eax, esi
  0004d	89 45 f8	 mov	 DWORD PTR _newIrp$[ebp], eax
  00050	75 0c		 jne	 SHORT $L9565

; 620  : 
; 621  :             TRACE(TL_ERROR, ("Failed to allocate newIrp!\n"));
; 622  :             ntStatus = STATUS_INSUFFICIENT_RESOURCES;

  00052	c7 45 10 9a 00
	00 c0		 mov	 DWORD PTR _ntStatus$[ebp], -1073741670 ; c000009aH

; 623  :             goto Exit_AsyncRead;            

  00059	e9 f1 00 00 00	 jmp	 $L10810
$L9565:

; 624  :         }
; 625  :         allocNewIrp = TRUE;

  0005e	c6 45 0b 01	 mov	 BYTE PTR _allocNewIrp$[ebp], 1
$L10809:
  00062	53		 push	 ebx

; 626  :     }
; 627  : 
; 628  :     pIrb = ExAllocatePool(NonPagedPool, sizeof(IRB));

  00063	68 57 64 6d 20	 push	 544040023		; 206d6457H
  00068	68 58 01 00 00	 push	 344			; 00000158H
  0006d	56		 push	 esi
  0006e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExAllocatePoolWithTag@12
  00074	8b d8		 mov	 ebx, eax

; 629  : 
; 630  :     if (!pIrb) {

  00076	3b de		 cmp	 ebx, esi
  00078	75 0c		 jne	 SHORT $L9569

; 631  : 
; 632  :         TRACE(TL_ERROR, ("Failed to allocate pIrb!\n"));
; 633  :         ntStatus = STATUS_INSUFFICIENT_RESOURCES;

  0007a	c7 45 10 9a 00
	00 c0		 mov	 DWORD PTR _ntStatus$[ebp], -1073741670 ; c000009aH

; 634  :         goto Exit_AsyncRead;

  00081	e9 b6 00 00 00	 jmp	 $Exit_AsyncRead$9567
$L9569:

; 635  :     } // if
; 636  : 
; 637  :     RtlZeroMemory (pIrb, sizeof (IRB));

  00086	6a 56		 push	 86			; 00000056H
  00088	33 c0		 xor	 eax, eax
  0008a	59		 pop	 ecx
  0008b	8b fb		 mov	 edi, ebx
  0008d	f3 ab		 rep stosd

; 638  :     pIrb->FunctionNumber = REQUEST_ASYNC_READ;
; 639  :     pIrb->Flags = 0;
; 640  :     pIrb->u.AsyncRead.DestinationAddress = DestinationAddress;
; 641  :     pIrb->u.AsyncRead.nNumberOfBytesToRead = nNumberOfBytesToRead;
; 642  :     pIrb->u.AsyncRead.nBlockSize = nBlockSize;

  0008f	8b 4d 28	 mov	 ecx, DWORD PTR _nBlockSize$[ebp]
  00092	8b 45 24	 mov	 eax, DWORD PTR _nNumberOfBytesToRead$[ebp]
  00095	89 33		 mov	 DWORD PTR [ebx], esi
  00097	89 73 04	 mov	 DWORD PTR [ebx+4], esi
  0009a	8d 7b 48	 lea	 edi, DWORD PTR [ebx+72]
  0009d	8d 75 18	 lea	 esi, DWORD PTR _DestinationAddress$[ebp]
  000a0	a5		 movsd
  000a1	a5		 movsd
  000a2	a5		 movsd
  000a3	89 4b 58	 mov	 DWORD PTR [ebx+88], ecx

; 643  :     pIrb->u.AsyncRead.fulFlags = fulFlags;

  000a6	8b 4d 2c	 mov	 ecx, DWORD PTR _fulFlags$[ebp]

; 644  : 
; 645  :     if (bGetGeneration) {

  000a9	33 f6		 xor	 esi, esi
  000ab	39 75 14	 cmp	 DWORD PTR _bGetGeneration$[ebp], esi
  000ae	89 43 54	 mov	 DWORD PTR [ebx+84], eax
  000b1	89 4b 5c	 mov	 DWORD PTR [ebx+92], ecx
  000b4	74 08		 je	 SHORT $L9572

; 646  : 
; 647  :         pIrb->u.AsyncRead.ulGeneration = deviceExtension->GenerationCount;

  000b6	8b 4d fc	 mov	 ecx, DWORD PTR _deviceExtension$[ebp]
  000b9	8b 49 34	 mov	 ecx, DWORD PTR [ecx+52]

; 648  :         TRACE(TL_TRACE, ("Retrieved Generation Count = 0x%x\n", pIrb->u.AsyncRead.ulGeneration));
; 649  :     }
; 650  :     else {

  000bc	eb 03		 jmp	 SHORT $L10812
$L9572:

; 651  :     
; 652  :         pIrb->u.AsyncRead.ulGeneration = ulGeneration;

  000be	8b 4d 30	 mov	 ecx, DWORD PTR _ulGeneration$[ebp]
$L10812:

; 653  :     }
; 654  : 
; 655  :     pMdl = IoAllocateMdl (Data, 
; 656  :                           nNumberOfBytesToRead,
; 657  :                           FALSE,
; 658  :                           FALSE,
; 659  :                           NULL);

  000c1	56		 push	 esi
  000c2	56		 push	 esi
  000c3	56		 push	 esi
  000c4	50		 push	 eax
  000c5	ff 75 34	 push	 DWORD PTR _Data$[ebp]
  000c8	89 4b 64	 mov	 DWORD PTR [ebx+100], ecx
  000cb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoAllocateMdl@20
  000d1	8b f8		 mov	 edi, eax

; 660  :     
; 661  :     MmBuildMdlForNonPagedPool(pMdl);

  000d3	57		 push	 edi
  000d4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MmBuildMdlForNonPagedPool@4

; 662  :     
; 663  :     pIrb->u.AsyncRead.Mdl = pMdl;
; 664  : 
; 665  :     //
; 666  :     // If we allocated this irp, submit it asynchronously and wait for its
; 667  :     // completion event to be signaled.  Otherwise submit it synchronously
; 668  :     //
; 669  :     if (allocNewIrp) {

  000da	80 7d 0b 00	 cmp	 BYTE PTR _allocNewIrp$[ebp], 0
  000de	89 7b 60	 mov	 DWORD PTR [ebx+96], edi
  000e1	74 35		 je	 SHORT $L9575

; 670  : 
; 671  :         KeInitializeEvent (&Event, NotificationEvent, FALSE);

  000e3	56		 push	 esi
  000e4	56		 push	 esi
  000e5	8d 45 e0	 lea	 eax, DWORD PTR _Event$[ebp]
  000e8	50		 push	 eax
  000e9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeInitializeEvent@12

; 672  :         ntStatus = t1394_SubmitIrpAsync (NextDeviceObject, newIrp, pIrb);

  000ef	53		 push	 ebx
  000f0	ff 75 f8	 push	 DWORD PTR _newIrp$[ebp]
  000f3	ff 75 10	 push	 DWORD PTR _NextDeviceObject$[ebp]
  000f6	e8 00 00 00 00	 call	 _t1394_SubmitIrpAsync@12

; 673  : 
; 674  :         if (ntStatus == STATUS_PENDING) {

  000fb	3d 03 01 00 00	 cmp	 eax, 259		; 00000103H
  00100	89 45 10	 mov	 DWORD PTR _ntStatus$[ebp], eax
  00103	75 22		 jne	 SHORT $L9579

; 675  :             KeWaitForSingleObject (&Event, Executive, KernelMode, FALSE, NULL); 

  00105	56		 push	 esi
  00106	56		 push	 esi
  00107	56		 push	 esi
  00108	56		 push	 esi
  00109	8d 45 e0	 lea	 eax, DWORD PTR _Event$[ebp]
  0010c	50		 push	 eax
  0010d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeWaitForSingleObject@20

; 676  :             ntStatus = ioStatus.Status;

  00113	8b 45 f0	 mov	 eax, DWORD PTR _ioStatus$[ebp]

; 677  :         }
; 678  :     }
; 679  :     else {

  00116	eb 0c		 jmp	 SHORT $L10813
$L9575:

; 680  :     
; 681  :         ntStatus = t1394_SubmitIrpSynch(NextDeviceObject, Irp, pIrb);

  00118	53		 push	 ebx
  00119	ff 75 0c	 push	 DWORD PTR _Irp$[ebp]
  0011c	ff 75 10	 push	 DWORD PTR _NextDeviceObject$[ebp]
  0011f	e8 00 00 00 00	 call	 _t1394_SubmitIrpSynch@12
$L10813:
  00124	89 45 10	 mov	 DWORD PTR _ntStatus$[ebp], eax
$L9579:

; 682  :         
; 683  :     }
; 684  : 
; 685  :     if (!NT_SUCCESS(ntStatus)) {
; 686  : 
; 687  :         TRACE(TL_ERROR, ("SubmitIrpSync failed = 0x%x\n", ntStatus));
; 688  : 
; 689  :         if (ntStatus != STATUS_INVALID_GENERATION) {
; 690  :         }
; 691  :     }
; 692  :     else {
; 693  : 
; 694  :     }
; 695  : 
; 696  : 
; 697  :     if (pMdl)

  00127	3b fe		 cmp	 edi, esi
  00129	74 07		 je	 SHORT $L9585

; 698  :         IoFreeMdl(pMdl);

  0012b	57		 push	 edi
  0012c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoFreeMdl@4
$L9585:

; 699  : 
; 700  :     if (pIrb)
; 701  :         ExFreePool(pIrb);

  00132	53		 push	 ebx
  00133	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePool@4
  00139	8b 7d 0c	 mov	 edi, DWORD PTR _Irp$[ebp]
$Exit_AsyncRead$9567:

; 702  : 
; 703  : Exit_AsyncRead:
; 704  : 
; 705  :     if (allocNewIrp) 

  0013c	80 7d 0b 00	 cmp	 BYTE PTR _allocNewIrp$[ebp], 0
  00140	5b		 pop	 ebx
  00141	74 0c		 je	 SHORT $L10810

; 706  :         Irp->IoStatus = ioStatus;

  00143	8b 45 f0	 mov	 eax, DWORD PTR _ioStatus$[ebp]
  00146	89 47 18	 mov	 DWORD PTR [edi+24], eax
  00149	8b 45 f4	 mov	 eax, DWORD PTR _ioStatus$[ebp+4]
  0014c	89 47 1c	 mov	 DWORD PTR [edi+28], eax
$L10810:

; 707  :         
; 708  :     EXIT("t1394_AsyncRead", ntStatus);
; 709  :     return(ntStatus);

  0014f	8b 45 10	 mov	 eax, DWORD PTR _ntStatus$[ebp]
  00152	5f		 pop	 edi
  00153	5e		 pop	 esi

; 710  : } // t1394_AsyncRead

  00154	c9		 leave
  00155	c2 30 00	 ret	 48			; 00000030H
_t1394_AsyncRead@48 ENDP
_TEXT	ENDS
PUBLIC	_t1394_AsyncWrite@48
; Function compile flags: /Ogsy
;	COMDAT _t1394_AsyncWrite@48
_TEXT	SEGMENT
_Event$ = -32						; size = 16
_ioStatus$ = -16					; size = 8
_newIrp$ = -8						; size = 4
_deviceExtension$ = -4					; size = 4
_DeviceObject$ = 8					; size = 4
_allocNewIrp$ = 11					; size = 1
_Irp$ = 12						; size = 4
_NextDeviceObject$ = 16					; size = 4
_bRawMode$ = 16						; size = 4
_bGetGeneration$ = 20					; size = 4
_DestinationAddress$ = 24				; size = 12
_pMdl$ = 36						; size = 4
_nNumberOfBytesToWrite$ = 36				; size = 4
_nBlockSize$ = 40					; size = 4
_fulFlags$ = 44						; size = 4
_ulGeneration$ = 48					; size = 4
_Data$ = 52						; size = 4
_t1394_AsyncWrite@48 PROC NEAR				; COMDAT

; 725  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H

; 726  :     NTSTATUS            ntStatus = STATUS_SUCCESS;
; 727  :     PDEVICE_EXTENSION   deviceExtension = DeviceObject->DeviceExtension;

  00006	8b 45 08	 mov	 eax, DWORD PTR _DeviceObject$[ebp]
  00009	8b 40 28	 mov	 eax, DWORD PTR [eax+40]
  0000c	56		 push	 esi

; 728  :     PIRB                pIrb;
; 729  :     PMDL                pMdl;
; 730  : 
; 731  :     PDEVICE_OBJECT      NextDeviceObject;
; 732  :     PIRP                newIrp;
; 733  :     BOOLEAN             allocNewIrp = FALSE;
; 734  :     KEVENT              Event;
; 735  :     IO_STATUS_BLOCK     ioStatus;
; 736  :     
; 737  :     ENTER("t1394_AsyncWrite");
; 738  : 
; 739  :     TRACE(TL_TRACE, ("bRawMode = %d\n", bRawMode));
; 740  :     TRACE(TL_TRACE, ("bGetGeneration = %d\n", bGetGeneration));
; 741  :     TRACE(TL_TRACE, ("DestinationAddress.IA_Destination_ID.NA_Bus_Number = 0x%x\n", DestinationAddress.IA_Destination_ID.NA_Bus_Number));
; 742  :     TRACE(TL_TRACE, ("DestinationAddress.IA_Destination_ID.NA_Node_Number = 0x%x\n", DestinationAddress.IA_Destination_ID.NA_Node_Number));
; 743  :     TRACE(TL_TRACE, ("DestinationAddress.IA_Destination_Offset.Off_High = 0x%x\n", DestinationAddress.IA_Destination_Offset.Off_High));
; 744  :     TRACE(TL_TRACE, ("DestinationAddress.IA_Destination_Offset.Off_Low = 0x%x\n", DestinationAddress.IA_Destination_Offset.Off_Low));
; 745  :     TRACE(TL_TRACE, ("nNumberOfBytesToWrite = 0x%x\n", nNumberOfBytesToWrite));
; 746  :     TRACE(TL_TRACE, ("nBlockSize = 0x%x\n", nBlockSize));
; 747  :     TRACE(TL_TRACE, ("fulFlags = 0x%x\n", fulFlags));
; 748  :     TRACE(TL_TRACE, ("ulGeneration = 0x%x\n", ulGeneration));
; 749  :     TRACE(TL_TRACE, ("Data = 0x%x\n", Data));
; 750  : 
; 751  :     if (nNumberOfBytesToWrite == 0) {

  0000d	33 f6		 xor	 esi, esi
  0000f	39 75 24	 cmp	 DWORD PTR _nNumberOfBytesToWrite$[ebp], esi
  00012	57		 push	 edi
  00013	89 45 fc	 mov	 DWORD PTR _deviceExtension$[ebp], eax
  00016	c6 45 0b 00	 mov	 BYTE PTR _allocNewIrp$[ebp], 0
  0001a	75 0a		 jne	 SHORT $L9619

; 752  : 
; 753  :         TRACE(TL_ERROR, ("Invalid nNumberOfBytesToWrite size!\n"));
; 754  :         ntStatus = STATUS_INVALID_PARAMETER;

  0001c	bf 0d 00 00 c0	 mov	 edi, -1073741811	; c000000dH

; 755  :         goto Exit_AsyncWrite;

  00021	e9 3d 01 00 00	 jmp	 $L9648
$L9619:

; 756  :     }
; 757  : 
; 758  :     //
; 759  :     // get the location of the next device object in the stack
; 760  :     //
; 761  :     if (bRawMode) {

  00026	39 75 10	 cmp	 DWORD PTR _bRawMode$[ebp], esi
  00029	74 05		 je	 SHORT $L9622

; 762  :         NextDeviceObject = deviceExtension->PortDeviceObject;

  0002b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 763  :     }
; 764  :     else {

  0002e	eb 02		 jmp	 SHORT $L10817
$L9622:

; 765  :         NextDeviceObject = deviceExtension->StackDeviceObject;

  00030	8b 00		 mov	 eax, DWORD PTR [eax]
$L10817:
  00032	89 45 10	 mov	 DWORD PTR _NextDeviceObject$[ebp], eax

; 766  :     }
; 767  : 
; 768  :     //
; 769  :     // If this is a UserMode request create a newIrp so that the request
; 770  :     // will be issued from KernelMode
; 771  :     //
; 772  :     if (Irp->RequestorMode == UserMode) {

  00035	8b 45 0c	 mov	 eax, DWORD PTR _Irp$[ebp]
  00038	80 78 20 01	 cmp	 BYTE PTR [eax+32], 1
  0003c	75 31		 jne	 SHORT $L10816

; 773  : 
; 774  :         newIrp = IoBuildDeviceIoControlRequest (IOCTL_1394_CLASS, NextDeviceObject, 
; 775  :                             NULL, 0, NULL, 0, TRUE, &Event, &ioStatus);

  0003e	8d 45 f0	 lea	 eax, DWORD PTR _ioStatus$[ebp]
  00041	50		 push	 eax
  00042	8d 45 e0	 lea	 eax, DWORD PTR _Event$[ebp]
  00045	50		 push	 eax
  00046	6a 01		 push	 1
  00048	56		 push	 esi
  00049	56		 push	 esi
  0004a	56		 push	 esi
  0004b	56		 push	 esi
  0004c	ff 75 10	 push	 DWORD PTR _NextDeviceObject$[ebp]
  0004f	68 1d 02 22 00	 push	 2228765			; 0022021dH
  00054	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoBuildDeviceIoControlRequest@36

; 776  : 
; 777  :         if (!newIrp) {

  0005a	3b c6		 cmp	 eax, esi
  0005c	89 45 f8	 mov	 DWORD PTR _newIrp$[ebp], eax
  0005f	75 0a		 jne	 SHORT $L9627

; 778  : 
; 779  :             TRACE(TL_ERROR, ("Failed to allocate newIrp!\n"));
; 780  :             ntStatus = STATUS_INSUFFICIENT_RESOURCES;

  00061	bf 9a 00 00 c0	 mov	 edi, -1073741670	; c000009aH

; 781  :             goto Exit_AsyncWrite;            

  00066	e9 f8 00 00 00	 jmp	 $L9648
$L9627:

; 782  :         }
; 783  :         allocNewIrp = TRUE;

  0006b	c6 45 0b 01	 mov	 BYTE PTR _allocNewIrp$[ebp], 1
$L10816:
  0006f	53		 push	 ebx

; 784  :     }
; 785  : 
; 786  :     pIrb = ExAllocatePool(NonPagedPool, sizeof(IRB));

  00070	68 57 64 6d 20	 push	 544040023		; 206d6457H
  00075	68 58 01 00 00	 push	 344			; 00000158H
  0007a	56		 push	 esi
  0007b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExAllocatePoolWithTag@12
  00081	8b d8		 mov	 ebx, eax

; 787  : 
; 788  :     if (!pIrb) {

  00083	3b de		 cmp	 ebx, esi
  00085	75 0a		 jne	 SHORT $L9630

; 789  : 
; 790  :         TRACE(TL_ERROR, ("Failed to allocate pIrb!\n"));
; 791  :         ntStatus = STATUS_INSUFFICIENT_RESOURCES;

  00087	bf 9a 00 00 c0	 mov	 edi, -1073741670	; c000009aH

; 792  :         goto Exit_AsyncWrite;

  0008c	e9 bc 00 00 00	 jmp	 $Exit_AsyncWrite$9621
$L9630:

; 793  :     } // if
; 794  : 
; 795  :     RtlZeroMemory (pIrb, sizeof (IRB));

  00091	6a 56		 push	 86			; 00000056H
  00093	33 c0		 xor	 eax, eax
  00095	59		 pop	 ecx
  00096	8b fb		 mov	 edi, ebx
  00098	f3 ab		 rep stosd

; 796  :     pIrb->FunctionNumber = REQUEST_ASYNC_WRITE;
; 797  :     pIrb->Flags = 0;
; 798  :     pIrb->u.AsyncWrite.DestinationAddress = DestinationAddress;
; 799  :     pIrb->u.AsyncWrite.nNumberOfBytesToWrite = nNumberOfBytesToWrite;
; 800  :     pIrb->u.AsyncWrite.nBlockSize = nBlockSize;

  0009a	8b 4d 28	 mov	 ecx, DWORD PTR _nBlockSize$[ebp]
  0009d	8b 45 24	 mov	 eax, DWORD PTR _nNumberOfBytesToWrite$[ebp]
  000a0	89 73 04	 mov	 DWORD PTR [ebx+4], esi
  000a3	8d 7b 48	 lea	 edi, DWORD PTR [ebx+72]
  000a6	8d 75 18	 lea	 esi, DWORD PTR _DestinationAddress$[ebp]
  000a9	a5		 movsd
  000aa	a5		 movsd
  000ab	a5		 movsd
  000ac	89 4b 58	 mov	 DWORD PTR [ebx+88], ecx

; 801  :     pIrb->u.AsyncWrite.fulFlags = fulFlags;

  000af	8b 4d 2c	 mov	 ecx, DWORD PTR _fulFlags$[ebp]

; 802  : 
; 803  :     if (bGetGeneration) {

  000b2	33 f6		 xor	 esi, esi
  000b4	39 75 14	 cmp	 DWORD PTR _bGetGeneration$[ebp], esi
  000b7	c7 03 01 00 00
	00		 mov	 DWORD PTR [ebx], 1
  000bd	89 43 54	 mov	 DWORD PTR [ebx+84], eax
  000c0	89 4b 5c	 mov	 DWORD PTR [ebx+92], ecx
  000c3	74 08		 je	 SHORT $L9633

; 804  :     
; 805  :         pIrb->u.AsyncRead.ulGeneration = deviceExtension->GenerationCount;

  000c5	8b 4d fc	 mov	 ecx, DWORD PTR _deviceExtension$[ebp]
  000c8	8b 49 34	 mov	 ecx, DWORD PTR [ecx+52]

; 806  :         TRACE(TL_TRACE, ("Retrieved Generation Count = 0x%x\n", pIrb->u.AsyncRead.ulGeneration));
; 807  :     }
; 808  :     else {

  000cb	eb 03		 jmp	 SHORT $L10818
$L9633:

; 809  :         pIrb->u.AsyncRead.ulGeneration = ulGeneration;

  000cd	8b 4d 30	 mov	 ecx, DWORD PTR _ulGeneration$[ebp]
$L10818:

; 810  :     }
; 811  :     
; 812  :     pMdl = IoAllocateMdl (Data,
; 813  :                           nNumberOfBytesToWrite,
; 814  :                           FALSE,
; 815  :                           FALSE,
; 816  :                           NULL);

  000d0	56		 push	 esi
  000d1	56		 push	 esi
  000d2	56		 push	 esi
  000d3	50		 push	 eax
  000d4	ff 75 34	 push	 DWORD PTR _Data$[ebp]
  000d7	89 4b 64	 mov	 DWORD PTR [ebx+100], ecx
  000da	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoAllocateMdl@20
  000e0	8b f8		 mov	 edi, eax

; 817  :     
; 818  :     MmBuildMdlForNonPagedPool(pMdl);

  000e2	57		 push	 edi
  000e3	89 7d 24	 mov	 DWORD PTR _pMdl$[ebp], edi
  000e6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MmBuildMdlForNonPagedPool@4

; 819  : 
; 820  :     pIrb->u.AsyncWrite.Mdl = pMdl;
; 821  : 
; 822  :     //
; 823  :     // If we allocated this irp, submit it asynchronously and wait for its
; 824  :     // completion event to be signaled.  Otherwise submit it synchronously
; 825  :     //
; 826  :     if (allocNewIrp) {

  000ec	80 7d 0b 00	 cmp	 BYTE PTR _allocNewIrp$[ebp], 0
  000f0	89 7b 60	 mov	 DWORD PTR [ebx+96], edi
  000f3	74 35		 je	 SHORT $L9636

; 827  : 
; 828  :         KeInitializeEvent (&Event, NotificationEvent, FALSE);

  000f5	56		 push	 esi
  000f6	56		 push	 esi
  000f7	8d 45 e0	 lea	 eax, DWORD PTR _Event$[ebp]
  000fa	50		 push	 eax
  000fb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeInitializeEvent@12

; 829  :         ntStatus = t1394_SubmitIrpAsync (NextDeviceObject, newIrp, pIrb);

  00101	53		 push	 ebx
  00102	ff 75 f8	 push	 DWORD PTR _newIrp$[ebp]
  00105	ff 75 10	 push	 DWORD PTR _NextDeviceObject$[ebp]
  00108	e8 00 00 00 00	 call	 _t1394_SubmitIrpAsync@12
  0010d	8b f8		 mov	 edi, eax

; 830  : 
; 831  :         if (ntStatus == STATUS_PENDING) {

  0010f	81 ff 03 01 00
	00		 cmp	 edi, 259		; 00000103H
  00115	75 21		 jne	 SHORT $L9640

; 832  :             KeWaitForSingleObject (&Event, Executive, KernelMode, FALSE, NULL); 

  00117	56		 push	 esi
  00118	56		 push	 esi
  00119	56		 push	 esi
  0011a	56		 push	 esi
  0011b	8d 45 e0	 lea	 eax, DWORD PTR _Event$[ebp]
  0011e	50		 push	 eax
  0011f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeWaitForSingleObject@20

; 833  :             ntStatus = ioStatus.Status;

  00125	8b 7d f0	 mov	 edi, DWORD PTR _ioStatus$[ebp]

; 834  :         }
; 835  :     }
; 836  :     else {

  00128	eb 0e		 jmp	 SHORT $L9640
$L9636:

; 837  :     
; 838  :         ntStatus = t1394_SubmitIrpSynch(NextDeviceObject, Irp, pIrb);

  0012a	53		 push	 ebx
  0012b	ff 75 0c	 push	 DWORD PTR _Irp$[ebp]
  0012e	ff 75 10	 push	 DWORD PTR _NextDeviceObject$[ebp]
  00131	e8 00 00 00 00	 call	 _t1394_SubmitIrpSynch@12
  00136	8b f8		 mov	 edi, eax
$L9640:

; 839  :     }
; 840  :     
; 841  :     if (!NT_SUCCESS(ntStatus)) {
; 842  : 
; 843  :         TRACE(TL_ERROR, ("SubmitIrpSync failed = 0x%x\n", ntStatus));
; 844  : 
; 845  :         if (ntStatus != STATUS_INVALID_GENERATION) {
; 846  :         }
; 847  :     }
; 848  :     else {
; 849  : 
; 850  :     }
; 851  : 
; 852  :     if (pMdl)

  00138	39 75 24	 cmp	 DWORD PTR _pMdl$[ebp], esi
  0013b	74 09		 je	 SHORT $L9646

; 853  :         IoFreeMdl(pMdl);

  0013d	ff 75 24	 push	 DWORD PTR _pMdl$[ebp]
  00140	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoFreeMdl@4
$L9646:

; 854  : 
; 855  :     if (pIrb)
; 856  :         ExFreePool(pIrb);

  00146	53		 push	 ebx
  00147	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePool@4
$Exit_AsyncWrite$9621:

; 857  : 
; 858  : Exit_AsyncWrite:
; 859  : 
; 860  :     if (allocNewIrp) 

  0014d	80 7d 0b 00	 cmp	 BYTE PTR _allocNewIrp$[ebp], 0
  00151	5b		 pop	 ebx
  00152	74 0f		 je	 SHORT $L9648

; 861  :         Irp->IoStatus = ioStatus;

  00154	8b 4d f0	 mov	 ecx, DWORD PTR _ioStatus$[ebp]
  00157	8b 45 0c	 mov	 eax, DWORD PTR _Irp$[ebp]
  0015a	89 48 18	 mov	 DWORD PTR [eax+24], ecx
  0015d	8b 4d f4	 mov	 ecx, DWORD PTR _ioStatus$[ebp+4]
  00160	89 48 1c	 mov	 DWORD PTR [eax+28], ecx
$L9648:

; 862  : 
; 863  :     EXIT("t1394_AsyncWrite", ntStatus);
; 864  :     return(ntStatus);

  00163	8b c7		 mov	 eax, edi
  00165	5f		 pop	 edi
  00166	5e		 pop	 esi

; 865  : } // t1394_AsyncWrite

  00167	c9		 leave
  00168	c2 30 00	 ret	 48			; 00000030H
_t1394_AsyncWrite@48 ENDP
_TEXT	ENDS
PUBLIC	_t1394_AsyncLock@60
; Function compile flags: /Ogsy
;	COMDAT _t1394_AsyncLock@60
_TEXT	SEGMENT
_Event$ = -32						; size = 16
_ioStatus$ = -16					; size = 8
_newIrp$ = -8						; size = 4
_deviceExtension$ = -4					; size = 4
_DeviceObject$ = 8					; size = 4
_allocNewIrp$ = 11					; size = 1
_Irp$ = 12						; size = 4
_NextDeviceObject$ = 16					; size = 4
_bRawMode$ = 16						; size = 4
_bGetGeneration$ = 20					; size = 4
_DestinationAddress$ = 24				; size = 12
_nNumberOfArgBytes$ = 36				; size = 4
_nNumberOfDataBytes$ = 40				; size = 4
_fulTransactionType$ = 44				; size = 4
_fulFlags$ = 48						; size = 4
_Arguments$ = 52					; size = 4
_DataValues$ = 56					; size = 4
_ulGeneration$ = 60					; size = 4
_Buffer$ = 64						; size = 4
_t1394_AsyncLock@60 PROC NEAR				; COMDAT

; 883  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H

; 884  :     NTSTATUS            ntStatus = STATUS_SUCCESS;
; 885  :     PDEVICE_EXTENSION   deviceExtension = DeviceObject->DeviceExtension;

  00006	8b 45 08	 mov	 eax, DWORD PTR _DeviceObject$[ebp]
  00009	8b 40 28	 mov	 eax, DWORD PTR [eax+40]
  0000c	56		 push	 esi

; 886  :     PIRB                pIrb;
; 887  : 
; 888  :     PDEVICE_OBJECT      NextDeviceObject;
; 889  :     PIRP                newIrp;
; 890  :     BOOLEAN             allocNewIrp = FALSE;
; 891  :     KEVENT              Event;
; 892  :     IO_STATUS_BLOCK     ioStatus;
; 893  :     
; 894  :     ENTER("t1394_AsyncLock");
; 895  : 
; 896  :     TRACE(TL_TRACE, ("bRawMode = %d\n", bRawMode));
; 897  :     TRACE(TL_TRACE, ("bGetGeneration = %d\n", bGetGeneration));
; 898  :     TRACE(TL_TRACE, ("DestinationAddress.IA_Destination_ID.NA_Bus_Number = 0x%x\n", DestinationAddress.IA_Destination_ID.NA_Bus_Number));
; 899  :     TRACE(TL_TRACE, ("DestinationAddress.IA_Destination_ID.NA_Node_Number = 0x%x\n", DestinationAddress.IA_Destination_ID.NA_Node_Number));
; 900  :     TRACE(TL_TRACE, ("DestinationAddress.IA_Destination_Offset.Off_High = 0x%x\n", DestinationAddress.IA_Destination_Offset.Off_High));
; 901  :     TRACE(TL_TRACE, ("DestinationAddress.IA_Destination_Offset.Off_Low = 0x%x\n", DestinationAddress.IA_Destination_Offset.Off_Low));
; 902  :     TRACE(TL_TRACE, ("nNumberOfArgBytes = 0x%x\n", nNumberOfArgBytes));
; 903  :     TRACE(TL_TRACE, ("nNumberOfDataBytes = 0x%x\n", nNumberOfDataBytes));
; 904  :     TRACE(TL_TRACE, ("fulTransactionType = 0x%x\n", fulTransactionType));
; 905  :     TRACE(TL_TRACE, ("fulFlags = 0x%x\n", fulFlags));
; 906  :     TRACE(TL_TRACE, ("Arguments[0] = 0x%x\n", Arguments[0]));
; 907  :     TRACE(TL_TRACE, ("Arguments[1] = 0x%x\n", Arguments[1]));
; 908  :     TRACE(TL_TRACE, ("DataValues[0] = 0x%x\n", DataValues[0]));
; 909  :     TRACE(TL_TRACE, ("DataValues[1] = 0x%x\n", DataValues[1]));
; 910  :     TRACE(TL_TRACE, ("ulGeneration = 0x%x\n", ulGeneration));
; 911  :     TRACE(TL_TRACE, ("Buffer = 0x%x\n", Buffer));
; 912  : 
; 913  :     //
; 914  :     // get the location of the next device object in the stack
; 915  :     //
; 916  :     if (bRawMode) {

  0000d	33 f6		 xor	 esi, esi
  0000f	39 75 10	 cmp	 DWORD PTR _bRawMode$[ebp], esi
  00012	57		 push	 edi
  00013	89 45 fc	 mov	 DWORD PTR _deviceExtension$[ebp], eax
  00016	c6 45 0b 00	 mov	 BYTE PTR _allocNewIrp$[ebp], 0
  0001a	74 05		 je	 SHORT $L9685

; 917  :         NextDeviceObject = deviceExtension->PortDeviceObject;

  0001c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 918  :     }
; 919  :     else {

  0001f	eb 02		 jmp	 SHORT $L10822
$L9685:

; 920  :         NextDeviceObject = deviceExtension->StackDeviceObject;

  00021	8b 00		 mov	 eax, DWORD PTR [eax]
$L10822:

; 921  :     }
; 922  : 
; 923  :     //
; 924  :     // If this is a UserMode request create a newIrp so that the request
; 925  :     // will be issued from KernelMode
; 926  :     //
; 927  :     if (Irp->RequestorMode == UserMode) {

  00023	8b 7d 0c	 mov	 edi, DWORD PTR _Irp$[ebp]
  00026	80 7f 20 01	 cmp	 BYTE PTR [edi+32], 1
  0002a	89 45 10	 mov	 DWORD PTR _NextDeviceObject$[ebp], eax
  0002d	75 31		 jne	 SHORT $L10821

; 928  : 
; 929  :         newIrp = IoBuildDeviceIoControlRequest (IOCTL_1394_CLASS, NextDeviceObject, 
; 930  :                             NULL, 0, NULL, 0, TRUE, &Event, &ioStatus);

  0002f	8d 45 f0	 lea	 eax, DWORD PTR _ioStatus$[ebp]
  00032	50		 push	 eax
  00033	8d 45 e0	 lea	 eax, DWORD PTR _Event$[ebp]
  00036	50		 push	 eax
  00037	6a 01		 push	 1
  00039	56		 push	 esi
  0003a	56		 push	 esi
  0003b	56		 push	 esi
  0003c	56		 push	 esi
  0003d	ff 75 10	 push	 DWORD PTR _NextDeviceObject$[ebp]
  00040	68 1d 02 22 00	 push	 2228765			; 0022021dH
  00045	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoBuildDeviceIoControlRequest@36

; 931  : 
; 932  :         if (!newIrp) {

  0004b	3b c6		 cmp	 eax, esi
  0004d	89 45 f8	 mov	 DWORD PTR _newIrp$[ebp], eax
  00050	75 0a		 jne	 SHORT $L9690

; 933  : 
; 934  :             TRACE(TL_ERROR, ("Failed to allocate newIrp!\n"));
; 935  :             ntStatus = STATUS_INSUFFICIENT_RESOURCES;

  00052	be 9a 00 00 c0	 mov	 esi, -1073741670	; c000009aH

; 936  :             goto Exit_AsyncLock;            

  00057	e9 f6 00 00 00	 jmp	 $L9709
$L9690:

; 937  :         }
; 938  :         allocNewIrp = TRUE;

  0005c	c6 45 0b 01	 mov	 BYTE PTR _allocNewIrp$[ebp], 1
$L10821:
  00060	53		 push	 ebx

; 939  :     }
; 940  : 
; 941  :     pIrb = ExAllocatePool(NonPagedPool, sizeof(IRB));

  00061	68 57 64 6d 20	 push	 544040023		; 206d6457H
  00066	68 58 01 00 00	 push	 344			; 00000158H
  0006b	56		 push	 esi
  0006c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExAllocatePoolWithTag@12
  00072	8b d8		 mov	 ebx, eax

; 942  : 
; 943  :     if (!pIrb) {

  00074	3b de		 cmp	 ebx, esi
  00076	75 0a		 jne	 SHORT $L9694

; 944  : 
; 945  :         TRACE(TL_ERROR, ("Failed to allocate pIrb!\n"));
; 946  :         ntStatus = STATUS_INSUFFICIENT_RESOURCES;

  00078	be 9a 00 00 c0	 mov	 esi, -1073741670	; c000009aH

; 947  :         goto Exit_AsyncLock;

  0007d	e9 bd 00 00 00	 jmp	 $Exit_AsyncLock$9692
$L9694:

; 948  :     } // if
; 949  : 
; 950  :     RtlZeroMemory (pIrb, sizeof (IRB));

  00082	33 c0		 xor	 eax, eax
  00084	6a 56		 push	 86			; 00000056H
  00086	59		 pop	 ecx
  00087	8b fb		 mov	 edi, ebx
  00089	f3 ab		 rep stosd

; 951  :     pIrb->FunctionNumber = REQUEST_ASYNC_LOCK;
; 952  :     pIrb->Flags = 0;
; 953  :     pIrb->u.AsyncLock.DestinationAddress = DestinationAddress;
; 954  :     pIrb->u.AsyncLock.nNumberOfArgBytes = nNumberOfArgBytes;

  0008b	8b 45 24	 mov	 eax, DWORD PTR _nNumberOfArgBytes$[ebp]
  0008e	89 73 04	 mov	 DWORD PTR [ebx+4], esi
  00091	89 43 54	 mov	 DWORD PTR [ebx+84], eax

; 955  :     pIrb->u.AsyncLock.nNumberOfDataBytes = nNumberOfDataBytes;

  00094	8b 45 28	 mov	 eax, DWORD PTR _nNumberOfDataBytes$[ebp]
  00097	89 43 58	 mov	 DWORD PTR [ebx+88], eax

; 956  :     pIrb->u.AsyncLock.fulTransactionType = fulTransactionType;

  0009a	8b 45 2c	 mov	 eax, DWORD PTR _fulTransactionType$[ebp]
  0009d	8d 7b 48	 lea	 edi, DWORD PTR [ebx+72]
  000a0	8d 75 18	 lea	 esi, DWORD PTR _DestinationAddress$[ebp]
  000a3	a5		 movsd
  000a4	89 43 5c	 mov	 DWORD PTR [ebx+92], eax

; 957  :     pIrb->u.AsyncLock.fulFlags = fulFlags;

  000a7	8b 45 30	 mov	 eax, DWORD PTR _fulFlags$[ebp]
  000aa	a5		 movsd
  000ab	89 43 60	 mov	 DWORD PTR [ebx+96], eax

; 958  :     pIrb->u.AsyncLock.Arguments[0] = Arguments[0];

  000ae	8b 45 34	 mov	 eax, DWORD PTR _Arguments$[ebp]
  000b1	a5		 movsd
  000b2	c7 03 02 00 00
	00		 mov	 DWORD PTR [ebx], 2
  000b8	8b 08		 mov	 ecx, DWORD PTR [eax]
  000ba	89 4b 64	 mov	 DWORD PTR [ebx+100], ecx

; 959  :     pIrb->u.AsyncLock.Arguments[1] = Arguments[1];

  000bd	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000c0	89 43 68	 mov	 DWORD PTR [ebx+104], eax

; 960  :     pIrb->u.AsyncLock.DataValues[0] = DataValues[0];

  000c3	8b 45 38	 mov	 eax, DWORD PTR _DataValues$[ebp]
  000c6	8b 08		 mov	 ecx, DWORD PTR [eax]
  000c8	89 4b 6c	 mov	 DWORD PTR [ebx+108], ecx

; 961  :     pIrb->u.AsyncLock.DataValues[1] = DataValues[1];

  000cb	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000ce	89 43 70	 mov	 DWORD PTR [ebx+112], eax

; 962  :     pIrb->u.AsyncLock.pBuffer = Buffer;

  000d1	8b 45 40	 mov	 eax, DWORD PTR _Buffer$[ebp]

; 963  : 
; 964  :     if (bGetGeneration) {

  000d4	33 ff		 xor	 edi, edi
  000d6	39 7d 14	 cmp	 DWORD PTR _bGetGeneration$[ebp], edi
  000d9	89 43 74	 mov	 DWORD PTR [ebx+116], eax
  000dc	74 08		 je	 SHORT $L9697

; 965  :     
; 966  :         pIrb->u.AsyncLock.ulGeneration = deviceExtension->GenerationCount;

  000de	8b 45 fc	 mov	 eax, DWORD PTR _deviceExtension$[ebp]
  000e1	8b 40 34	 mov	 eax, DWORD PTR [eax+52]

; 967  :         TRACE(TL_TRACE, ("Retrieved Generation Count = 0x%x\n", pIrb->u.AsyncLock.ulGeneration));
; 968  :     }
; 969  :     else {

  000e4	eb 03		 jmp	 SHORT $L10823
$L9697:

; 970  :         pIrb->u.AsyncLock.ulGeneration = ulGeneration;

  000e6	8b 45 3c	 mov	 eax, DWORD PTR _ulGeneration$[ebp]
$L10823:

; 971  :     }
; 972  : 
; 973  :     //
; 974  :     // If we allocated this irp, submit it asynchronously and wait for its
; 975  :     // completion event to be signaled.  Otherwise submit it synchronously
; 976  :     //
; 977  :     if (allocNewIrp) {

  000e9	80 7d 0b 00	 cmp	 BYTE PTR _allocNewIrp$[ebp], 0
  000ed	89 43 78	 mov	 DWORD PTR [ebx+120], eax
  000f0	74 35		 je	 SHORT $L9699

; 978  : 
; 979  :         KeInitializeEvent (&Event, NotificationEvent, FALSE);

  000f2	57		 push	 edi
  000f3	57		 push	 edi
  000f4	8d 45 e0	 lea	 eax, DWORD PTR _Event$[ebp]
  000f7	50		 push	 eax
  000f8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeInitializeEvent@12

; 980  :         ntStatus = t1394_SubmitIrpAsync (NextDeviceObject, newIrp, pIrb);

  000fe	53		 push	 ebx
  000ff	ff 75 f8	 push	 DWORD PTR _newIrp$[ebp]
  00102	ff 75 10	 push	 DWORD PTR _NextDeviceObject$[ebp]
  00105	e8 00 00 00 00	 call	 _t1394_SubmitIrpAsync@12
  0010a	8b f0		 mov	 esi, eax

; 981  : 
; 982  :         if (ntStatus == STATUS_PENDING) {

  0010c	81 fe 03 01 00
	00		 cmp	 esi, 259		; 00000103H
  00112	75 21		 jne	 SHORT $L9703

; 983  :             KeWaitForSingleObject (&Event, Executive, KernelMode, FALSE, NULL); 

  00114	57		 push	 edi
  00115	57		 push	 edi
  00116	57		 push	 edi
  00117	57		 push	 edi
  00118	8d 45 e0	 lea	 eax, DWORD PTR _Event$[ebp]
  0011b	50		 push	 eax
  0011c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeWaitForSingleObject@20

; 984  :             ntStatus = ioStatus.Status;

  00122	8b 75 f0	 mov	 esi, DWORD PTR _ioStatus$[ebp]

; 985  :         }
; 986  :     }
; 987  :     else {

  00125	eb 0e		 jmp	 SHORT $L9703
$L9699:

; 988  :     
; 989  :         ntStatus = t1394_SubmitIrpSynch(NextDeviceObject, Irp, pIrb);

  00127	53		 push	 ebx
  00128	ff 75 0c	 push	 DWORD PTR _Irp$[ebp]
  0012b	ff 75 10	 push	 DWORD PTR _NextDeviceObject$[ebp]
  0012e	e8 00 00 00 00	 call	 _t1394_SubmitIrpSynch@12
  00133	8b f0		 mov	 esi, eax
$L9703:

; 990  :     }
; 991  :     
; 992  :     if (!NT_SUCCESS(ntStatus)) {
; 993  : 
; 994  :         TRACE(TL_ERROR, ("SubmitIrpSync failed = 0x%x\n", ntStatus));
; 995  : 
; 996  :         if (ntStatus != STATUS_INVALID_GENERATION) {
; 997  :         }
; 998  :     }
; 999  : 
; 1000 :     if (pIrb)
; 1001 :         ExFreePool(pIrb);

  00135	53		 push	 ebx
  00136	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePool@4
  0013c	8b 7d 0c	 mov	 edi, DWORD PTR _Irp$[ebp]
$Exit_AsyncLock$9692:

; 1002 : 
; 1003 : Exit_AsyncLock:
; 1004 : 
; 1005 :     if (allocNewIrp) 

  0013f	80 7d 0b 00	 cmp	 BYTE PTR _allocNewIrp$[ebp], 0
  00143	5b		 pop	 ebx
  00144	74 0c		 je	 SHORT $L9709

; 1006 :         Irp->IoStatus = ioStatus;

  00146	8b 45 f0	 mov	 eax, DWORD PTR _ioStatus$[ebp]
  00149	89 47 18	 mov	 DWORD PTR [edi+24], eax
  0014c	8b 45 f4	 mov	 eax, DWORD PTR _ioStatus$[ebp+4]
  0014f	89 47 1c	 mov	 DWORD PTR [edi+28], eax
$L9709:
  00152	5f		 pop	 edi

; 1007 :         
; 1008 :     EXIT("t1394_AsyncLock", ntStatus);
; 1009 :     return(ntStatus);

  00153	8b c6		 mov	 eax, esi
  00155	5e		 pop	 esi

; 1010 : } // t1394_AsyncLock

  00156	c9		 leave
  00157	c2 3c 00	 ret	 60			; 0000003cH
_t1394_AsyncLock@60 ENDP
_TEXT	ENDS
PUBLIC	_t1394_AsyncStream@36
; Function compile flags: /Ogsy
;	COMDAT _t1394_AsyncStream@36
_TEXT	SEGMENT
_Event$ = -28						; size = 16
_ioStatus$ = -12					; size = 8
_newIrp$ = -4						; size = 4
_DeviceObject$ = 8					; size = 4
_allocNewIrp$ = 11					; size = 1
_Irp$ = 12						; size = 4
_nNumberOfBytesToStream$ = 16				; size = 4
_fulFlags$ = 20						; size = 4
_ulTag$ = 24						; size = 4
_nChannel$ = 28						; size = 4
_ulSynch$ = 32						; size = 4
_pMdl$ = 36						; size = 4
_nSpeed$ = 36						; size = 1
_Data$ = 40						; size = 4
_t1394_AsyncStream@36 PROC NEAR				; COMDAT

; 1024 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH

; 1025 :     NTSTATUS            ntStatus = STATUS_SUCCESS;
; 1026 :     PDEVICE_EXTENSION   deviceExtension = DeviceObject->DeviceExtension;

  00006	8b 45 08	 mov	 eax, DWORD PTR _DeviceObject$[ebp]
  00009	53		 push	 ebx
  0000a	8b 58 28	 mov	 ebx, DWORD PTR [eax+40]

; 1027 :     PIRB                pIrb;
; 1028 :     PMDL                pMdl;
; 1029 : 
; 1030 :     PIRP                    newIrp;
; 1031 :     BOOLEAN                 allocNewIrp = FALSE;
; 1032 :     KEVENT                  Event;
; 1033 :     IO_STATUS_BLOCK         ioStatus;
; 1034 :     
; 1035 :     ENTER("t1394_AsyncStream");
; 1036 : 
; 1037 :     TRACE(TL_TRACE, ("nNumberOfBytesToStream = 0x%x\n", nNumberOfBytesToStream));
; 1038 :     TRACE(TL_TRACE, ("fulFlags = 0x%x\n", fulFlags));
; 1039 :     TRACE(TL_TRACE, ("ulTag = 0x%x\n", ulTag));
; 1040 :     TRACE(TL_TRACE, ("nChannel = 0x%x\n", nChannel));
; 1041 :     TRACE(TL_TRACE, ("ulSynch = 0x%x\n", ulSynch));
; 1042 :     TRACE(TL_TRACE, ("nSpeed = 0x%x\n", nSpeed));
; 1043 : 
; 1044 :     //
; 1045 :     // If this is a UserMode request create a newIrp so that the request
; 1046 :     // will be issued from KernelMode
; 1047 :     //
; 1048 :     if (Irp->RequestorMode == UserMode) {

  0000d	8b 45 0c	 mov	 eax, DWORD PTR _Irp$[ebp]
  00010	57		 push	 edi

; 1049 : 
; 1050 :         newIrp = IoBuildDeviceIoControlRequest (IOCTL_1394_CLASS, deviceExtension->StackDeviceObject, 
; 1051 :                             NULL, 0, NULL, 0, TRUE, &Event, &ioStatus);

  00011	33 ff		 xor	 edi, edi
  00013	80 78 20 01	 cmp	 BYTE PTR [eax+32], 1
  00017	c6 45 0b 00	 mov	 BYTE PTR _allocNewIrp$[ebp], 0
  0001b	75 30		 jne	 SHORT $L9738
  0001d	8d 45 f4	 lea	 eax, DWORD PTR _ioStatus$[ebp]
  00020	50		 push	 eax
  00021	8d 45 e4	 lea	 eax, DWORD PTR _Event$[ebp]
  00024	50		 push	 eax
  00025	6a 01		 push	 1
  00027	57		 push	 edi
  00028	57		 push	 edi
  00029	57		 push	 edi
  0002a	57		 push	 edi
  0002b	ff 33		 push	 DWORD PTR [ebx]
  0002d	68 1d 02 22 00	 push	 2228765			; 0022021dH
  00032	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoBuildDeviceIoControlRequest@36

; 1052 : 
; 1053 :         if (!newIrp) {

  00038	3b c7		 cmp	 eax, edi
  0003a	89 45 fc	 mov	 DWORD PTR _newIrp$[ebp], eax
  0003d	75 0a		 jne	 SHORT $L9741

; 1054 : 
; 1055 :             TRACE(TL_ERROR, ("Failed to allocate newIrp!\n"));        
; 1056 :             ntStatus = STATUS_INSUFFICIENT_RESOURCES;

  0003f	bb 9a 00 00 c0	 mov	 ebx, -1073741670	; c000009aH

; 1057 :             goto Exit_AsyncStream;            

  00044	e9 e9 00 00 00	 jmp	 $L9760
$L9741:

; 1058 :         }
; 1059 :         allocNewIrp = TRUE;

  00049	c6 45 0b 01	 mov	 BYTE PTR _allocNewIrp$[ebp], 1
$L9738:
  0004d	56		 push	 esi

; 1060 :     }
; 1061 :     
; 1062 :     pIrb = ExAllocatePool(NonPagedPool, sizeof(IRB));

  0004e	68 57 64 6d 20	 push	 544040023		; 206d6457H
  00053	68 58 01 00 00	 push	 344			; 00000158H
  00058	57		 push	 edi
  00059	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExAllocatePoolWithTag@12
  0005f	8b f0		 mov	 esi, eax

; 1063 : 
; 1064 :     if (!pIrb) {

  00061	3b f7		 cmp	 esi, edi

; 1065 : 
; 1066 :         TRACE(TL_ERROR, ("Failed to allocate pIrb!\n"));
; 1067 :         ntStatus = STATUS_INSUFFICIENT_RESOURCES;
; 1068 :         goto Exit_AsyncStream;

  00063	74 4c		 je	 SHORT $L10827

; 1069 :     } // if
; 1070 : 
; 1071 :     RtlZeroMemory (pIrb, sizeof (IRB));

  00065	6a 56		 push	 86			; 00000056H
  00067	59		 pop	 ecx
  00068	33 c0		 xor	 eax, eax
  0006a	8b fe		 mov	 edi, esi
  0006c	f3 ab		 rep stosd

; 1072 :     pIrb->FunctionNumber = REQUEST_ASYNC_STREAM;
; 1073 :     pIrb->Flags = 0;
; 1074 :     pIrb->u.AsyncStream.nNumberOfBytesToStream = nNumberOfBytesToStream;
; 1075 :     pIrb->u.AsyncStream.fulFlags = fulFlags;

  0006e	8b 4d 14	 mov	 ecx, DWORD PTR _fulFlags$[ebp]
  00071	8b 45 10	 mov	 eax, DWORD PTR _nNumberOfBytesToStream$[ebp]
  00074	89 4e 4c	 mov	 DWORD PTR [esi+76], ecx

; 1076 :     pIrb->u.AsyncStream.ulTag = ulTag;

  00077	8b 4d 18	 mov	 ecx, DWORD PTR _ulTag$[ebp]
  0007a	33 ff		 xor	 edi, edi

; 1077 :     pIrb->u.AsyncStream.nChannel = nChannel;
; 1078 :     pIrb->u.AsyncStream.ulSynch = ulSynch;
; 1079 :     pIrb->u.AsyncStream.nSpeed = nSpeed;
; 1080 :     
; 1081 :     pMdl = IoAllocateMdl (Data,
; 1082 :                           nNumberOfBytesToStream,
; 1083 :                           FALSE,
; 1084 :                           FALSE,
; 1085 :                           NULL);

  0007c	57		 push	 edi
  0007d	89 4e 54	 mov	 DWORD PTR [esi+84], ecx
  00080	8b 4d 1c	 mov	 ecx, DWORD PTR _nChannel$[ebp]
  00083	57		 push	 edi
  00084	89 4e 58	 mov	 DWORD PTR [esi+88], ecx
  00087	8b 4d 20	 mov	 ecx, DWORD PTR _ulSynch$[ebp]
  0008a	57		 push	 edi
  0008b	50		 push	 eax
  0008c	ff 75 28	 push	 DWORD PTR _Data$[ebp]
  0008f	89 4e 5c	 mov	 DWORD PTR [esi+92], ecx
  00092	8a 4d 24	 mov	 cl, BYTE PTR _nSpeed$[ebp]
  00095	c7 06 1e 00 00
	00		 mov	 DWORD PTR [esi], 30	; 0000001eH
  0009b	89 7e 04	 mov	 DWORD PTR [esi+4], edi
  0009e	89 46 48	 mov	 DWORD PTR [esi+72], eax
  000a1	88 4e 64	 mov	 BYTE PTR [esi+100], cl
  000a4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoAllocateMdl@20

; 1086 : 
; 1087 :     if (!pMdl) {

  000aa	3b c7		 cmp	 eax, edi
  000ac	89 45 24	 mov	 DWORD PTR _pMdl$[ebp], eax
  000af	75 07		 jne	 SHORT $L9749
$L10827:

; 1088 : 
; 1089 :         TRACE(TL_ERROR, ("Failed to allocate pMdl!\n"));
; 1090 :         ntStatus = STATUS_INSUFFICIENT_RESOURCES;

  000b1	bb 9a 00 00 c0	 mov	 ebx, -1073741670	; c000009aH

; 1091 :         goto Exit_AsyncStream;    

  000b6	eb 64		 jmp	 SHORT $Exit_AsyncStream$9743
$L9749:

; 1092 :     }
; 1093 :     
; 1094 :     MmBuildMdlForNonPagedPool(pMdl);

  000b8	50		 push	 eax
  000b9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MmBuildMdlForNonPagedPool@4

; 1095 : 
; 1096 :     pIrb->u.AsyncStream.Mdl = pMdl;
; 1097 : 
; 1098 :     //
; 1099 :     // If we allocated this irp, submit it asynchronously and wait for its
; 1100 :     // completion event to be signaled.  Otherwise submit it synchronously
; 1101 :     //
; 1102 :     if (allocNewIrp) {

  000bf	80 7d 0b 00	 cmp	 BYTE PTR _allocNewIrp$[ebp], 0
  000c3	8b 45 24	 mov	 eax, DWORD PTR _pMdl$[ebp]
  000c6	89 46 50	 mov	 DWORD PTR [esi+80], eax
  000c9	74 34		 je	 SHORT $L9751

; 1103 : 
; 1104 :         KeInitializeEvent (&Event, NotificationEvent, FALSE);

  000cb	57		 push	 edi
  000cc	57		 push	 edi
  000cd	8d 45 e4	 lea	 eax, DWORD PTR _Event$[ebp]
  000d0	50		 push	 eax
  000d1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeInitializeEvent@12

; 1105 :         ntStatus = t1394_SubmitIrpAsync (deviceExtension->StackDeviceObject, newIrp, pIrb);

  000d7	56		 push	 esi
  000d8	ff 75 fc	 push	 DWORD PTR _newIrp$[ebp]
  000db	ff 33		 push	 DWORD PTR [ebx]
  000dd	e8 00 00 00 00	 call	 _t1394_SubmitIrpAsync@12
  000e2	8b d8		 mov	 ebx, eax

; 1106 : 
; 1107 :         if (ntStatus == STATUS_PENDING) {

  000e4	81 fb 03 01 00
	00		 cmp	 ebx, 259		; 00000103H
  000ea	75 20		 jne	 SHORT $L9755

; 1108 :             KeWaitForSingleObject (&Event, Executive, KernelMode, FALSE, NULL); 

  000ec	57		 push	 edi
  000ed	57		 push	 edi
  000ee	57		 push	 edi
  000ef	57		 push	 edi
  000f0	8d 45 e4	 lea	 eax, DWORD PTR _Event$[ebp]
  000f3	50		 push	 eax
  000f4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeWaitForSingleObject@20

; 1109 :             ntStatus = ioStatus.Status;

  000fa	8b 5d f4	 mov	 ebx, DWORD PTR _ioStatus$[ebp]

; 1110 :         }
; 1111 :     }
; 1112 :     else {

  000fd	eb 0d		 jmp	 SHORT $L9755
$L9751:

; 1113 :         ntStatus = t1394_SubmitIrpSynch(deviceExtension->StackDeviceObject, Irp, pIrb);

  000ff	56		 push	 esi
  00100	ff 75 0c	 push	 DWORD PTR _Irp$[ebp]
  00103	ff 33		 push	 DWORD PTR [ebx]
  00105	e8 00 00 00 00	 call	 _t1394_SubmitIrpSynch@12
  0010a	8b d8		 mov	 ebx, eax
$L9755:

; 1114 :     }
; 1115 :     
; 1116 :     if (!NT_SUCCESS(ntStatus)) {
; 1117 : 
; 1118 :         TRACE(TL_ERROR, ("SubmitIrpSync failed = 0x%x\n", ntStatus));
; 1119 :     }
; 1120 : 
; 1121 :     if (pMdl)
; 1122 :         IoFreeMdl(pMdl);

  0010c	ff 75 24	 push	 DWORD PTR _pMdl$[ebp]
  0010f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoFreeMdl@4

; 1123 : 
; 1124 :     if (pIrb)
; 1125 :         ExFreePool(pIrb);

  00115	56		 push	 esi
  00116	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePool@4
$Exit_AsyncStream$9743:

; 1126 : 
; 1127 : Exit_AsyncStream:
; 1128 : 
; 1129 :     EXIT("t1394_AsyncStream", ntStatus);
; 1130 : 
; 1131 :     if (allocNewIrp) 

  0011c	80 7d 0b 00	 cmp	 BYTE PTR _allocNewIrp$[ebp], 0
  00120	5e		 pop	 esi
  00121	74 0f		 je	 SHORT $L9760

; 1132 :         Irp->IoStatus = ioStatus;

  00123	8b 4d f4	 mov	 ecx, DWORD PTR _ioStatus$[ebp]
  00126	8b 45 0c	 mov	 eax, DWORD PTR _Irp$[ebp]
  00129	89 48 18	 mov	 DWORD PTR [eax+24], ecx
  0012c	8b 4d f8	 mov	 ecx, DWORD PTR _ioStatus$[ebp+4]
  0012f	89 48 1c	 mov	 DWORD PTR [eax+28], ecx
$L9760:
  00132	5f		 pop	 edi

; 1133 :     
; 1134 :     return(ntStatus);

  00133	8b c3		 mov	 eax, ebx
  00135	5b		 pop	 ebx

; 1135 : } // t1394_AsyncStream

  00136	c9		 leave
  00137	c2 24 00	 ret	 36			; 00000024H
_t1394_AsyncStream@36 ENDP
_TEXT	ENDS
PUBLIC	_t1394_IsochAllocateBandwidth@28
; Function compile flags: /Ogsy
; File d:\srv03rtm\drivers\wdm\1394\tools\test\driver\common\isochapi.c
;	COMDAT _t1394_IsochAllocateBandwidth@28
_TEXT	SEGMENT
_Event$ = -28						; size = 16
_ioStatus$ = -12					; size = 8
_newIrp$ = -4						; size = 4
_DeviceObject$ = 8					; size = 4
_allocNewIrp$ = 11					; size = 1
_Irp$ = 12						; size = 4
_nMaxBytesPerFrameRequested$ = 16			; size = 4
_fulSpeed$ = 20						; size = 4
_phBandwidth$ = 24					; size = 4
_pBytesPerFrameAvailable$ = 28				; size = 4
_pSpeedSelected$ = 32					; size = 4
_t1394_IsochAllocateBandwidth@28 PROC NEAR		; COMDAT

; 33   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH

; 34   :     NTSTATUS            ntStatus = STATUS_SUCCESS;
; 35   :     PDEVICE_EXTENSION   deviceExtension = DeviceObject->DeviceExtension;

  00006	8b 45 08	 mov	 eax, DWORD PTR _DeviceObject$[ebp]
  00009	53		 push	 ebx
  0000a	8b 58 28	 mov	 ebx, DWORD PTR [eax+40]

; 36   :     PIRB                pIrb;
; 37   : 
; 38   :     PIRP                newIrp;
; 39   :     BOOLEAN             allocNewIrp = FALSE;
; 40   :     KEVENT              Event;
; 41   :     IO_STATUS_BLOCK     ioStatus;
; 42   :     
; 43   :     ENTER("t1394_IsochAllocateBandwidth");
; 44   : 
; 45   :     TRACE(TL_TRACE, ("nMaxBytesPerFrameRequested = 0x%x\n", nMaxBytesPerFrameRequested));
; 46   :     TRACE(TL_TRACE, ("fulSpeed = 0x%x\n", fulSpeed));
; 47   : 
; 48   :     //
; 49   :     // If this is a UserMode request create a newIrp so that the request
; 50   :     // will be issued from KernelMode
; 51   :     //
; 52   :     if (Irp->RequestorMode == UserMode) {

  0000d	8b 45 0c	 mov	 eax, DWORD PTR _Irp$[ebp]
  00010	57		 push	 edi

; 53   : 
; 54   :         newIrp = IoBuildDeviceIoControlRequest (IOCTL_1394_CLASS, deviceExtension->StackDeviceObject, 
; 55   :                             NULL, 0, NULL, 0, TRUE, &Event, &ioStatus);

  00011	33 ff		 xor	 edi, edi
  00013	80 78 20 01	 cmp	 BYTE PTR [eax+32], 1
  00017	c6 45 0b 00	 mov	 BYTE PTR _allocNewIrp$[ebp], 0
  0001b	75 30		 jne	 SHORT $L9785
  0001d	8d 45 f4	 lea	 eax, DWORD PTR _ioStatus$[ebp]
  00020	50		 push	 eax
  00021	8d 45 e4	 lea	 eax, DWORD PTR _Event$[ebp]
  00024	50		 push	 eax
  00025	6a 01		 push	 1
  00027	57		 push	 edi
  00028	57		 push	 edi
  00029	57		 push	 edi
  0002a	57		 push	 edi
  0002b	ff 33		 push	 DWORD PTR [ebx]
  0002d	68 1d 02 22 00	 push	 2228765			; 0022021dH
  00032	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoBuildDeviceIoControlRequest@36

; 56   : 
; 57   :         if (!newIrp) {

  00038	3b c7		 cmp	 eax, edi
  0003a	89 45 fc	 mov	 DWORD PTR _newIrp$[ebp], eax
  0003d	75 0a		 jne	 SHORT $L9788

; 58   : 
; 59   :             TRACE(TL_ERROR, ("Failed to allocate newIrp!\n"));        
; 60   :             ntStatus = STATUS_INSUFFICIENT_RESOURCES;

  0003f	bb 9a 00 00 c0	 mov	 ebx, -1073741670	; c000009aH

; 61   :             goto Exit_IsochAllocateBandwidth;            

  00044	e9 c6 00 00 00	 jmp	 $L9804
$L9788:

; 62   :         }
; 63   :         allocNewIrp = TRUE;

  00049	c6 45 0b 01	 mov	 BYTE PTR _allocNewIrp$[ebp], 1
$L9785:
  0004d	56		 push	 esi

; 64   :     }
; 65   :     
; 66   :     pIrb = ExAllocatePool(NonPagedPool, sizeof(IRB));

  0004e	68 57 64 6d 20	 push	 544040023		; 206d6457H
  00053	68 58 01 00 00	 push	 344			; 00000158H
  00058	57		 push	 edi
  00059	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExAllocatePoolWithTag@12
  0005f	8b f0		 mov	 esi, eax

; 67   : 
; 68   :     if (!pIrb) {

  00061	3b f7		 cmp	 esi, edi
  00063	75 0a		 jne	 SHORT $L9792

; 69   : 
; 70   :         TRACE(TL_ERROR, ("Failed to allocate pIrb!\n"));
; 71   :         ntStatus = STATUS_INSUFFICIENT_RESOURCES;

  00065	bb 9a 00 00 c0	 mov	 ebx, -1073741670	; c000009aH

; 72   :         goto Exit_IsochAllocateBandwidth;

  0006a	e9 8a 00 00 00	 jmp	 $Exit_IsochAllocateBandwidth$9790
$L9792:

; 73   :     } // if
; 74   : 
; 75   :     RtlZeroMemory (pIrb, sizeof (IRB));

  0006f	33 c0		 xor	 eax, eax
  00071	6a 56		 push	 86			; 00000056H
  00073	59		 pop	 ecx
  00074	8b fe		 mov	 edi, esi
  00076	f3 ab		 rep stosd

; 76   :     pIrb->FunctionNumber = REQUEST_ISOCH_ALLOCATE_BANDWIDTH;
; 77   :     pIrb->Flags = 0;
; 78   :     pIrb->u.IsochAllocateBandwidth.nMaxBytesPerFrameRequested = nMaxBytesPerFrameRequested;

  00078	8b 45 10	 mov	 eax, DWORD PTR _nMaxBytesPerFrameRequested$[ebp]
  0007b	33 ff		 xor	 edi, edi

; 79   :     pIrb->u.IsochAllocateBandwidth.fulSpeed = fulSpeed;
; 80   : 
; 81   :     //
; 82   :     // If we allocated this irp, submit it asynchronously and wait for its
; 83   :     // completion event to be signaled.  Otherwise submit it synchronously
; 84   :     //
; 85   :     if (allocNewIrp) {

  0007d	80 7d 0b 00	 cmp	 BYTE PTR _allocNewIrp$[ebp], 0
  00081	89 46 48	 mov	 DWORD PTR [esi+72], eax
  00084	8b 45 14	 mov	 eax, DWORD PTR _fulSpeed$[ebp]
  00087	c7 06 03 00 00
	00		 mov	 DWORD PTR [esi], 3
  0008d	89 7e 04	 mov	 DWORD PTR [esi+4], edi
  00090	89 46 4c	 mov	 DWORD PTR [esi+76], eax
  00093	74 34		 je	 SHORT $L9795

; 86   : 
; 87   :         KeInitializeEvent (&Event, NotificationEvent, FALSE);

  00095	57		 push	 edi
  00096	57		 push	 edi
  00097	8d 45 e4	 lea	 eax, DWORD PTR _Event$[ebp]
  0009a	50		 push	 eax
  0009b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeInitializeEvent@12

; 88   :         ntStatus = t1394_SubmitIrpAsync (deviceExtension->StackDeviceObject, newIrp, pIrb);

  000a1	56		 push	 esi
  000a2	ff 75 fc	 push	 DWORD PTR _newIrp$[ebp]
  000a5	ff 33		 push	 DWORD PTR [ebx]
  000a7	e8 00 00 00 00	 call	 _t1394_SubmitIrpAsync@12
  000ac	8b d8		 mov	 ebx, eax

; 89   : 
; 90   :         if (ntStatus == STATUS_PENDING) {

  000ae	81 fb 03 01 00
	00		 cmp	 ebx, 259		; 00000103H
  000b4	75 20		 jne	 SHORT $L9799

; 91   :             KeWaitForSingleObject (&Event, Executive, KernelMode, FALSE, NULL); 

  000b6	57		 push	 edi
  000b7	57		 push	 edi
  000b8	57		 push	 edi
  000b9	57		 push	 edi
  000ba	8d 45 e4	 lea	 eax, DWORD PTR _Event$[ebp]
  000bd	50		 push	 eax
  000be	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeWaitForSingleObject@20

; 92   :             ntStatus = ioStatus.Status;

  000c4	8b 5d f4	 mov	 ebx, DWORD PTR _ioStatus$[ebp]

; 93   :         }
; 94   :     }
; 95   :     else {

  000c7	eb 0d		 jmp	 SHORT $L9799
$L9795:

; 96   :         ntStatus = t1394_SubmitIrpSynch(deviceExtension->StackDeviceObject, Irp, pIrb);

  000c9	56		 push	 esi
  000ca	ff 75 0c	 push	 DWORD PTR _Irp$[ebp]
  000cd	ff 33		 push	 DWORD PTR [ebx]
  000cf	e8 00 00 00 00	 call	 _t1394_SubmitIrpSynch@12
  000d4	8b d8		 mov	 ebx, eax
$L9799:

; 97   :     }
; 98   :     
; 99   :     if (NT_SUCCESS(ntStatus)) {

  000d6	3b df		 cmp	 ebx, edi
  000d8	7c 18		 jl	 SHORT $L9802

; 100  : 
; 101  :         *phBandwidth = pIrb->u.IsochAllocateBandwidth.hBandwidth;

  000da	8b 46 50	 mov	 eax, DWORD PTR [esi+80]
  000dd	8b 4d 18	 mov	 ecx, DWORD PTR _phBandwidth$[ebp]
  000e0	89 01		 mov	 DWORD PTR [ecx], eax

; 102  :         *pBytesPerFrameAvailable = pIrb->u.IsochAllocateBandwidth.BytesPerFrameAvailable;

  000e2	8b 46 54	 mov	 eax, DWORD PTR [esi+84]
  000e5	8b 4d 1c	 mov	 ecx, DWORD PTR _pBytesPerFrameAvailable$[ebp]
  000e8	89 01		 mov	 DWORD PTR [ecx], eax

; 103  :         *pSpeedSelected = pIrb->u.IsochAllocateBandwidth.SpeedSelected;

  000ea	8b 46 58	 mov	 eax, DWORD PTR [esi+88]
  000ed	8b 4d 20	 mov	 ecx, DWORD PTR _pSpeedSelected$[ebp]
  000f0	89 01		 mov	 DWORD PTR [ecx], eax
$L9802:

; 104  : 
; 105  :         TRACE(TL_TRACE, ("hBandwidth = 0x%x\n", *phBandwidth));
; 106  :         TRACE(TL_TRACE, ("BytesPerFrameAvailable = 0x%x\n", *pBytesPerFrameAvailable));
; 107  : 
; 108  :         // lets see if we got the speed we wanted
; 109  :         if (fulSpeed != pIrb->u.IsochAllocateBandwidth.SpeedSelected) {
; 110  : 
; 111  :             TRACE(TL_TRACE, ("Different bandwidth speed selected.\n"));
; 112  :         }
; 113  : 
; 114  :         TRACE(TL_TRACE, ("SpeedSelected = 0x%x\n", *pSpeedSelected));
; 115  :     }
; 116  :     else {
; 117  : 
; 118  :         TRACE(TL_ERROR, ("SubmitIrpSync failed = 0x%x\n", ntStatus));
; 119  :     }
; 120  : 
; 121  :     ExFreePool(pIrb);

  000f2	56		 push	 esi
  000f3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePool@4
$Exit_IsochAllocateBandwidth$9790:

; 122  : 
; 123  : Exit_IsochAllocateBandwidth:
; 124  : 
; 125  :     if (allocNewIrp) 

  000f9	80 7d 0b 00	 cmp	 BYTE PTR _allocNewIrp$[ebp], 0
  000fd	5e		 pop	 esi
  000fe	74 0f		 je	 SHORT $L9804

; 126  :         Irp->IoStatus = ioStatus;

  00100	8b 4d f4	 mov	 ecx, DWORD PTR _ioStatus$[ebp]
  00103	8b 45 0c	 mov	 eax, DWORD PTR _Irp$[ebp]
  00106	89 48 18	 mov	 DWORD PTR [eax+24], ecx
  00109	8b 4d f8	 mov	 ecx, DWORD PTR _ioStatus$[ebp+4]
  0010c	89 48 1c	 mov	 DWORD PTR [eax+28], ecx
$L9804:
  0010f	5f		 pop	 edi

; 127  :         
; 128  :     EXIT("t1394_IsochAllocateBandwidth", ntStatus);
; 129  :     return(ntStatus);

  00110	8b c3		 mov	 eax, ebx
  00112	5b		 pop	 ebx

; 130  : } // t1394_IsochAllocateBandwidth

  00113	c9		 leave
  00114	c2 1c 00	 ret	 28			; 0000001cH
_t1394_IsochAllocateBandwidth@28 ENDP
_TEXT	ENDS
PUBLIC	_t1394_IsochAllocateChannel@20
; Function compile flags: /Ogsy
;	COMDAT _t1394_IsochAllocateChannel@20
_TEXT	SEGMENT
_Event$ = -28						; size = 16
_ioStatus$ = -12					; size = 8
_newIrp$ = -4						; size = 4
_DeviceObject$ = 8					; size = 4
_allocNewIrp$ = 11					; size = 1
_Irp$ = 12						; size = 4
_nRequestedChannel$ = 16				; size = 4
_pChannel$ = 20						; size = 4
_pChannelsAvailable$ = 24				; size = 4
_t1394_IsochAllocateChannel@20 PROC NEAR		; COMDAT

; 140  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH

; 141  :     NTSTATUS            ntStatus = STATUS_SUCCESS;
; 142  :     PDEVICE_EXTENSION   deviceExtension = DeviceObject->DeviceExtension;

  00006	8b 45 08	 mov	 eax, DWORD PTR _DeviceObject$[ebp]
  00009	53		 push	 ebx
  0000a	8b 58 28	 mov	 ebx, DWORD PTR [eax+40]

; 143  :     PIRB                pIrb;
; 144  : 
; 145  :     PIRP                newIrp;
; 146  :     BOOLEAN             allocNewIrp = FALSE;
; 147  :     KEVENT              Event;
; 148  :     IO_STATUS_BLOCK     ioStatus;
; 149  :     
; 150  :     ENTER("t1394_IsochAllocateChannel");
; 151  : 
; 152  :     TRACE(TL_TRACE, ("nRequestedChannel = 0x%x\n", nRequestedChannel));
; 153  : 
; 154  :     //
; 155  :     // If this is a UserMode request create a newIrp so that the request
; 156  :     // will be issued from KernelMode
; 157  :     //
; 158  :     if (Irp->RequestorMode == UserMode) {

  0000d	8b 45 0c	 mov	 eax, DWORD PTR _Irp$[ebp]
  00010	57		 push	 edi

; 159  : 
; 160  :         newIrp = IoBuildDeviceIoControlRequest (IOCTL_1394_CLASS, deviceExtension->StackDeviceObject, 
; 161  :                             NULL, 0, NULL, 0, TRUE, &Event, &ioStatus);

  00011	33 ff		 xor	 edi, edi
  00013	80 78 20 01	 cmp	 BYTE PTR [eax+32], 1
  00017	c6 45 0b 00	 mov	 BYTE PTR _allocNewIrp$[ebp], 0
  0001b	75 30		 jne	 SHORT $L9824
  0001d	8d 45 f4	 lea	 eax, DWORD PTR _ioStatus$[ebp]
  00020	50		 push	 eax
  00021	8d 45 e4	 lea	 eax, DWORD PTR _Event$[ebp]
  00024	50		 push	 eax
  00025	6a 01		 push	 1
  00027	57		 push	 edi
  00028	57		 push	 edi
  00029	57		 push	 edi
  0002a	57		 push	 edi
  0002b	ff 33		 push	 DWORD PTR [ebx]
  0002d	68 1d 02 22 00	 push	 2228765			; 0022021dH
  00032	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoBuildDeviceIoControlRequest@36

; 162  : 
; 163  :         if (!newIrp) {

  00038	3b c7		 cmp	 eax, edi
  0003a	89 45 fc	 mov	 DWORD PTR _newIrp$[ebp], eax
  0003d	75 0a		 jne	 SHORT $L9827

; 164  : 
; 165  :             TRACE(TL_ERROR, ("Failed to allocate newIrp!\n"));        
; 166  :             ntStatus = STATUS_INSUFFICIENT_RESOURCES;

  0003f	bb 9a 00 00 c0	 mov	 ebx, -1073741670	; c000009aH

; 167  :             goto Exit_IsochAllocateChannel;            

  00044	e9 be 00 00 00	 jmp	 $L9842
$L9827:

; 168  :         }
; 169  :         allocNewIrp = TRUE;

  00049	c6 45 0b 01	 mov	 BYTE PTR _allocNewIrp$[ebp], 1
$L9824:
  0004d	56		 push	 esi

; 170  :     }
; 171  :     
; 172  :     pIrb = ExAllocatePool(NonPagedPool, sizeof(IRB));

  0004e	68 57 64 6d 20	 push	 544040023		; 206d6457H
  00053	68 58 01 00 00	 push	 344			; 00000158H
  00058	57		 push	 edi
  00059	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExAllocatePoolWithTag@12
  0005f	8b f0		 mov	 esi, eax

; 173  : 
; 174  :     if (!pIrb) {

  00061	3b f7		 cmp	 esi, edi
  00063	75 0a		 jne	 SHORT $L9831

; 175  : 
; 176  :         TRACE(TL_ERROR, ("Failed to allocate pIrb!\n"));
; 177  :         ntStatus = STATUS_INSUFFICIENT_RESOURCES;

  00065	bb 9a 00 00 c0	 mov	 ebx, -1073741670	; c000009aH

; 178  :         goto Exit_IsochAllocateChannel;

  0006a	e9 82 00 00 00	 jmp	 $Exit_IsochAllocateChannel$9829
$L9831:

; 179  :     } // if
; 180  : 
; 181  :     RtlZeroMemory (pIrb, sizeof (IRB));

  0006f	6a 56		 push	 86			; 00000056H
  00071	33 c0		 xor	 eax, eax
  00073	59		 pop	 ecx
  00074	8b fe		 mov	 edi, esi
  00076	f3 ab		 rep stosd

; 182  :     pIrb->FunctionNumber = REQUEST_ISOCH_ALLOCATE_CHANNEL;
; 183  :     pIrb->Flags = 0;
; 184  :     pIrb->u.IsochAllocateChannel.nRequestedChannel = nRequestedChannel;

  00078	8b 45 10	 mov	 eax, DWORD PTR _nRequestedChannel$[ebp]
  0007b	33 ff		 xor	 edi, edi

; 185  : 
; 186  :     //
; 187  :     // If we allocated this irp, submit it asynchronously and wait for its
; 188  :     // completion event to be signaled.  Otherwise submit it synchronously
; 189  :     //
; 190  :     if (allocNewIrp) {

  0007d	80 7d 0b 00	 cmp	 BYTE PTR _allocNewIrp$[ebp], 0
  00081	c7 06 04 00 00
	00		 mov	 DWORD PTR [esi], 4
  00087	89 7e 04	 mov	 DWORD PTR [esi+4], edi
  0008a	89 46 48	 mov	 DWORD PTR [esi+72], eax
  0008d	74 34		 je	 SHORT $L9834

; 191  : 
; 192  :         KeInitializeEvent (&Event, NotificationEvent, FALSE);

  0008f	57		 push	 edi
  00090	57		 push	 edi
  00091	8d 45 e4	 lea	 eax, DWORD PTR _Event$[ebp]
  00094	50		 push	 eax
  00095	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeInitializeEvent@12

; 193  :         ntStatus = t1394_SubmitIrpAsync (deviceExtension->StackDeviceObject, newIrp, pIrb);

  0009b	56		 push	 esi
  0009c	ff 75 fc	 push	 DWORD PTR _newIrp$[ebp]
  0009f	ff 33		 push	 DWORD PTR [ebx]
  000a1	e8 00 00 00 00	 call	 _t1394_SubmitIrpAsync@12
  000a6	8b d8		 mov	 ebx, eax

; 194  : 
; 195  :         if (ntStatus == STATUS_PENDING) {

  000a8	81 fb 03 01 00
	00		 cmp	 ebx, 259		; 00000103H
  000ae	75 20		 jne	 SHORT $L9838

; 196  :             KeWaitForSingleObject (&Event, Executive, KernelMode, FALSE, NULL); 

  000b0	57		 push	 edi
  000b1	57		 push	 edi
  000b2	57		 push	 edi
  000b3	57		 push	 edi
  000b4	8d 45 e4	 lea	 eax, DWORD PTR _Event$[ebp]
  000b7	50		 push	 eax
  000b8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeWaitForSingleObject@20

; 197  :             ntStatus = ioStatus.Status;

  000be	8b 5d f4	 mov	 ebx, DWORD PTR _ioStatus$[ebp]

; 198  :         }
; 199  :     }
; 200  :     else {

  000c1	eb 0d		 jmp	 SHORT $L9838
$L9834:

; 201  :         ntStatus = t1394_SubmitIrpSynch(deviceExtension->StackDeviceObject, Irp, pIrb);

  000c3	56		 push	 esi
  000c4	ff 75 0c	 push	 DWORD PTR _Irp$[ebp]
  000c7	ff 33		 push	 DWORD PTR [ebx]
  000c9	e8 00 00 00 00	 call	 _t1394_SubmitIrpSynch@12
  000ce	8b d8		 mov	 ebx, eax
$L9838:

; 202  :     }
; 203  :     
; 204  :     if (NT_SUCCESS(ntStatus)) {

  000d0	3b df		 cmp	 ebx, edi
  000d2	7c 16		 jl	 SHORT $L9840

; 205  : 
; 206  :         *pChannel = pIrb->u.IsochAllocateChannel.Channel;

  000d4	8b 46 4c	 mov	 eax, DWORD PTR [esi+76]
  000d7	8b 4d 14	 mov	 ecx, DWORD PTR _pChannel$[ebp]
  000da	89 01		 mov	 DWORD PTR [ecx], eax

; 207  :         *pChannelsAvailable = pIrb->u.IsochAllocateChannel.ChannelsAvailable;

  000dc	8b 4e 50	 mov	 ecx, DWORD PTR [esi+80]
  000df	8b 45 18	 mov	 eax, DWORD PTR _pChannelsAvailable$[ebp]
  000e2	89 08		 mov	 DWORD PTR [eax], ecx
  000e4	8b 4e 54	 mov	 ecx, DWORD PTR [esi+84]
  000e7	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$L9840:

; 208  : 
; 209  :         TRACE(TL_TRACE, ("Channel = 0x%x\n", *pChannel));
; 210  :         TRACE(TL_TRACE, ("ChannelsAvailable.LowPart = 0x%x\n", pChannelsAvailable->LowPart));
; 211  :         TRACE(TL_TRACE, ("ChannelsAvailable.HighPart = 0x%x\n", pChannelsAvailable->HighPart));
; 212  :     }
; 213  :     else {
; 214  : 
; 215  :         TRACE(TL_ERROR, ("SubmitIrpSync failed = 0x%x\n", ntStatus));
; 216  :     }
; 217  : 
; 218  :     ExFreePool(pIrb);

  000ea	56		 push	 esi
  000eb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePool@4
$Exit_IsochAllocateChannel$9829:

; 219  : 
; 220  : Exit_IsochAllocateChannel:
; 221  : 
; 222  :     if (allocNewIrp) 

  000f1	80 7d 0b 00	 cmp	 BYTE PTR _allocNewIrp$[ebp], 0
  000f5	5e		 pop	 esi
  000f6	74 0f		 je	 SHORT $L9842

; 223  :         Irp->IoStatus = ioStatus;

  000f8	8b 4d f4	 mov	 ecx, DWORD PTR _ioStatus$[ebp]
  000fb	8b 45 0c	 mov	 eax, DWORD PTR _Irp$[ebp]
  000fe	89 48 18	 mov	 DWORD PTR [eax+24], ecx
  00101	8b 4d f8	 mov	 ecx, DWORD PTR _ioStatus$[ebp+4]
  00104	89 48 1c	 mov	 DWORD PTR [eax+28], ecx
$L9842:
  00107	5f		 pop	 edi

; 224  :         
; 225  :     EXIT("t1394_IsochAllocateChannel", ntStatus);
; 226  :     return(ntStatus);

  00108	8b c3		 mov	 eax, ebx
  0010a	5b		 pop	 ebx

; 227  : } // t1394_IsochAllocateChannel

  0010b	c9		 leave
  0010c	c2 14 00	 ret	 20			; 00000014H
_t1394_IsochAllocateChannel@20 ENDP
_TEXT	ENDS
PUBLIC	_t1394_IsochAllocateResources@40
; Function compile flags: /Ogsy
;	COMDAT _t1394_IsochAllocateResources@40
_TEXT	SEGMENT
_Event$ = -28						; size = 16
_ioStatus$ = -12					; size = 8
_newIrp$ = -4						; size = 4
_DeviceObject$ = 8					; size = 4
_allocNewIrp$ = 11					; size = 1
_Irp$ = 12						; size = 4
_ntStatus$ = 16						; size = 4
_fulSpeed$ = 16						; size = 4
tv230 = 20						; size = 4
_fulFlags$ = 20						; size = 4
_nChannel$ = 24						; size = 4
_nMaxBytesPerFrame$ = 28				; size = 4
_nNumberOfBuffers$ = 32					; size = 4
_nMaxBufferSize$ = 36					; size = 4
_nQuadletsToStrip$ = 40					; size = 4
_phResource$ = 44					; size = 4
_t1394_IsochAllocateResources@40 PROC NEAR		; COMDAT

; 242  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH

; 243  :     NTSTATUS            ntStatus = STATUS_SUCCESS;
; 244  :     PDEVICE_EXTENSION   deviceExtension = DeviceObject->DeviceExtension;

  00006	8b 45 08	 mov	 eax, DWORD PTR _DeviceObject$[ebp]
  00009	53		 push	 ebx
  0000a	8b 58 28	 mov	 ebx, DWORD PTR [eax+40]

; 245  :     PIRB                pIrb;
; 246  : 
; 247  :     PIRP                newIrp;
; 248  :     BOOLEAN             allocNewIrp = FALSE;
; 249  :     KEVENT              Event;
; 250  :     IO_STATUS_BLOCK     ioStatus;
; 251  :     
; 252  :     ENTER("t1394_IsochAllocateResources");
; 253  : 
; 254  :     TRACE(TL_TRACE, ("fulSpeed = 0x%x\n", fulSpeed));
; 255  :     TRACE(TL_TRACE, ("fulFlags = 0x%x\n", fulFlags));
; 256  :     TRACE(TL_TRACE, ("nChannel = 0x%x\n", nChannel));
; 257  :     TRACE(TL_TRACE, ("nMaxBytesPerFrame = 0x%x\n", nMaxBytesPerFrame));
; 258  :     TRACE(TL_TRACE, ("nNumberOfBuffers = 0x%x\n", nNumberOfBuffers));
; 259  :     TRACE(TL_TRACE, ("nMaxBufferSize = 0x%x\n", nMaxBufferSize));
; 260  :     TRACE(TL_TRACE, ("nQuadletsToStrip = 0x%x\n", nQuadletsToStrip));
; 261  : 
; 262  :     //
; 263  :     // If this is a UserMode request create a newIrp so that the request
; 264  :     // will be issued from KernelMode
; 265  :     //
; 266  :     if (Irp->RequestorMode == UserMode) {

  0000d	8b 45 0c	 mov	 eax, DWORD PTR _Irp$[ebp]
  00010	57		 push	 edi

; 267  : 
; 268  :         newIrp = IoBuildDeviceIoControlRequest (IOCTL_1394_CLASS, deviceExtension->StackDeviceObject, 
; 269  :                             NULL, 0, NULL, 0, TRUE, &Event, &ioStatus);

  00011	33 ff		 xor	 edi, edi
  00013	80 78 20 01	 cmp	 BYTE PTR [eax+32], 1
  00017	c6 45 0b 00	 mov	 BYTE PTR _allocNewIrp$[ebp], 0
  0001b	75 32		 jne	 SHORT $L9872
  0001d	8d 45 f4	 lea	 eax, DWORD PTR _ioStatus$[ebp]
  00020	50		 push	 eax
  00021	8d 45 e4	 lea	 eax, DWORD PTR _Event$[ebp]
  00024	50		 push	 eax
  00025	6a 01		 push	 1
  00027	57		 push	 edi
  00028	57		 push	 edi
  00029	57		 push	 edi
  0002a	57		 push	 edi
  0002b	ff 33		 push	 DWORD PTR [ebx]
  0002d	68 1d 02 22 00	 push	 2228765			; 0022021dH
  00032	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoBuildDeviceIoControlRequest@36

; 270  : 
; 271  :         if (!newIrp) {

  00038	3b c7		 cmp	 eax, edi
  0003a	89 45 fc	 mov	 DWORD PTR _newIrp$[ebp], eax
  0003d	75 0c		 jne	 SHORT $L9875

; 272  : 
; 273  :             TRACE(TL_ERROR, ("Failed to allocate newIrp!\n"));        
; 274  :             ntStatus = STATUS_INSUFFICIENT_RESOURCES;

  0003f	c7 45 10 9a 00
	00 c0		 mov	 DWORD PTR _ntStatus$[ebp], -1073741670 ; c000009aH

; 275  :             goto Exit_IsochAllocateResources;            

  00046	e9 18 01 00 00	 jmp	 $L10842
$L9875:

; 276  :         }
; 277  :         allocNewIrp = TRUE;

  0004b	c6 45 0b 01	 mov	 BYTE PTR _allocNewIrp$[ebp], 1
$L9872:
  0004f	56		 push	 esi

; 278  :     }
; 279  :     
; 280  :     pIrb = ExAllocatePool(NonPagedPool, sizeof(IRB));

  00050	68 57 64 6d 20	 push	 544040023		; 206d6457H
  00055	68 58 01 00 00	 push	 344			; 00000158H
  0005a	57		 push	 edi
  0005b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExAllocatePoolWithTag@12
  00061	8b f0		 mov	 esi, eax

; 281  : 
; 282  :     if (!pIrb) {

  00063	3b f7		 cmp	 esi, edi
  00065	75 0c		 jne	 SHORT $L9879

; 283  : 
; 284  :         TRACE(TL_ERROR, ("Failed to allocate pIrb!\n"));
; 285  :         ntStatus = STATUS_INSUFFICIENT_RESOURCES;

  00067	c7 45 10 9a 00
	00 c0		 mov	 DWORD PTR _ntStatus$[ebp], -1073741670 ; c000009aH

; 286  :         goto Exit_IsochAllocateResources;

  0006e	e9 da 00 00 00	 jmp	 $Exit_IsochAllocateResources$9877
$L9879:

; 287  :     } // if
; 288  : 
; 289  :     RtlZeroMemory (pIrb, sizeof (IRB));

  00073	33 c0		 xor	 eax, eax
  00075	6a 56		 push	 86			; 00000056H
  00077	59		 pop	 ecx
  00078	8b fe		 mov	 edi, esi
  0007a	f3 ab		 rep stosd

; 290  :     pIrb->FunctionNumber = REQUEST_ISOCH_ALLOCATE_RESOURCES;
; 291  :     pIrb->Flags = 0;
; 292  :     pIrb->u.IsochAllocateResources.fulSpeed = fulSpeed;

  0007c	8b 45 10	 mov	 eax, DWORD PTR _fulSpeed$[ebp]
  0007f	89 46 48	 mov	 DWORD PTR [esi+72], eax

; 293  :     pIrb->u.IsochAllocateResources.fulFlags = fulFlags;

  00082	8b 45 14	 mov	 eax, DWORD PTR _fulFlags$[ebp]
  00085	89 46 4c	 mov	 DWORD PTR [esi+76], eax

; 294  :     pIrb->u.IsochAllocateResources.nChannel = nChannel;

  00088	8b 45 18	 mov	 eax, DWORD PTR _nChannel$[ebp]
  0008b	89 46 50	 mov	 DWORD PTR [esi+80], eax

; 295  :     pIrb->u.IsochAllocateResources.nMaxBytesPerFrame = nMaxBytesPerFrame;

  0008e	8b 45 1c	 mov	 eax, DWORD PTR _nMaxBytesPerFrame$[ebp]
  00091	89 46 54	 mov	 DWORD PTR [esi+84], eax

; 296  :     pIrb->u.IsochAllocateResources.nNumberOfBuffers = nNumberOfBuffers;

  00094	8b 45 20	 mov	 eax, DWORD PTR _nNumberOfBuffers$[ebp]
  00097	89 46 58	 mov	 DWORD PTR [esi+88], eax

; 297  :     pIrb->u.IsochAllocateResources.nMaxBufferSize = nMaxBufferSize;

  0009a	8b 45 24	 mov	 eax, DWORD PTR _nMaxBufferSize$[ebp]
  0009d	33 ff		 xor	 edi, edi

; 298  :     pIrb->u.IsochAllocateResources.nQuadletsToStrip = nQuadletsToStrip;
; 299  : 
; 300  :     //
; 301  :     // If we allocated this irp, submit it asynchronously and wait for its
; 302  :     // completion event to be signaled.  Otherwise submit it synchronously
; 303  :     //
; 304  :     if (allocNewIrp) {

  0009f	80 7d 0b 00	 cmp	 BYTE PTR _allocNewIrp$[ebp], 0
  000a3	89 46 5c	 mov	 DWORD PTR [esi+92], eax
  000a6	8b 45 28	 mov	 eax, DWORD PTR _nQuadletsToStrip$[ebp]
  000a9	c7 06 05 00 00
	00		 mov	 DWORD PTR [esi], 5
  000af	89 7e 04	 mov	 DWORD PTR [esi+4], edi
  000b2	89 46 60	 mov	 DWORD PTR [esi+96], eax
  000b5	74 34		 je	 SHORT $L9882

; 305  : 
; 306  :         KeInitializeEvent (&Event, NotificationEvent, FALSE);

  000b7	57		 push	 edi
  000b8	57		 push	 edi
  000b9	8d 45 e4	 lea	 eax, DWORD PTR _Event$[ebp]
  000bc	50		 push	 eax
  000bd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeInitializeEvent@12

; 307  :         ntStatus = t1394_SubmitIrpAsync (deviceExtension->StackDeviceObject, newIrp, pIrb);

  000c3	56		 push	 esi
  000c4	ff 75 fc	 push	 DWORD PTR _newIrp$[ebp]
  000c7	ff 33		 push	 DWORD PTR [ebx]
  000c9	e8 00 00 00 00	 call	 _t1394_SubmitIrpAsync@12

; 308  : 
; 309  :         if (ntStatus == STATUS_PENDING) {

  000ce	3d 03 01 00 00	 cmp	 eax, 259		; 00000103H
  000d3	89 45 10	 mov	 DWORD PTR _ntStatus$[ebp], eax
  000d6	75 21		 jne	 SHORT $L9886

; 310  :             KeWaitForSingleObject (&Event, Executive, KernelMode, FALSE, NULL); 

  000d8	57		 push	 edi
  000d9	57		 push	 edi
  000da	57		 push	 edi
  000db	57		 push	 edi
  000dc	8d 45 e4	 lea	 eax, DWORD PTR _Event$[ebp]
  000df	50		 push	 eax
  000e0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeWaitForSingleObject@20

; 311  :             ntStatus = ioStatus.Status;

  000e6	8b 45 f4	 mov	 eax, DWORD PTR _ioStatus$[ebp]

; 312  :         }
; 313  :     }
; 314  :     else {

  000e9	eb 0b		 jmp	 SHORT $L10843
$L9882:

; 315  :         ntStatus = t1394_SubmitIrpSynch(deviceExtension->StackDeviceObject, Irp, pIrb);

  000eb	56		 push	 esi
  000ec	ff 75 0c	 push	 DWORD PTR _Irp$[ebp]
  000ef	ff 33		 push	 DWORD PTR [ebx]
  000f1	e8 00 00 00 00	 call	 _t1394_SubmitIrpSynch@12
$L10843:
  000f6	89 45 10	 mov	 DWORD PTR _ntStatus$[ebp], eax
$L9886:

; 316  :     }
; 317  :     
; 318  :     if (NT_SUCCESS(ntStatus)) {

  000f9	39 7d 10	 cmp	 DWORD PTR _ntStatus$[ebp], edi
  000fc	7c 48		 jl	 SHORT $L9892

; 319  : 
; 320  :         PISOCH_RESOURCE_DATA    IsochResourceData;
; 321  :         KIRQL                   Irql;
; 322  : 
; 323  :         *phResource = pIrb->u.IsochAllocateResources.hResource;

  000fe	8b 46 64	 mov	 eax, DWORD PTR [esi+100]
  00101	8b 4d 2c	 mov	 ecx, DWORD PTR _phResource$[ebp]

; 324  : 
; 325  :         TRACE(TL_TRACE, ("hResource = 0x%x\n", *phResource));
; 326  : 
; 327  :         // need to add to our list...
; 328  :         IsochResourceData = ExAllocatePool(NonPagedPool, sizeof(ISOCH_RESOURCE_DATA));

  00104	68 57 64 6d 20	 push	 544040023		; 206d6457H
  00109	6a 0c		 push	 12			; 0000000cH
  0010b	57		 push	 edi
  0010c	89 01		 mov	 DWORD PTR [ecx], eax
  0010e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExAllocatePoolWithTag@12
  00114	8b f8		 mov	 edi, eax

; 329  : 
; 330  :         if (IsochResourceData) {

  00116	85 ff		 test	 edi, edi
  00118	74 2c		 je	 SHORT $L9892

; 331  : 
; 332  :             IsochResourceData->hResource = pIrb->u.IsochAllocateResources.hResource;

  0011a	8b 46 64	 mov	 eax, DWORD PTR [esi+100]

; 333  : 
; 334  :             KeAcquireSpinLock(&deviceExtension->IsochResourceSpinLock, &Irql);

  0011d	8d 4b 24	 lea	 ecx, DWORD PTR [ebx+36]
  00120	89 47 08	 mov	 DWORD PTR [edi+8], eax
  00123	89 4d 14	 mov	 DWORD PTR tv230[ebp], ecx
  00126	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@KfAcquireSpinLock@4

; 335  :             InsertHeadList(&deviceExtension->IsochResourceData, &IsochResourceData->IsochResourceList);

  0012c	8d 4b 58	 lea	 ecx, DWORD PTR [ebx+88]
  0012f	8b 19		 mov	 ebx, DWORD PTR [ecx]
  00131	89 4f 04	 mov	 DWORD PTR [edi+4], ecx
  00134	89 1f		 mov	 DWORD PTR [edi], ebx
  00136	89 7b 04	 mov	 DWORD PTR [ebx+4], edi
  00139	89 39		 mov	 DWORD PTR [ecx], edi

; 336  :             KeReleaseSpinLock(&deviceExtension->IsochResourceSpinLock, Irql);

  0013b	8b 4d 14	 mov	 ecx, DWORD PTR tv230[ebp]
  0013e	8a d0		 mov	 dl, al
  00140	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@KfReleaseSpinLock@8
$L9892:

; 337  :         }
; 338  :         else {
; 339  : 
; 340  :             TRACE(TL_WARNING, ("Failed to allocate IsochResourceData!\n"));
; 341  :         }
; 342  : 
; 343  :     }
; 344  :     else {
; 345  : 
; 346  :         TRACE(TL_ERROR, ("SubmitIrpSync failed = 0x%x\n", ntStatus));
; 347  :     }
; 348  : 
; 349  :     ExFreePool(pIrb);

  00146	56		 push	 esi
  00147	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePool@4
$Exit_IsochAllocateResources$9877:

; 350  : 
; 351  : Exit_IsochAllocateResources:
; 352  : 
; 353  :     if (allocNewIrp) 

  0014d	80 7d 0b 00	 cmp	 BYTE PTR _allocNewIrp$[ebp], 0
  00151	5e		 pop	 esi
  00152	74 0f		 je	 SHORT $L10842

; 354  :         Irp->IoStatus = ioStatus;

  00154	8b 4d f4	 mov	 ecx, DWORD PTR _ioStatus$[ebp]
  00157	8b 45 0c	 mov	 eax, DWORD PTR _Irp$[ebp]
  0015a	89 48 18	 mov	 DWORD PTR [eax+24], ecx
  0015d	8b 4d f8	 mov	 ecx, DWORD PTR _ioStatus$[ebp+4]
  00160	89 48 1c	 mov	 DWORD PTR [eax+28], ecx
$L10842:

; 355  : 
; 356  :     EXIT("t1394_IsochAllocateResources", ntStatus);
; 357  :     return(ntStatus);

  00163	8b 45 10	 mov	 eax, DWORD PTR _ntStatus$[ebp]
  00166	5f		 pop	 edi
  00167	5b		 pop	 ebx

; 358  : } // t1394_IsochAllocateResources

  00168	c9		 leave
  00169	c2 28 00	 ret	 40			; 00000028H
_t1394_IsochAllocateResources@40 ENDP
_TEXT	ENDS
PUBLIC	_t1394_IsochDetachBuffers@20
; Function compile flags: /Ogsy
;	COMDAT _t1394_IsochDetachBuffers@20
_TEXT	SEGMENT
_Event$ = -28						; size = 16
_ioStatus$ = -12					; size = 8
_newIrp$ = -4						; size = 4
_DeviceObject$ = 8					; size = 4
_allocNewIrp$ = 11					; size = 1
_Irp$ = 12						; size = 4
_ntStatus$ = 16						; size = 4
_hResource$ = 16					; size = 4
tv176 = 20						; size = 4
_nNumberOfDescriptors$ = 20				; size = 4
_IsochDescriptor$ = 24					; size = 4
_t1394_IsochDetachBuffers@20 PROC NEAR			; COMDAT

; 631  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH

; 632  :     NTSTATUS            ntStatus = STATUS_SUCCESS;
; 633  :     PDEVICE_EXTENSION   deviceExtension = DeviceObject->DeviceExtension;

  00006	8b 45 08	 mov	 eax, DWORD PTR _DeviceObject$[ebp]
  00009	53		 push	 ebx
  0000a	8b 58 28	 mov	 ebx, DWORD PTR [eax+40]

; 634  :     PIRB                pIrb;
; 635  :     ULONG               i;
; 636  : 
; 637  :     PIRP                newIrp;
; 638  :     BOOLEAN             allocNewIrp = FALSE;
; 639  :     KEVENT              Event;
; 640  :     IO_STATUS_BLOCK     ioStatus;
; 641  :     
; 642  :     ENTER("");
; 643  : 
; 644  :     TRACE(TL_TRACE, ("hResource = 0x%x\n", hResource));
; 645  :     TRACE(TL_TRACE, ("nNumberOfDescriptors = 0x%x\n", nNumberOfDescriptors));
; 646  :     TRACE(TL_TRACE, ("IsochDescriptor = 0x%x\n", IsochDescriptor));
; 647  : 
; 648  :     //
; 649  :     // If this is a UserMode request create a newIrp so that the request
; 650  :     // will be issued from KernelMode
; 651  :     //
; 652  :     if (Irp->RequestorMode == UserMode) {

  0000d	8b 45 0c	 mov	 eax, DWORD PTR _Irp$[ebp]
  00010	57		 push	 edi

; 653  : 
; 654  :         newIrp = IoBuildDeviceIoControlRequest (IOCTL_1394_CLASS, deviceExtension->StackDeviceObject, 
; 655  :                             NULL, 0, NULL, 0, TRUE, &Event, &ioStatus);

  00011	33 ff		 xor	 edi, edi
  00013	80 78 20 01	 cmp	 BYTE PTR [eax+32], 1
  00017	c6 45 0b 00	 mov	 BYTE PTR _allocNewIrp$[ebp], 0
  0001b	75 32		 jne	 SHORT $L9994
  0001d	8d 45 f4	 lea	 eax, DWORD PTR _ioStatus$[ebp]
  00020	50		 push	 eax
  00021	8d 45 e4	 lea	 eax, DWORD PTR _Event$[ebp]
  00024	50		 push	 eax
  00025	6a 01		 push	 1
  00027	57		 push	 edi
  00028	57		 push	 edi
  00029	57		 push	 edi
  0002a	57		 push	 edi
  0002b	ff 33		 push	 DWORD PTR [ebx]
  0002d	68 1d 02 22 00	 push	 2228765			; 0022021dH
  00032	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoBuildDeviceIoControlRequest@36

; 656  : 
; 657  :         if (!newIrp) {

  00038	3b c7		 cmp	 eax, edi
  0003a	89 45 fc	 mov	 DWORD PTR _newIrp$[ebp], eax
  0003d	75 0c		 jne	 SHORT $L9997

; 658  : 
; 659  :             TRACE(TL_ERROR, ("Failed to allocate newIrp!\n"));        
; 660  :             ntStatus = STATUS_INSUFFICIENT_RESOURCES;

  0003f	c7 45 10 9a 00
	00 c0		 mov	 DWORD PTR _ntStatus$[ebp], -1073741670 ; c000009aH

; 661  :             goto Exit_IsochDetachBuffers;            

  00046	e9 e9 00 00 00	 jmp	 $L10851
$L9997:

; 662  :         }
; 663  :         allocNewIrp = TRUE;

  0004b	c6 45 0b 01	 mov	 BYTE PTR _allocNewIrp$[ebp], 1
$L9994:
  0004f	56		 push	 esi

; 664  :     }
; 665  :     
; 666  :     pIrb = ExAllocatePool(NonPagedPool, sizeof(IRB));

  00050	68 57 64 6d 20	 push	 544040023		; 206d6457H
  00055	68 58 01 00 00	 push	 344			; 00000158H
  0005a	57		 push	 edi
  0005b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExAllocatePoolWithTag@12
  00061	8b f0		 mov	 esi, eax

; 667  : 
; 668  :     if (!pIrb) {

  00063	3b f7		 cmp	 esi, edi
  00065	75 0c		 jne	 SHORT $L10001

; 669  : 
; 670  :         TRACE(TL_ERROR, ("Failed to allocate pIrb!\n"));
; 671  :         ntStatus = STATUS_INSUFFICIENT_RESOURCES;

  00067	c7 45 10 9a 00
	00 c0		 mov	 DWORD PTR _ntStatus$[ebp], -1073741670 ; c000009aH

; 672  :         goto Exit_IsochDetachBuffers;

  0006e	e9 ab 00 00 00	 jmp	 $Exit_IsochDetachBuffers$9999
$L10001:

; 673  :     } // if
; 674  : 
; 675  :     RtlZeroMemory (pIrb, sizeof (IRB));

  00073	33 c0		 xor	 eax, eax
  00075	6a 56		 push	 86			; 00000056H
  00077	59		 pop	 ecx
  00078	8b fe		 mov	 edi, esi
  0007a	f3 ab		 rep stosd

; 676  :     pIrb->FunctionNumber = REQUEST_ISOCH_DETACH_BUFFERS;
; 677  :     pIrb->Flags = 0;
; 678  :     pIrb->u.IsochDetachBuffers.hResource = hResource;

  0007c	8b 45 10	 mov	 eax, DWORD PTR _hResource$[ebp]
  0007f	89 46 48	 mov	 DWORD PTR [esi+72], eax

; 679  :     pIrb->u.IsochDetachBuffers.nNumberOfDescriptors = nNumberOfDescriptors;

  00082	8b 45 14	 mov	 eax, DWORD PTR _nNumberOfDescriptors$[ebp]
  00085	33 ff		 xor	 edi, edi

; 680  :     pIrb->u.IsochDetachBuffers.pIsochDescriptor = IsochDescriptor;
; 681  : 
; 682  :     //
; 683  :     // If we allocated this irp, submit it asynchronously and wait for its
; 684  :     // completion event to be signaled.  Otherwise submit it synchronously
; 685  :     //
; 686  :     if (allocNewIrp) {

  00087	80 7d 0b 00	 cmp	 BYTE PTR _allocNewIrp$[ebp], 0
  0008b	89 46 4c	 mov	 DWORD PTR [esi+76], eax
  0008e	8b 45 18	 mov	 eax, DWORD PTR _IsochDescriptor$[ebp]
  00091	c7 06 07 00 00
	00		 mov	 DWORD PTR [esi], 7
  00097	89 7e 04	 mov	 DWORD PTR [esi+4], edi
  0009a	89 46 50	 mov	 DWORD PTR [esi+80], eax
  0009d	74 34		 je	 SHORT $L10004

; 687  : 
; 688  :         KeInitializeEvent (&Event, NotificationEvent, FALSE);

  0009f	57		 push	 edi
  000a0	57		 push	 edi
  000a1	8d 45 e4	 lea	 eax, DWORD PTR _Event$[ebp]
  000a4	50		 push	 eax
  000a5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeInitializeEvent@12

; 689  :         ntStatus = t1394_SubmitIrpAsync (deviceExtension->StackDeviceObject, newIrp, pIrb);

  000ab	56		 push	 esi
  000ac	ff 75 fc	 push	 DWORD PTR _newIrp$[ebp]
  000af	ff 33		 push	 DWORD PTR [ebx]
  000b1	e8 00 00 00 00	 call	 _t1394_SubmitIrpAsync@12

; 690  : 
; 691  :         if (ntStatus == STATUS_PENDING) {

  000b6	3d 03 01 00 00	 cmp	 eax, 259		; 00000103H
  000bb	89 45 10	 mov	 DWORD PTR _ntStatus$[ebp], eax
  000be	75 21		 jne	 SHORT $L10008

; 692  :             KeWaitForSingleObject (&Event, Executive, KernelMode, FALSE, NULL); 

  000c0	57		 push	 edi
  000c1	57		 push	 edi
  000c2	57		 push	 edi
  000c3	57		 push	 edi
  000c4	8d 45 e4	 lea	 eax, DWORD PTR _Event$[ebp]
  000c7	50		 push	 eax
  000c8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeWaitForSingleObject@20

; 693  :             ntStatus = ioStatus.Status;

  000ce	8b 45 f4	 mov	 eax, DWORD PTR _ioStatus$[ebp]

; 694  :         }
; 695  :     }
; 696  :     else {

  000d1	eb 0b		 jmp	 SHORT $L10852
$L10004:

; 697  :         ntStatus = t1394_SubmitIrpSynch(deviceExtension->StackDeviceObject, Irp, pIrb);

  000d3	56		 push	 esi
  000d4	ff 75 0c	 push	 DWORD PTR _Irp$[ebp]
  000d7	ff 33		 push	 DWORD PTR [ebx]
  000d9	e8 00 00 00 00	 call	 _t1394_SubmitIrpSynch@12
$L10852:
  000de	89 45 10	 mov	 DWORD PTR _ntStatus$[ebp], eax
$L10008:

; 698  :     }
; 699  :     
; 700  :     if (!NT_SUCCESS(ntStatus)) {

  000e1	39 7d 10	 cmp	 DWORD PTR _ntStatus$[ebp], edi
  000e4	7c 31		 jl	 SHORT $L10850

; 701  : 
; 702  :         TRACE(TL_ERROR, ("SubmitIrpSync failed = 0x%x\n", ntStatus));
; 703  :     }
; 704  :     else
; 705  :     {
; 706  :         // if we detached the descriptor, free up the allocations
; 707  :         for (i=0; i<nNumberOfDescriptors; i++)

  000e6	8b 45 14	 mov	 eax, DWORD PTR _nNumberOfDescriptors$[ebp]
  000e9	3b c7		 cmp	 eax, edi
  000eb	76 21		 jbe	 SHORT $L10849
  000ed	8b 5d 18	 mov	 ebx, DWORD PTR _IsochDescriptor$[ebp]
  000f0	83 c3 04	 add	 ebx, 4
  000f3	89 45 14	 mov	 DWORD PTR tv176[ebp], eax
$L10012:

; 708  : 		{
; 709  : 			if (IsochDescriptor[i].Mdl)

  000f6	8b 03		 mov	 eax, DWORD PTR [ebx]
  000f8	3b c7		 cmp	 eax, edi
  000fa	74 07		 je	 SHORT $L10013

; 710  : 			{
; 711  : 				IoFreeMdl(IsochDescriptor[i].Mdl);

  000fc	50		 push	 eax
  000fd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoFreeMdl@4
$L10013:
  00103	81 c3 ac 00 00
	00		 add	 ebx, 172		; 000000acH
  00109	ff 4d 14	 dec	 DWORD PTR tv176[ebp]
  0010c	75 e8		 jne	 SHORT $L10012
$L10849:

; 712  : 			}
; 713  : 		}
; 714  :         ExFreePool(IsochDescriptor);

  0010e	ff 75 18	 push	 DWORD PTR _IsochDescriptor$[ebp]
  00111	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePool@4
$L10850:

; 715  :     }
; 716  : 
; 717  :     if (pIrb)
; 718  :         ExFreePool(pIrb);

  00117	56		 push	 esi
  00118	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePool@4
$Exit_IsochDetachBuffers$9999:

; 719  : 
; 720  : 
; 721  : 
; 722  : Exit_IsochDetachBuffers:
; 723  : 
; 724  :     if (allocNewIrp) 

  0011e	80 7d 0b 00	 cmp	 BYTE PTR _allocNewIrp$[ebp], 0
  00122	5e		 pop	 esi
  00123	74 0f		 je	 SHORT $L10851

; 725  :         Irp->IoStatus = ioStatus;

  00125	8b 4d f4	 mov	 ecx, DWORD PTR _ioStatus$[ebp]
  00128	8b 45 0c	 mov	 eax, DWORD PTR _Irp$[ebp]
  0012b	89 48 18	 mov	 DWORD PTR [eax+24], ecx
  0012e	8b 4d f8	 mov	 ecx, DWORD PTR _ioStatus$[ebp+4]
  00131	89 48 1c	 mov	 DWORD PTR [eax+28], ecx
$L10851:

; 726  :         
; 727  :     EXIT("t1394_IsochDetachBuffers", ntStatus);
; 728  :     return(ntStatus);

  00134	8b 45 10	 mov	 eax, DWORD PTR _ntStatus$[ebp]
  00137	5f		 pop	 edi
  00138	5b		 pop	 ebx

; 729  : } // t1394_IsochDetachBuffers

  00139	c9		 leave
  0013a	c2 14 00	 ret	 20			; 00000014H
_t1394_IsochDetachBuffers@20 ENDP
_TEXT	ENDS
PUBLIC	_t1394_IsochFreeBandwidth@12
; Function compile flags: /Ogsy
;	COMDAT _t1394_IsochFreeBandwidth@12
_TEXT	SEGMENT
_Event$ = -28						; size = 16
_ioStatus$ = -12					; size = 8
_newIrp$ = -4						; size = 4
_DeviceObject$ = 8					; size = 4
_allocNewIrp$ = 11					; size = 1
_Irp$ = 12						; size = 4
_hBandwidth$ = 16					; size = 4
_t1394_IsochFreeBandwidth@12 PROC NEAR			; COMDAT

; 737  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH

; 738  :     NTSTATUS            ntStatus = STATUS_SUCCESS;
; 739  :     PDEVICE_EXTENSION   deviceExtension = DeviceObject->DeviceExtension;

  00006	8b 45 08	 mov	 eax, DWORD PTR _DeviceObject$[ebp]
  00009	56		 push	 esi
  0000a	8b 70 28	 mov	 esi, DWORD PTR [eax+40]

; 740  :     PIRB                pIrb;
; 741  : 
; 742  :     PIRP                newIrp;
; 743  :     BOOLEAN             allocNewIrp = FALSE;
; 744  :     KEVENT              Event;
; 745  :     IO_STATUS_BLOCK     ioStatus;
; 746  :     
; 747  :     ENTER("t1394_IsochFreeBandwidth");
; 748  : 
; 749  :     TRACE(TL_TRACE, ("hBandwidth = 0x%x\n", hBandwidth));
; 750  : 
; 751  :     //
; 752  :     // If this is a UserMode request create a newIrp so that the request
; 753  :     // will be issued from KernelMode
; 754  :     //
; 755  :     if (Irp->RequestorMode == UserMode) {

  0000d	8b 45 0c	 mov	 eax, DWORD PTR _Irp$[ebp]
  00010	57		 push	 edi

; 756  : 
; 757  :         newIrp = IoBuildDeviceIoControlRequest (IOCTL_1394_CLASS, deviceExtension->StackDeviceObject, 
; 758  :                             NULL, 0, NULL, 0, TRUE, &Event, &ioStatus);

  00011	33 ff		 xor	 edi, edi
  00013	80 78 20 01	 cmp	 BYTE PTR [eax+32], 1
  00017	c6 45 0b 00	 mov	 BYTE PTR _allocNewIrp$[ebp], 0
  0001b	75 30		 jne	 SHORT $L10033
  0001d	8d 45 f4	 lea	 eax, DWORD PTR _ioStatus$[ebp]
  00020	50		 push	 eax
  00021	8d 45 e4	 lea	 eax, DWORD PTR _Event$[ebp]
  00024	50		 push	 eax
  00025	6a 01		 push	 1
  00027	57		 push	 edi
  00028	57		 push	 edi
  00029	57		 push	 edi
  0002a	57		 push	 edi
  0002b	ff 36		 push	 DWORD PTR [esi]
  0002d	68 1d 02 22 00	 push	 2228765			; 0022021dH
  00032	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoBuildDeviceIoControlRequest@36

; 759  : 
; 760  :         if (!newIrp) {

  00038	3b c7		 cmp	 eax, edi
  0003a	89 45 fc	 mov	 DWORD PTR _newIrp$[ebp], eax
  0003d	75 0a		 jne	 SHORT $L10036

; 761  : 
; 762  :             TRACE(TL_ERROR, ("Failed to allocate newIrp!\n"));        
; 763  :             ntStatus = STATUS_INSUFFICIENT_RESOURCES;

  0003f	be 9a 00 00 c0	 mov	 esi, -1073741670	; c000009aH

; 764  :             goto Exit_IsochFreeBandwidth;            

  00044	e9 a1 00 00 00	 jmp	 $L10050
$L10036:

; 765  :         }
; 766  :         allocNewIrp = TRUE;

  00049	c6 45 0b 01	 mov	 BYTE PTR _allocNewIrp$[ebp], 1
$L10033:
  0004d	53		 push	 ebx

; 767  :     }
; 768  :     
; 769  :     pIrb = ExAllocatePool(NonPagedPool, sizeof(IRB));

  0004e	68 57 64 6d 20	 push	 544040023		; 206d6457H
  00053	68 58 01 00 00	 push	 344			; 00000158H
  00058	57		 push	 edi
  00059	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExAllocatePoolWithTag@12
  0005f	8b d8		 mov	 ebx, eax

; 770  : 
; 771  :     if (!pIrb) {

  00061	3b df		 cmp	 ebx, edi
  00063	75 07		 jne	 SHORT $L10040

; 772  : 
; 773  :         TRACE(TL_ERROR, ("Failed to allocate pIrb!\n"));
; 774  :         ntStatus = STATUS_INSUFFICIENT_RESOURCES;

  00065	be 9a 00 00 c0	 mov	 esi, -1073741670	; c000009aH

; 775  :         goto Exit_IsochFreeBandwidth;

  0006a	eb 68		 jmp	 SHORT $Exit_IsochFreeBandwidth$10038
$L10040:

; 776  :     } // if
; 777  : 
; 778  :     RtlZeroMemory (pIrb, sizeof (IRB));

  0006c	6a 56		 push	 86			; 00000056H
  0006e	33 c0		 xor	 eax, eax
  00070	59		 pop	 ecx
  00071	8b fb		 mov	 edi, ebx
  00073	f3 ab		 rep stosd

; 779  :     pIrb->FunctionNumber = REQUEST_ISOCH_FREE_BANDWIDTH;
; 780  :     pIrb->Flags = 0;
; 781  :     pIrb->u.IsochFreeBandwidth.hBandwidth = hBandwidth;

  00075	8b 45 10	 mov	 eax, DWORD PTR _hBandwidth$[ebp]
  00078	33 ff		 xor	 edi, edi

; 782  : 
; 783  :     //
; 784  :     // If we allocated this irp, submit it asynchronously and wait for its
; 785  :     // completion event to be signaled.  Otherwise submit it synchronously
; 786  :     //
; 787  :     if (allocNewIrp) {

  0007a	80 7d 0b 00	 cmp	 BYTE PTR _allocNewIrp$[ebp], 0
  0007e	c7 03 08 00 00
	00		 mov	 DWORD PTR [ebx], 8
  00084	89 7b 04	 mov	 DWORD PTR [ebx+4], edi
  00087	89 43 48	 mov	 DWORD PTR [ebx+72], eax
  0008a	74 34		 je	 SHORT $L10043

; 788  : 
; 789  :         KeInitializeEvent (&Event, NotificationEvent, FALSE);

  0008c	57		 push	 edi
  0008d	57		 push	 edi
  0008e	8d 45 e4	 lea	 eax, DWORD PTR _Event$[ebp]
  00091	50		 push	 eax
  00092	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeInitializeEvent@12

; 790  :         ntStatus = t1394_SubmitIrpAsync (deviceExtension->StackDeviceObject, newIrp, pIrb);

  00098	53		 push	 ebx
  00099	ff 75 fc	 push	 DWORD PTR _newIrp$[ebp]
  0009c	ff 36		 push	 DWORD PTR [esi]
  0009e	e8 00 00 00 00	 call	 _t1394_SubmitIrpAsync@12
  000a3	8b f0		 mov	 esi, eax

; 791  : 
; 792  :         if (ntStatus == STATUS_PENDING) {

  000a5	81 fe 03 01 00
	00		 cmp	 esi, 259		; 00000103H
  000ab	75 20		 jne	 SHORT $L10047

; 793  :             KeWaitForSingleObject (&Event, Executive, KernelMode, FALSE, NULL); 

  000ad	57		 push	 edi
  000ae	57		 push	 edi
  000af	57		 push	 edi
  000b0	57		 push	 edi
  000b1	8d 45 e4	 lea	 eax, DWORD PTR _Event$[ebp]
  000b4	50		 push	 eax
  000b5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeWaitForSingleObject@20

; 794  :             ntStatus = ioStatus.Status;

  000bb	8b 75 f4	 mov	 esi, DWORD PTR _ioStatus$[ebp]

; 795  :         }
; 796  :     }
; 797  :     else {

  000be	eb 0d		 jmp	 SHORT $L10047
$L10043:

; 798  :         ntStatus = t1394_SubmitIrpSynch(deviceExtension->StackDeviceObject, Irp, pIrb);

  000c0	53		 push	 ebx
  000c1	ff 75 0c	 push	 DWORD PTR _Irp$[ebp]
  000c4	ff 36		 push	 DWORD PTR [esi]
  000c6	e8 00 00 00 00	 call	 _t1394_SubmitIrpSynch@12
  000cb	8b f0		 mov	 esi, eax
$L10047:

; 799  :     }
; 800  :     
; 801  :     if (!NT_SUCCESS(ntStatus)) {
; 802  : 
; 803  :         TRACE(TL_ERROR, ("SubmitIrpSync failed = 0x%x\n", ntStatus));
; 804  :     }
; 805  :     
; 806  :     ExFreePool(pIrb);

  000cd	53		 push	 ebx
  000ce	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePool@4
$Exit_IsochFreeBandwidth$10038:

; 807  : 
; 808  : Exit_IsochFreeBandwidth:
; 809  : 
; 810  :     if (allocNewIrp) 

  000d4	80 7d 0b 00	 cmp	 BYTE PTR _allocNewIrp$[ebp], 0
  000d8	5b		 pop	 ebx
  000d9	74 0f		 je	 SHORT $L10050

; 811  :         Irp->IoStatus = ioStatus;

  000db	8b 4d f4	 mov	 ecx, DWORD PTR _ioStatus$[ebp]
  000de	8b 45 0c	 mov	 eax, DWORD PTR _Irp$[ebp]
  000e1	89 48 18	 mov	 DWORD PTR [eax+24], ecx
  000e4	8b 4d f8	 mov	 ecx, DWORD PTR _ioStatus$[ebp+4]
  000e7	89 48 1c	 mov	 DWORD PTR [eax+28], ecx
$L10050:
  000ea	5f		 pop	 edi

; 812  : 
; 813  :     EXIT("t1394_IsochFreeBandwidth", ntStatus);
; 814  :     return(ntStatus);

  000eb	8b c6		 mov	 eax, esi
  000ed	5e		 pop	 esi

; 815  : } // t1394_IsochFreeBandwidth

  000ee	c9		 leave
  000ef	c2 0c 00	 ret	 12			; 0000000cH
_t1394_IsochFreeBandwidth@12 ENDP
_TEXT	ENDS
PUBLIC	_t1394_IsochFreeChannel@12
; Function compile flags: /Ogsy
;	COMDAT _t1394_IsochFreeChannel@12
_TEXT	SEGMENT
_Event$ = -28						; size = 16
_ioStatus$ = -12					; size = 8
_newIrp$ = -4						; size = 4
_DeviceObject$ = 8					; size = 4
_allocNewIrp$ = 11					; size = 1
_Irp$ = 12						; size = 4
_nChannel$ = 16						; size = 4
_t1394_IsochFreeChannel@12 PROC NEAR			; COMDAT

; 823  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH

; 824  :     NTSTATUS            ntStatus = STATUS_SUCCESS;
; 825  :     PDEVICE_EXTENSION   deviceExtension = DeviceObject->DeviceExtension;

  00006	8b 45 08	 mov	 eax, DWORD PTR _DeviceObject$[ebp]
  00009	56		 push	 esi
  0000a	8b 70 28	 mov	 esi, DWORD PTR [eax+40]

; 826  :     PIRB                pIrb;
; 827  : 
; 828  :     PIRP                newIrp;
; 829  :     BOOLEAN             allocNewIrp = FALSE;
; 830  :     KEVENT              Event;
; 831  :     IO_STATUS_BLOCK     ioStatus;
; 832  :     
; 833  :     ENTER("t1394_IsochFreeChannel");
; 834  : 
; 835  :     TRACE(TL_TRACE, ("nChannel = 0x%x\n", nChannel));
; 836  : 
; 837  :     //
; 838  :     // If this is a UserMode request create a newIrp so that the request
; 839  :     // will be issued from KernelMode
; 840  :     //
; 841  :     if (Irp->RequestorMode == UserMode) {

  0000d	8b 45 0c	 mov	 eax, DWORD PTR _Irp$[ebp]
  00010	57		 push	 edi

; 842  : 
; 843  :         newIrp = IoBuildDeviceIoControlRequest (IOCTL_1394_CLASS, deviceExtension->StackDeviceObject, 
; 844  :                             NULL, 0, NULL, 0, TRUE, &Event, &ioStatus);

  00011	33 ff		 xor	 edi, edi
  00013	80 78 20 01	 cmp	 BYTE PTR [eax+32], 1
  00017	c6 45 0b 00	 mov	 BYTE PTR _allocNewIrp$[ebp], 0
  0001b	75 30		 jne	 SHORT $L10066
  0001d	8d 45 f4	 lea	 eax, DWORD PTR _ioStatus$[ebp]
  00020	50		 push	 eax
  00021	8d 45 e4	 lea	 eax, DWORD PTR _Event$[ebp]
  00024	50		 push	 eax
  00025	6a 01		 push	 1
  00027	57		 push	 edi
  00028	57		 push	 edi
  00029	57		 push	 edi
  0002a	57		 push	 edi
  0002b	ff 36		 push	 DWORD PTR [esi]
  0002d	68 1d 02 22 00	 push	 2228765			; 0022021dH
  00032	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoBuildDeviceIoControlRequest@36

; 845  : 
; 846  :         if (!newIrp) {

  00038	3b c7		 cmp	 eax, edi
  0003a	89 45 fc	 mov	 DWORD PTR _newIrp$[ebp], eax
  0003d	75 0a		 jne	 SHORT $L10069

; 847  : 
; 848  :             TRACE(TL_ERROR, ("Failed to allocate newIrp!\n"));        
; 849  :             ntStatus = STATUS_INSUFFICIENT_RESOURCES;

  0003f	be 9a 00 00 c0	 mov	 esi, -1073741670	; c000009aH

; 850  :             goto Exit_IsochFreeChannel;            

  00044	e9 a1 00 00 00	 jmp	 $L10083
$L10069:

; 851  :         }
; 852  :         allocNewIrp = TRUE;

  00049	c6 45 0b 01	 mov	 BYTE PTR _allocNewIrp$[ebp], 1
$L10066:
  0004d	53		 push	 ebx

; 853  :     }
; 854  :     
; 855  :     pIrb = ExAllocatePool(NonPagedPool, sizeof(IRB));

  0004e	68 57 64 6d 20	 push	 544040023		; 206d6457H
  00053	68 58 01 00 00	 push	 344			; 00000158H
  00058	57		 push	 edi
  00059	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExAllocatePoolWithTag@12
  0005f	8b d8		 mov	 ebx, eax

; 856  : 
; 857  :     if (!pIrb) {

  00061	3b df		 cmp	 ebx, edi
  00063	75 07		 jne	 SHORT $L10073

; 858  : 
; 859  :         TRACE(TL_ERROR, ("Failed to allocate pIrb!\n"));
; 860  :         ntStatus = STATUS_INSUFFICIENT_RESOURCES;

  00065	be 9a 00 00 c0	 mov	 esi, -1073741670	; c000009aH

; 861  :         goto Exit_IsochFreeChannel;

  0006a	eb 68		 jmp	 SHORT $Exit_IsochFreeChannel$10071
$L10073:

; 862  :     } // if
; 863  : 
; 864  :     RtlZeroMemory (pIrb, sizeof (IRB));

  0006c	6a 56		 push	 86			; 00000056H
  0006e	33 c0		 xor	 eax, eax
  00070	59		 pop	 ecx
  00071	8b fb		 mov	 edi, ebx
  00073	f3 ab		 rep stosd

; 865  :     pIrb->FunctionNumber = REQUEST_ISOCH_FREE_CHANNEL;
; 866  :     pIrb->Flags = 0;
; 867  :     pIrb->u.IsochFreeChannel.nChannel = nChannel;

  00075	8b 45 10	 mov	 eax, DWORD PTR _nChannel$[ebp]
  00078	33 ff		 xor	 edi, edi

; 868  : 
; 869  :     //
; 870  :     // If we allocated this irp, submit it asynchronously and wait for its
; 871  :     // completion event to be signaled.  Otherwise submit it synchronously
; 872  :     //
; 873  :     if (allocNewIrp) {

  0007a	80 7d 0b 00	 cmp	 BYTE PTR _allocNewIrp$[ebp], 0
  0007e	c7 03 09 00 00
	00		 mov	 DWORD PTR [ebx], 9
  00084	89 7b 04	 mov	 DWORD PTR [ebx+4], edi
  00087	89 43 48	 mov	 DWORD PTR [ebx+72], eax
  0008a	74 34		 je	 SHORT $L10076

; 874  : 
; 875  :         KeInitializeEvent (&Event, NotificationEvent, FALSE);

  0008c	57		 push	 edi
  0008d	57		 push	 edi
  0008e	8d 45 e4	 lea	 eax, DWORD PTR _Event$[ebp]
  00091	50		 push	 eax
  00092	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeInitializeEvent@12

; 876  :         ntStatus = t1394_SubmitIrpAsync (deviceExtension->StackDeviceObject, newIrp, pIrb);

  00098	53		 push	 ebx
  00099	ff 75 fc	 push	 DWORD PTR _newIrp$[ebp]
  0009c	ff 36		 push	 DWORD PTR [esi]
  0009e	e8 00 00 00 00	 call	 _t1394_SubmitIrpAsync@12
  000a3	8b f0		 mov	 esi, eax

; 877  : 
; 878  :         if (ntStatus == STATUS_PENDING) {

  000a5	81 fe 03 01 00
	00		 cmp	 esi, 259		; 00000103H
  000ab	75 20		 jne	 SHORT $L10080

; 879  :             KeWaitForSingleObject (&Event, Executive, KernelMode, FALSE, NULL); 

  000ad	57		 push	 edi
  000ae	57		 push	 edi
  000af	57		 push	 edi
  000b0	57		 push	 edi
  000b1	8d 45 e4	 lea	 eax, DWORD PTR _Event$[ebp]
  000b4	50		 push	 eax
  000b5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeWaitForSingleObject@20

; 880  :             ntStatus = ioStatus.Status;

  000bb	8b 75 f4	 mov	 esi, DWORD PTR _ioStatus$[ebp]

; 881  :         }
; 882  :     }
; 883  :     else {

  000be	eb 0d		 jmp	 SHORT $L10080
$L10076:

; 884  :         ntStatus = t1394_SubmitIrpSynch(deviceExtension->StackDeviceObject, Irp, pIrb);

  000c0	53		 push	 ebx
  000c1	ff 75 0c	 push	 DWORD PTR _Irp$[ebp]
  000c4	ff 36		 push	 DWORD PTR [esi]
  000c6	e8 00 00 00 00	 call	 _t1394_SubmitIrpSynch@12
  000cb	8b f0		 mov	 esi, eax
$L10080:

; 885  :     }
; 886  :     
; 887  :     if (!NT_SUCCESS(ntStatus)) {
; 888  : 
; 889  :         TRACE(TL_ERROR, ("SubmitIrpSync failed = 0x%x\n", ntStatus));
; 890  :     }
; 891  :     
; 892  :     ExFreePool(pIrb);

  000cd	53		 push	 ebx
  000ce	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePool@4
$Exit_IsochFreeChannel$10071:

; 893  : 
; 894  : Exit_IsochFreeChannel:
; 895  : 
; 896  :     if (allocNewIrp) 

  000d4	80 7d 0b 00	 cmp	 BYTE PTR _allocNewIrp$[ebp], 0
  000d8	5b		 pop	 ebx
  000d9	74 0f		 je	 SHORT $L10083

; 897  :         Irp->IoStatus = ioStatus;

  000db	8b 4d f4	 mov	 ecx, DWORD PTR _ioStatus$[ebp]
  000de	8b 45 0c	 mov	 eax, DWORD PTR _Irp$[ebp]
  000e1	89 48 18	 mov	 DWORD PTR [eax+24], ecx
  000e4	8b 4d f8	 mov	 ecx, DWORD PTR _ioStatus$[ebp+4]
  000e7	89 48 1c	 mov	 DWORD PTR [eax+28], ecx
$L10083:
  000ea	5f		 pop	 edi

; 898  :         
; 899  :     EXIT("t1394_IsochFreeChannel", ntStatus);
; 900  :     return(ntStatus);

  000eb	8b c6		 mov	 eax, esi
  000ed	5e		 pop	 esi

; 901  : } // t1394_IsochFreeChannel

  000ee	c9		 leave
  000ef	c2 0c 00	 ret	 12			; 0000000cH
_t1394_IsochFreeChannel@12 ENDP
_TEXT	ENDS
PUBLIC	_t1394_IsochFreeResources@12
; Function compile flags: /Ogsy
;	COMDAT _t1394_IsochFreeResources@12
_TEXT	SEGMENT
_Event$ = -32						; size = 16
_ioStatus$ = -16					; size = 8
_newIrp$ = -8						; size = 4
_Irql$ = -1						; size = 1
_DeviceObject$ = 8					; size = 4
_allocNewIrp$ = 11					; size = 1
_Irp$ = 12						; size = 4
_hResource$ = 16					; size = 4
_t1394_IsochFreeResources@12 PROC NEAR			; COMDAT

; 909  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H

; 910  :     NTSTATUS                ntStatus = STATUS_SUCCESS;
; 911  :     PDEVICE_EXTENSION       deviceExtension = DeviceObject->DeviceExtension;

  00006	8b 45 08	 mov	 eax, DWORD PTR _DeviceObject$[ebp]
  00009	56		 push	 esi
  0000a	8b 70 28	 mov	 esi, DWORD PTR [eax+40]

; 912  :     PIRB                    pIrb;
; 913  :     PISOCH_RESOURCE_DATA    IsochResourceData;
; 914  :     KIRQL                   Irql;
; 915  : 
; 916  :     PIRP                newIrp;
; 917  :     BOOLEAN             allocNewIrp = FALSE;
; 918  :     KEVENT              Event;
; 919  :     IO_STATUS_BLOCK     ioStatus;
; 920  :     
; 921  :     ENTER("t1394_IsochFreeResources");
; 922  : 
; 923  :     TRACE(TL_TRACE, ("hResource = 0x%x\n", hResource));
; 924  : 
; 925  :     //
; 926  :     // If this is a UserMode request create a newIrp so that the request
; 927  :     // will be issued from KernelMode
; 928  :     //
; 929  :     if (Irp->RequestorMode == UserMode) {

  0000d	8b 45 0c	 mov	 eax, DWORD PTR _Irp$[ebp]
  00010	57		 push	 edi

; 930  : 
; 931  :         newIrp = IoBuildDeviceIoControlRequest (IOCTL_1394_CLASS, deviceExtension->StackDeviceObject, 
; 932  :                             NULL, 0, NULL, 0, TRUE, &Event, &ioStatus);

  00011	33 ff		 xor	 edi, edi
  00013	80 78 20 01	 cmp	 BYTE PTR [eax+32], 1
  00017	c6 45 0b 00	 mov	 BYTE PTR _allocNewIrp$[ebp], 0
  0001b	75 30		 jne	 SHORT $L10101
  0001d	8d 45 f0	 lea	 eax, DWORD PTR _ioStatus$[ebp]
  00020	50		 push	 eax
  00021	8d 45 e0	 lea	 eax, DWORD PTR _Event$[ebp]
  00024	50		 push	 eax
  00025	6a 01		 push	 1
  00027	57		 push	 edi
  00028	57		 push	 edi
  00029	57		 push	 edi
  0002a	57		 push	 edi
  0002b	ff 36		 push	 DWORD PTR [esi]
  0002d	68 1d 02 22 00	 push	 2228765			; 0022021dH
  00032	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoBuildDeviceIoControlRequest@36

; 933  : 
; 934  :         if (!newIrp) {

  00038	3b c7		 cmp	 eax, edi
  0003a	89 45 f8	 mov	 DWORD PTR _newIrp$[ebp], eax
  0003d	75 0a		 jne	 SHORT $L10104

; 935  : 
; 936  :             TRACE(TL_ERROR, ("Failed to allocate newIrp!\n"));        
; 937  :             ntStatus = STATUS_INSUFFICIENT_RESOURCES;

  0003f	be 9a 00 00 c0	 mov	 esi, -1073741670	; c000009aH

; 938  :             goto Exit_IsochFreeResources;            

  00044	e9 e9 00 00 00	 jmp	 $L10127
$L10104:

; 939  :         }
; 940  :         allocNewIrp = TRUE;

  00049	c6 45 0b 01	 mov	 BYTE PTR _allocNewIrp$[ebp], 1
$L10101:
  0004d	53		 push	 ebx

; 941  :     }
; 942  :     
; 943  :     pIrb = ExAllocatePool(NonPagedPool, sizeof(IRB));

  0004e	68 57 64 6d 20	 push	 544040023		; 206d6457H
  00053	68 58 01 00 00	 push	 344			; 00000158H
  00058	57		 push	 edi
  00059	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExAllocatePoolWithTag@12
  0005f	8b d8		 mov	 ebx, eax

; 944  : 
; 945  :     if (!pIrb) {

  00061	3b df		 cmp	 ebx, edi
  00063	75 0a		 jne	 SHORT $L10108

; 946  : 
; 947  :         TRACE(TL_ERROR, ("Failed to allocate pIrb!\n"));
; 948  :         ntStatus = STATUS_INSUFFICIENT_RESOURCES;

  00065	be 9a 00 00 c0	 mov	 esi, -1073741670	; c000009aH

; 949  :         goto Exit_IsochFreeResources;

  0006a	e9 ad 00 00 00	 jmp	 $Exit_IsochFreeResources$10106
$L10108:

; 950  :     } // if
; 951  : 
; 952  :     // remove this one from our list...
; 953  :     KeAcquireSpinLock(&deviceExtension->IsochResourceSpinLock, &Irql);

  0006f	8d 7e 24	 lea	 edi, DWORD PTR [esi+36]
  00072	8b cf		 mov	 ecx, edi
  00074	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@KfAcquireSpinLock@4

; 954  : 
; 955  :     IsochResourceData = (PISOCH_RESOURCE_DATA)deviceExtension->IsochResourceData.Flink;

  0007a	8d 4e 58	 lea	 ecx, DWORD PTR [esi+88]
  0007d	88 45 ff	 mov	 BYTE PTR _Irql$[ebp], al
  00080	8b 01		 mov	 eax, DWORD PTR [ecx]
  00082	eb 0e		 jmp	 SHORT $L10871
$L10112:

; 958  : 
; 959  :         TRACE(TL_TRACE, ("Removing hResource = 0x%x\n", hResource));
; 960  : 
; 961  :         if (IsochResourceData->hResource == hResource) {

  00084	8b 55 10	 mov	 edx, DWORD PTR _hResource$[ebp]
  00087	39 50 08	 cmp	 DWORD PTR [eax+8], edx
  0008a	74 0c		 je	 SHORT $L10867

; 965  :             break;
; 966  :         }
; 967  :         else if (IsochResourceData->IsochResourceList.Flink == &deviceExtension->IsochResourceData) {

  0008c	8b 00		 mov	 eax, DWORD PTR [eax]
  0008e	3b c1		 cmp	 eax, ecx
  00090	74 17		 je	 SHORT $L10870
$L10871:

; 956  : 
; 957  :     while (IsochResourceData) {

  00092	85 c0		 test	 eax, eax
  00094	75 ee		 jne	 SHORT $L10112

; 965  :             break;
; 966  :         }
; 967  :         else if (IsochResourceData->IsochResourceList.Flink == &deviceExtension->IsochResourceData) {

  00096	eb 11		 jmp	 SHORT $L10870
$L10867:

; 962  : 
; 963  :             RemoveEntryList(&IsochResourceData->IsochResourceList);

  00098	8b 08		 mov	 ecx, DWORD PTR [eax]
  0009a	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0009d	89 0a		 mov	 DWORD PTR [edx], ecx

; 964  :             ExFreePool(IsochResourceData);

  0009f	50		 push	 eax
  000a0	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  000a3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePool@4
$L10870:

; 968  :             break;
; 969  :         }
; 970  :         else
; 971  :             IsochResourceData = (PISOCH_RESOURCE_DATA)IsochResourceData->IsochResourceList.Flink;
; 972  :     }
; 973  : 
; 974  :     KeReleaseSpinLock(&deviceExtension->IsochResourceSpinLock, Irql);

  000a9	8a 55 ff	 mov	 dl, BYTE PTR _Irql$[ebp]
  000ac	8b cf		 mov	 ecx, edi
  000ae	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@KfReleaseSpinLock@8

; 975  : 
; 976  :     RtlZeroMemory (pIrb, sizeof (IRB));

  000b4	6a 56		 push	 86			; 00000056H
  000b6	33 c0		 xor	 eax, eax
  000b8	59		 pop	 ecx
  000b9	8b fb		 mov	 edi, ebx
  000bb	f3 ab		 rep stosd

; 977  :     pIrb->FunctionNumber = REQUEST_ISOCH_FREE_RESOURCES;
; 978  :     pIrb->Flags = 0;
; 979  :     pIrb->u.IsochFreeResources.hResource = hResource;

  000bd	8b 45 10	 mov	 eax, DWORD PTR _hResource$[ebp]
  000c0	33 ff		 xor	 edi, edi

; 980  : 
; 981  :     //
; 982  :     // If we allocated this irp, submit it asynchronously and wait for its
; 983  :     // completion event to be signaled.  Otherwise submit it synchronously
; 984  :     //
; 985  :     if (allocNewIrp) {

  000c2	80 7d 0b 00	 cmp	 BYTE PTR _allocNewIrp$[ebp], 0
  000c6	c7 03 0a 00 00
	00		 mov	 DWORD PTR [ebx], 10	; 0000000aH
  000cc	89 7b 04	 mov	 DWORD PTR [ebx+4], edi
  000cf	89 43 48	 mov	 DWORD PTR [ebx+72], eax
  000d2	74 34		 je	 SHORT $L10120

; 986  : 
; 987  :         KeInitializeEvent (&Event, NotificationEvent, FALSE);

  000d4	57		 push	 edi
  000d5	57		 push	 edi
  000d6	8d 45 e0	 lea	 eax, DWORD PTR _Event$[ebp]
  000d9	50		 push	 eax
  000da	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeInitializeEvent@12

; 988  :         ntStatus = t1394_SubmitIrpAsync (deviceExtension->StackDeviceObject, newIrp, pIrb);

  000e0	53		 push	 ebx
  000e1	ff 75 f8	 push	 DWORD PTR _newIrp$[ebp]
  000e4	ff 36		 push	 DWORD PTR [esi]
  000e6	e8 00 00 00 00	 call	 _t1394_SubmitIrpAsync@12
  000eb	8b f0		 mov	 esi, eax

; 989  : 
; 990  :         if (ntStatus == STATUS_PENDING) {

  000ed	81 fe 03 01 00
	00		 cmp	 esi, 259		; 00000103H
  000f3	75 20		 jne	 SHORT $L10124

; 991  :             KeWaitForSingleObject (&Event, Executive, KernelMode, FALSE, NULL); 

  000f5	57		 push	 edi
  000f6	57		 push	 edi
  000f7	57		 push	 edi
  000f8	57		 push	 edi
  000f9	8d 45 e0	 lea	 eax, DWORD PTR _Event$[ebp]
  000fc	50		 push	 eax
  000fd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeWaitForSingleObject@20

; 992  :             ntStatus = ioStatus.Status;

  00103	8b 75 f0	 mov	 esi, DWORD PTR _ioStatus$[ebp]

; 993  :         }
; 994  :     }
; 995  :     else {

  00106	eb 0d		 jmp	 SHORT $L10124
$L10120:

; 996  :         ntStatus = t1394_SubmitIrpSynch(deviceExtension->StackDeviceObject, Irp, pIrb);

  00108	53		 push	 ebx
  00109	ff 75 0c	 push	 DWORD PTR _Irp$[ebp]
  0010c	ff 36		 push	 DWORD PTR [esi]
  0010e	e8 00 00 00 00	 call	 _t1394_SubmitIrpSynch@12
  00113	8b f0		 mov	 esi, eax
$L10124:

; 997  :     }
; 998  :     
; 999  :     if (!NT_SUCCESS(ntStatus)) {
; 1000 : 
; 1001 :         TRACE(TL_ERROR, ("SubmitIrpSync failed = 0x%x\n", ntStatus));
; 1002 :     }
; 1003 : 
; 1004 :     ExFreePool(pIrb);

  00115	53		 push	 ebx
  00116	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePool@4
$Exit_IsochFreeResources$10106:

; 1005 : 
; 1006 : Exit_IsochFreeResources:
; 1007 : 
; 1008 :     if (allocNewIrp) 

  0011c	80 7d 0b 00	 cmp	 BYTE PTR _allocNewIrp$[ebp], 0
  00120	5b		 pop	 ebx
  00121	74 0f		 je	 SHORT $L10127

; 1009 :         Irp->IoStatus = ioStatus;

  00123	8b 4d f0	 mov	 ecx, DWORD PTR _ioStatus$[ebp]
  00126	8b 45 0c	 mov	 eax, DWORD PTR _Irp$[ebp]
  00129	89 48 18	 mov	 DWORD PTR [eax+24], ecx
  0012c	8b 4d f4	 mov	 ecx, DWORD PTR _ioStatus$[ebp+4]
  0012f	89 48 1c	 mov	 DWORD PTR [eax+28], ecx
$L10127:
  00132	5f		 pop	 edi

; 1010 :         
; 1011 :     EXIT("t1394_IsochFreeResources", ntStatus);
; 1012 :     return(ntStatus);

  00133	8b c6		 mov	 eax, esi
  00135	5e		 pop	 esi

; 1013 : } // t1394_IsochFreeResources

  00136	c9		 leave
  00137	c2 0c 00	 ret	 12			; 0000000cH
_t1394_IsochFreeResources@12 ENDP
_TEXT	ENDS
PUBLIC	_t1394_IsochListen@20
; Function compile flags: /Ogsy
;	COMDAT _t1394_IsochListen@20
_TEXT	SEGMENT
_Event$ = -28						; size = 16
_ioStatus$ = -12					; size = 8
_newIrp$ = -4						; size = 4
_DeviceObject$ = 8					; size = 4
_allocNewIrp$ = 11					; size = 1
_Irp$ = 12						; size = 4
_hResource$ = 16					; size = 4
_fulFlags$ = 20						; size = 4
_StartTime$ = 24					; size = 4
_t1394_IsochListen@20 PROC NEAR				; COMDAT

; 1023 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH

; 1024 :     NTSTATUS            ntStatus = STATUS_SUCCESS;
; 1025 :     PDEVICE_EXTENSION   deviceExtension = DeviceObject->DeviceExtension;

  00006	8b 45 08	 mov	 eax, DWORD PTR _DeviceObject$[ebp]
  00009	53		 push	 ebx
  0000a	8b 58 28	 mov	 ebx, DWORD PTR [eax+40]

; 1026 :     PIRB                pIrb;
; 1027 : 
; 1028 :     PIRP                newIrp;
; 1029 :     BOOLEAN             allocNewIrp = FALSE;
; 1030 :     KEVENT              Event;
; 1031 :     IO_STATUS_BLOCK     ioStatus;
; 1032 :     
; 1033 :     ENTER("t1394_IsochListen");
; 1034 : 
; 1035 :     TRACE(TL_TRACE, ("hResource = 0x%x\n", hResource));
; 1036 :     TRACE(TL_TRACE, ("fulFlags = 0x%x\n", fulFlags));
; 1037 :     TRACE(TL_TRACE, ("StartTime.CL_CycleOffset = 0x%x\n", StartTime.CL_CycleOffset));
; 1038 :     TRACE(TL_TRACE, ("StartTime.CL_CycleCount = 0x%x\n", StartTime.CL_CycleCount));
; 1039 :     TRACE(TL_TRACE, ("StartTime.CL_SecondCount = 0x%x\n", StartTime.CL_SecondCount));
; 1040 : 
; 1041 :     //
; 1042 :     // If this is a UserMode request create a newIrp so that the request
; 1043 :     // will be issued from KernelMode
; 1044 :     //
; 1045 :     if (Irp->RequestorMode == UserMode) {

  0000d	8b 45 0c	 mov	 eax, DWORD PTR _Irp$[ebp]
  00010	57		 push	 edi

; 1046 : 
; 1047 :         newIrp = IoBuildDeviceIoControlRequest (IOCTL_1394_CLASS, deviceExtension->StackDeviceObject, 
; 1048 :                             NULL, 0, NULL, 0, TRUE, &Event, &ioStatus);

  00011	33 ff		 xor	 edi, edi
  00013	80 78 20 01	 cmp	 BYTE PTR [eax+32], 1
  00017	c6 45 0b 00	 mov	 BYTE PTR _allocNewIrp$[ebp], 0
  0001b	75 30		 jne	 SHORT $L10147
  0001d	8d 45 f4	 lea	 eax, DWORD PTR _ioStatus$[ebp]
  00020	50		 push	 eax
  00021	8d 45 e4	 lea	 eax, DWORD PTR _Event$[ebp]
  00024	50		 push	 eax
  00025	6a 01		 push	 1
  00027	57		 push	 edi
  00028	57		 push	 edi
  00029	57		 push	 edi
  0002a	57		 push	 edi
  0002b	ff 33		 push	 DWORD PTR [ebx]
  0002d	68 1d 02 22 00	 push	 2228765			; 0022021dH
  00032	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoBuildDeviceIoControlRequest@36

; 1049 : 
; 1050 :         if (!newIrp) {

  00038	3b c7		 cmp	 eax, edi
  0003a	89 45 fc	 mov	 DWORD PTR _newIrp$[ebp], eax
  0003d	75 0a		 jne	 SHORT $L10150

; 1051 : 
; 1052 :             TRACE(TL_ERROR, ("Failed to allocate newIrp!\n"));        
; 1053 :             ntStatus = STATUS_INSUFFICIENT_RESOURCES;

  0003f	bb 9a 00 00 c0	 mov	 ebx, -1073741670	; c000009aH

; 1054 :             goto Exit_IsochListen;            

  00044	e9 ad 00 00 00	 jmp	 $L10164
$L10150:

; 1055 :         }
; 1056 :         allocNewIrp = TRUE;

  00049	c6 45 0b 01	 mov	 BYTE PTR _allocNewIrp$[ebp], 1
$L10147:
  0004d	56		 push	 esi

; 1057 :     }
; 1058 :     
; 1059 :     pIrb = ExAllocatePool(NonPagedPool, sizeof(IRB));

  0004e	68 57 64 6d 20	 push	 544040023		; 206d6457H
  00053	68 58 01 00 00	 push	 344			; 00000158H
  00058	57		 push	 edi
  00059	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExAllocatePoolWithTag@12
  0005f	8b f0		 mov	 esi, eax

; 1060 : 
; 1061 :     if (!pIrb) {

  00061	3b f7		 cmp	 esi, edi
  00063	75 07		 jne	 SHORT $L10154

; 1062 : 
; 1063 :         TRACE(TL_ERROR, ("Failed to allocate pIrb!\n"));
; 1064 :         ntStatus = STATUS_INSUFFICIENT_RESOURCES;

  00065	bb 9a 00 00 c0	 mov	 ebx, -1073741670	; c000009aH

; 1065 :         goto Exit_IsochListen;

  0006a	eb 74		 jmp	 SHORT $Exit_IsochListen$10152
$L10154:

; 1066 :     } // if
; 1067 : 
; 1068 :     RtlZeroMemory (pIrb, sizeof (IRB));

  0006c	33 c0		 xor	 eax, eax
  0006e	6a 56		 push	 86			; 00000056H
  00070	59		 pop	 ecx
  00071	8b fe		 mov	 edi, esi
  00073	f3 ab		 rep stosd

; 1069 :     pIrb->FunctionNumber = REQUEST_ISOCH_LISTEN;
; 1070 :     pIrb->Flags = 0;
; 1071 :     pIrb->u.IsochListen.hResource = hResource;

  00075	8b 45 10	 mov	 eax, DWORD PTR _hResource$[ebp]
  00078	89 46 48	 mov	 DWORD PTR [esi+72], eax

; 1072 :     pIrb->u.IsochListen.fulFlags = fulFlags;

  0007b	8b 45 14	 mov	 eax, DWORD PTR _fulFlags$[ebp]
  0007e	33 ff		 xor	 edi, edi

; 1073 :     pIrb->u.IsochListen.StartTime = StartTime;
; 1074 : 
; 1075 :     //
; 1076 :     // If we allocated this irp, submit it asynchronously and wait for its
; 1077 :     // completion event to be signaled.  Otherwise submit it synchronously
; 1078 :     //
; 1079 :     if (allocNewIrp) {

  00080	80 7d 0b 00	 cmp	 BYTE PTR _allocNewIrp$[ebp], 0
  00084	89 46 4c	 mov	 DWORD PTR [esi+76], eax
  00087	8b 45 18	 mov	 eax, DWORD PTR _StartTime$[ebp]
  0008a	c7 06 0b 00 00
	00		 mov	 DWORD PTR [esi], 11	; 0000000bH
  00090	89 7e 04	 mov	 DWORD PTR [esi+4], edi
  00093	89 46 50	 mov	 DWORD PTR [esi+80], eax
  00096	74 34		 je	 SHORT $L10157

; 1080 : 
; 1081 :         KeInitializeEvent (&Event, NotificationEvent, FALSE);

  00098	57		 push	 edi
  00099	57		 push	 edi
  0009a	8d 45 e4	 lea	 eax, DWORD PTR _Event$[ebp]
  0009d	50		 push	 eax
  0009e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeInitializeEvent@12

; 1082 :         ntStatus = t1394_SubmitIrpAsync (deviceExtension->StackDeviceObject, newIrp, pIrb);

  000a4	56		 push	 esi
  000a5	ff 75 fc	 push	 DWORD PTR _newIrp$[ebp]
  000a8	ff 33		 push	 DWORD PTR [ebx]
  000aa	e8 00 00 00 00	 call	 _t1394_SubmitIrpAsync@12
  000af	8b d8		 mov	 ebx, eax

; 1083 : 
; 1084 :         if (ntStatus == STATUS_PENDING) {

  000b1	81 fb 03 01 00
	00		 cmp	 ebx, 259		; 00000103H
  000b7	75 20		 jne	 SHORT $L10161

; 1085 :             KeWaitForSingleObject (&Event, Executive, KernelMode, FALSE, NULL); 

  000b9	57		 push	 edi
  000ba	57		 push	 edi
  000bb	57		 push	 edi
  000bc	57		 push	 edi
  000bd	8d 45 e4	 lea	 eax, DWORD PTR _Event$[ebp]
  000c0	50		 push	 eax
  000c1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeWaitForSingleObject@20

; 1086 :             ntStatus = ioStatus.Status;

  000c7	8b 5d f4	 mov	 ebx, DWORD PTR _ioStatus$[ebp]

; 1087 :         }
; 1088 :     }
; 1089 :     else {

  000ca	eb 0d		 jmp	 SHORT $L10161
$L10157:

; 1090 :         ntStatus = t1394_SubmitIrpSynch(deviceExtension->StackDeviceObject, Irp, pIrb);

  000cc	56		 push	 esi
  000cd	ff 75 0c	 push	 DWORD PTR _Irp$[ebp]
  000d0	ff 33		 push	 DWORD PTR [ebx]
  000d2	e8 00 00 00 00	 call	 _t1394_SubmitIrpSynch@12
  000d7	8b d8		 mov	 ebx, eax
$L10161:

; 1091 :     }
; 1092 :     
; 1093 :     if (!NT_SUCCESS(ntStatus)) {
; 1094 : 
; 1095 :         TRACE(TL_ERROR, ("SubmitIrpSync failed = 0x%x\n", ntStatus));
; 1096 :     }
; 1097 :     
; 1098 :     ExFreePool(pIrb);

  000d9	56		 push	 esi
  000da	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePool@4
$Exit_IsochListen$10152:

; 1099 : 
; 1100 : Exit_IsochListen:
; 1101 : 
; 1102 :     if (allocNewIrp) 

  000e0	80 7d 0b 00	 cmp	 BYTE PTR _allocNewIrp$[ebp], 0
  000e4	5e		 pop	 esi
  000e5	74 0f		 je	 SHORT $L10164

; 1103 :         Irp->IoStatus = ioStatus;

  000e7	8b 4d f4	 mov	 ecx, DWORD PTR _ioStatus$[ebp]
  000ea	8b 45 0c	 mov	 eax, DWORD PTR _Irp$[ebp]
  000ed	89 48 18	 mov	 DWORD PTR [eax+24], ecx
  000f0	8b 4d f8	 mov	 ecx, DWORD PTR _ioStatus$[ebp+4]
  000f3	89 48 1c	 mov	 DWORD PTR [eax+28], ecx
$L10164:
  000f6	5f		 pop	 edi

; 1104 :         
; 1105 :     EXIT("t1394_IsochListen", ntStatus);
; 1106 :     return(ntStatus);

  000f7	8b c3		 mov	 eax, ebx
  000f9	5b		 pop	 ebx

; 1107 : } // t1394_IsochListen

  000fa	c9		 leave
  000fb	c2 14 00	 ret	 20			; 00000014H
_t1394_IsochListen@20 ENDP
_TEXT	ENDS
PUBLIC	_t1394_IsochQueryCurrentCycleTime@12
; Function compile flags: /Ogsy
;	COMDAT _t1394_IsochQueryCurrentCycleTime@12
_TEXT	SEGMENT
_Event$ = -28						; size = 16
_ioStatus$ = -12					; size = 8
_newIrp$ = -4						; size = 4
_DeviceObject$ = 8					; size = 4
_allocNewIrp$ = 11					; size = 1
_Irp$ = 12						; size = 4
_pCurrentCycleTime$ = 16				; size = 4
_t1394_IsochQueryCurrentCycleTime@12 PROC NEAR		; COMDAT

; 1115 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH

; 1116 :     NTSTATUS            ntStatus = STATUS_SUCCESS;
; 1117 :     PDEVICE_EXTENSION   deviceExtension = DeviceObject->DeviceExtension;

  00006	8b 45 08	 mov	 eax, DWORD PTR _DeviceObject$[ebp]
  00009	56		 push	 esi
  0000a	8b 70 28	 mov	 esi, DWORD PTR [eax+40]

; 1118 :     PIRB                pIrb;
; 1119 : 
; 1120 :     PIRP                newIrp;
; 1121 :     BOOLEAN             allocNewIrp = FALSE;
; 1122 :     KEVENT              Event;
; 1123 :     IO_STATUS_BLOCK     ioStatus;
; 1124 :     
; 1125 :     ENTER("t1394_IsochQueryCurrentCycleTime");
; 1126 : 
; 1127 :     //
; 1128 :     // If this is a UserMode request create a newIrp so that the request
; 1129 :     // will be issued from KernelMode
; 1130 :     //
; 1131 :     if (Irp->RequestorMode == UserMode) {

  0000d	8b 45 0c	 mov	 eax, DWORD PTR _Irp$[ebp]
  00010	57		 push	 edi

; 1132 : 
; 1133 :         newIrp = IoBuildDeviceIoControlRequest (IOCTL_1394_CLASS, deviceExtension->StackDeviceObject, 
; 1134 :                             NULL, 0, NULL, 0, TRUE, &Event, &ioStatus);

  00011	33 ff		 xor	 edi, edi
  00013	80 78 20 01	 cmp	 BYTE PTR [eax+32], 1
  00017	c6 45 0b 00	 mov	 BYTE PTR _allocNewIrp$[ebp], 0
  0001b	75 30		 jne	 SHORT $L10180
  0001d	8d 45 f4	 lea	 eax, DWORD PTR _ioStatus$[ebp]
  00020	50		 push	 eax
  00021	8d 45 e4	 lea	 eax, DWORD PTR _Event$[ebp]
  00024	50		 push	 eax
  00025	6a 01		 push	 1
  00027	57		 push	 edi
  00028	57		 push	 edi
  00029	57		 push	 edi
  0002a	57		 push	 edi
  0002b	ff 36		 push	 DWORD PTR [esi]
  0002d	68 1d 02 22 00	 push	 2228765			; 0022021dH
  00032	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoBuildDeviceIoControlRequest@36

; 1135 : 
; 1136 :         if (!newIrp) {

  00038	3b c7		 cmp	 eax, edi
  0003a	89 45 fc	 mov	 DWORD PTR _newIrp$[ebp], eax
  0003d	75 0a		 jne	 SHORT $L10183

; 1137 : 
; 1138 :             TRACE(TL_ERROR, ("Failed to allocate newIrp!\n"));        
; 1139 :             ntStatus = STATUS_INSUFFICIENT_RESOURCES;

  0003f	be 9a 00 00 c0	 mov	 esi, -1073741670	; c000009aH

; 1140 :             goto Exit_IsochQueryCurrentCycleTime;            

  00044	e9 a7 00 00 00	 jmp	 $L10198
$L10183:

; 1141 :         }
; 1142 :         allocNewIrp = TRUE;

  00049	c6 45 0b 01	 mov	 BYTE PTR _allocNewIrp$[ebp], 1
$L10180:
  0004d	53		 push	 ebx

; 1143 :     }
; 1144 :     
; 1145 :     pIrb = ExAllocatePool(NonPagedPool, sizeof(IRB));

  0004e	68 57 64 6d 20	 push	 544040023		; 206d6457H
  00053	68 58 01 00 00	 push	 344			; 00000158H
  00058	57		 push	 edi
  00059	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExAllocatePoolWithTag@12
  0005f	8b d8		 mov	 ebx, eax

; 1146 : 
; 1147 :     if (!pIrb) {

  00061	3b df		 cmp	 ebx, edi
  00063	75 07		 jne	 SHORT $L10187

; 1148 : 
; 1149 :         TRACE(TL_ERROR, ("Failed to allocate pIrb!\n"));
; 1150 :         ntStatus = STATUS_INSUFFICIENT_RESOURCES;

  00065	be 9a 00 00 c0	 mov	 esi, -1073741670	; c000009aH

; 1151 :         goto Exit_IsochQueryCurrentCycleTime;

  0006a	eb 6e		 jmp	 SHORT $Exit_IsochQueryCurrentCycleTime$10185
$L10187:

; 1152 :     } // if
; 1153 : 
; 1154 :     RtlZeroMemory (pIrb, sizeof (IRB));

  0006c	6a 56		 push	 86			; 00000056H
  0006e	33 c0		 xor	 eax, eax
  00070	59		 pop	 ecx
  00071	8b fb		 mov	 edi, ebx
  00073	f3 ab		 rep stosd

; 1155 :     pIrb->FunctionNumber = REQUEST_ISOCH_QUERY_CYCLE_TIME;
; 1156 :     pIrb->Flags = 0;

  00075	33 ff		 xor	 edi, edi

; 1157 : 
; 1158 :     //
; 1159 :     // If we allocated this irp, submit it asynchronously and wait for its
; 1160 :     // completion event to be signaled.  Otherwise submit it synchronously
; 1161 :     //
; 1162 :     if (allocNewIrp) {

  00077	80 7d 0b 00	 cmp	 BYTE PTR _allocNewIrp$[ebp], 0
  0007b	c7 03 0e 00 00
	00		 mov	 DWORD PTR [ebx], 14	; 0000000eH
  00081	89 7b 04	 mov	 DWORD PTR [ebx+4], edi
  00084	74 34		 je	 SHORT $L10190

; 1163 : 
; 1164 :         KeInitializeEvent (&Event, NotificationEvent, FALSE);

  00086	57		 push	 edi
  00087	57		 push	 edi
  00088	8d 45 e4	 lea	 eax, DWORD PTR _Event$[ebp]
  0008b	50		 push	 eax
  0008c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeInitializeEvent@12

; 1165 :         ntStatus = t1394_SubmitIrpAsync (deviceExtension->StackDeviceObject, newIrp, pIrb);

  00092	53		 push	 ebx
  00093	ff 75 fc	 push	 DWORD PTR _newIrp$[ebp]
  00096	ff 36		 push	 DWORD PTR [esi]
  00098	e8 00 00 00 00	 call	 _t1394_SubmitIrpAsync@12
  0009d	8b f0		 mov	 esi, eax

; 1166 : 
; 1167 :         if (ntStatus == STATUS_PENDING) {

  0009f	81 fe 03 01 00
	00		 cmp	 esi, 259		; 00000103H
  000a5	75 20		 jne	 SHORT $L10194

; 1168 :             KeWaitForSingleObject (&Event, Executive, KernelMode, FALSE, NULL); 

  000a7	57		 push	 edi
  000a8	57		 push	 edi
  000a9	57		 push	 edi
  000aa	57		 push	 edi
  000ab	8d 45 e4	 lea	 eax, DWORD PTR _Event$[ebp]
  000ae	50		 push	 eax
  000af	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeWaitForSingleObject@20

; 1169 :             ntStatus = ioStatus.Status;

  000b5	8b 75 f4	 mov	 esi, DWORD PTR _ioStatus$[ebp]

; 1170 :         }
; 1171 :     }
; 1172 :     else {

  000b8	eb 0d		 jmp	 SHORT $L10194
$L10190:

; 1173 :         ntStatus = t1394_SubmitIrpSynch(deviceExtension->StackDeviceObject, Irp, pIrb);

  000ba	53		 push	 ebx
  000bb	ff 75 0c	 push	 DWORD PTR _Irp$[ebp]
  000be	ff 36		 push	 DWORD PTR [esi]
  000c0	e8 00 00 00 00	 call	 _t1394_SubmitIrpSynch@12
  000c5	8b f0		 mov	 esi, eax
$L10194:

; 1174 :     }
; 1175 :     
; 1176 :     if (NT_SUCCESS(ntStatus)) {

  000c7	3b f7		 cmp	 esi, edi
  000c9	7c 08		 jl	 SHORT $L10196

; 1177 : 
; 1178 :         *pCurrentCycleTime = pIrb->u.IsochQueryCurrentCycleTime.CycleTime;

  000cb	8b 43 48	 mov	 eax, DWORD PTR [ebx+72]
  000ce	8b 4d 10	 mov	 ecx, DWORD PTR _pCurrentCycleTime$[ebp]
  000d1	89 01		 mov	 DWORD PTR [ecx], eax
$L10196:

; 1179 :         
; 1180 :         TRACE(TL_TRACE, ("CurrentCycleTime.CL_CycleOffset = 0x%x\n", pCurrentCycleTime->CL_CycleOffset));
; 1181 :         TRACE(TL_TRACE, ("CurrentCycleTime.CL_CycleCount = 0x%x\n", pCurrentCycleTime->CL_CycleCount));
; 1182 :         TRACE(TL_TRACE, ("CurrentCycleTime.CL_SecondCount = 0x%x\n", pCurrentCycleTime->CL_SecondCount));
; 1183 :     }
; 1184 :     else {
; 1185 : 
; 1186 :         TRACE(TL_ERROR, ("SubmitIrpSync failed = 0x%x\n", ntStatus));
; 1187 :     }
; 1188 : 
; 1189 :     ExFreePool(pIrb);

  000d3	53		 push	 ebx
  000d4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePool@4
$Exit_IsochQueryCurrentCycleTime$10185:

; 1190 : 
; 1191 : Exit_IsochQueryCurrentCycleTime:
; 1192 : 
; 1193 :     if (allocNewIrp) 

  000da	80 7d 0b 00	 cmp	 BYTE PTR _allocNewIrp$[ebp], 0
  000de	5b		 pop	 ebx
  000df	74 0f		 je	 SHORT $L10198

; 1194 :         Irp->IoStatus = ioStatus;

  000e1	8b 4d f4	 mov	 ecx, DWORD PTR _ioStatus$[ebp]
  000e4	8b 45 0c	 mov	 eax, DWORD PTR _Irp$[ebp]
  000e7	89 48 18	 mov	 DWORD PTR [eax+24], ecx
  000ea	8b 4d f8	 mov	 ecx, DWORD PTR _ioStatus$[ebp+4]
  000ed	89 48 1c	 mov	 DWORD PTR [eax+28], ecx
$L10198:
  000f0	5f		 pop	 edi

; 1195 :         
; 1196 :     EXIT("t1394_IsochQueryCurrentCycleTime", ntStatus);
; 1197 :     return(ntStatus);

  000f1	8b c6		 mov	 eax, esi
  000f3	5e		 pop	 esi

; 1198 : } // t1394_IsochQueryCurrentCycleTime

  000f4	c9		 leave
  000f5	c2 0c 00	 ret	 12			; 0000000cH
_t1394_IsochQueryCurrentCycleTime@12 ENDP
_TEXT	ENDS
PUBLIC	_t1394_IsochQueryResources@20
; Function compile flags: /Ogsy
;	COMDAT _t1394_IsochQueryResources@20
_TEXT	SEGMENT
_Event$ = -28						; size = 16
_ioStatus$ = -12					; size = 8
_newIrp$ = -4						; size = 4
_DeviceObject$ = 8					; size = 4
_allocNewIrp$ = 11					; size = 1
_Irp$ = 12						; size = 4
_fulSpeed$ = 16						; size = 4
_pBytesPerFrameAvailable$ = 20				; size = 4
_pChannelsAvailable$ = 24				; size = 4
_t1394_IsochQueryResources@20 PROC NEAR			; COMDAT

; 1208 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH

; 1209 :     NTSTATUS            ntStatus = STATUS_SUCCESS;
; 1210 :     PDEVICE_EXTENSION   deviceExtension = DeviceObject->DeviceExtension;

  00006	8b 45 08	 mov	 eax, DWORD PTR _DeviceObject$[ebp]
  00009	53		 push	 ebx
  0000a	8b 58 28	 mov	 ebx, DWORD PTR [eax+40]

; 1211 :     PIRB                pIrb;
; 1212 : 
; 1213 :     PIRP                newIrp;
; 1214 :     BOOLEAN             allocNewIrp = FALSE;
; 1215 :     KEVENT              Event;
; 1216 :     IO_STATUS_BLOCK     ioStatus;
; 1217 :     
; 1218 :     ENTER("t1394_IsochQueryResources");
; 1219 : 
; 1220 :     TRACE(TL_TRACE, ("fulSpeed = 0x%x\n", fulSpeed));
; 1221 : 
; 1222 :     //
; 1223 :     // If this is a UserMode request create a newIrp so that the request
; 1224 :     // will be issued from KernelMode
; 1225 :     //
; 1226 :     if (Irp->RequestorMode == UserMode) {

  0000d	8b 45 0c	 mov	 eax, DWORD PTR _Irp$[ebp]
  00010	57		 push	 edi

; 1227 : 
; 1228 :         newIrp = IoBuildDeviceIoControlRequest (IOCTL_1394_CLASS, deviceExtension->StackDeviceObject, 
; 1229 :                             NULL, 0, NULL, 0, TRUE, &Event, &ioStatus);

  00011	33 ff		 xor	 edi, edi
  00013	80 78 20 01	 cmp	 BYTE PTR [eax+32], 1
  00017	c6 45 0b 00	 mov	 BYTE PTR _allocNewIrp$[ebp], 0
  0001b	75 30		 jne	 SHORT $L10218
  0001d	8d 45 f4	 lea	 eax, DWORD PTR _ioStatus$[ebp]
  00020	50		 push	 eax
  00021	8d 45 e4	 lea	 eax, DWORD PTR _Event$[ebp]
  00024	50		 push	 eax
  00025	6a 01		 push	 1
  00027	57		 push	 edi
  00028	57		 push	 edi
  00029	57		 push	 edi
  0002a	57		 push	 edi
  0002b	ff 33		 push	 DWORD PTR [ebx]
  0002d	68 1d 02 22 00	 push	 2228765			; 0022021dH
  00032	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoBuildDeviceIoControlRequest@36

; 1230 : 
; 1231 :         if (!newIrp) {

  00038	3b c7		 cmp	 eax, edi
  0003a	89 45 fc	 mov	 DWORD PTR _newIrp$[ebp], eax
  0003d	75 0a		 jne	 SHORT $L10221

; 1232 : 
; 1233 :             TRACE(TL_ERROR, ("Failed to allocate newIrp!\n"));        
; 1234 :             ntStatus = STATUS_INSUFFICIENT_RESOURCES;

  0003f	bb 9a 00 00 c0	 mov	 ebx, -1073741670	; c000009aH

; 1235 :             goto Exit_IsochQueryResources;            

  00044	e9 be 00 00 00	 jmp	 $L10236
$L10221:

; 1236 :         }
; 1237 :         allocNewIrp = TRUE;

  00049	c6 45 0b 01	 mov	 BYTE PTR _allocNewIrp$[ebp], 1
$L10218:
  0004d	56		 push	 esi

; 1238 :     }
; 1239 :     
; 1240 :     pIrb = ExAllocatePool(NonPagedPool, sizeof(IRB));

  0004e	68 57 64 6d 20	 push	 544040023		; 206d6457H
  00053	68 58 01 00 00	 push	 344			; 00000158H
  00058	57		 push	 edi
  00059	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExAllocatePoolWithTag@12
  0005f	8b f0		 mov	 esi, eax

; 1241 : 
; 1242 :     if (!pIrb) {

  00061	3b f7		 cmp	 esi, edi
  00063	75 0a		 jne	 SHORT $L10225

; 1243 : 
; 1244 :         TRACE(TL_ERROR, ("Failed to allocate pIrb!\n"));
; 1245 :         ntStatus = STATUS_INSUFFICIENT_RESOURCES;

  00065	bb 9a 00 00 c0	 mov	 ebx, -1073741670	; c000009aH

; 1246 :         goto Exit_IsochQueryResources;

  0006a	e9 82 00 00 00	 jmp	 $Exit_IsochQueryResources$10223
$L10225:

; 1247 :     } // if
; 1248 : 
; 1249 :     RtlZeroMemory (pIrb, sizeof (IRB));

  0006f	6a 56		 push	 86			; 00000056H
  00071	33 c0		 xor	 eax, eax
  00073	59		 pop	 ecx
  00074	8b fe		 mov	 edi, esi
  00076	f3 ab		 rep stosd

; 1250 :     pIrb->FunctionNumber = REQUEST_ISOCH_QUERY_RESOURCES;
; 1251 :     pIrb->Flags = 0;
; 1252 :     pIrb->u.IsochQueryResources.fulSpeed = fulSpeed;

  00078	8b 45 10	 mov	 eax, DWORD PTR _fulSpeed$[ebp]
  0007b	33 ff		 xor	 edi, edi

; 1253 : 
; 1254 :     //
; 1255 :     // If we allocated this irp, submit it asynchronously and wait for its
; 1256 :     // completion event to be signaled.  Otherwise submit it synchronously
; 1257 :     //
; 1258 :     if (allocNewIrp) {

  0007d	80 7d 0b 00	 cmp	 BYTE PTR _allocNewIrp$[ebp], 0
  00081	c7 06 0f 00 00
	00		 mov	 DWORD PTR [esi], 15	; 0000000fH
  00087	89 7e 04	 mov	 DWORD PTR [esi+4], edi
  0008a	89 46 48	 mov	 DWORD PTR [esi+72], eax
  0008d	74 34		 je	 SHORT $L10228

; 1259 : 
; 1260 :         KeInitializeEvent (&Event, NotificationEvent, FALSE);

  0008f	57		 push	 edi
  00090	57		 push	 edi
  00091	8d 45 e4	 lea	 eax, DWORD PTR _Event$[ebp]
  00094	50		 push	 eax
  00095	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeInitializeEvent@12

; 1261 :         ntStatus = t1394_SubmitIrpAsync (deviceExtension->StackDeviceObject, newIrp, pIrb);

  0009b	56		 push	 esi
  0009c	ff 75 fc	 push	 DWORD PTR _newIrp$[ebp]
  0009f	ff 33		 push	 DWORD PTR [ebx]
  000a1	e8 00 00 00 00	 call	 _t1394_SubmitIrpAsync@12
  000a6	8b d8		 mov	 ebx, eax

; 1262 : 
; 1263 :         if (ntStatus == STATUS_PENDING) {

  000a8	81 fb 03 01 00
	00		 cmp	 ebx, 259		; 00000103H
  000ae	75 20		 jne	 SHORT $L10232

; 1264 :             KeWaitForSingleObject (&Event, Executive, KernelMode, FALSE, NULL); 

  000b0	57		 push	 edi
  000b1	57		 push	 edi
  000b2	57		 push	 edi
  000b3	57		 push	 edi
  000b4	8d 45 e4	 lea	 eax, DWORD PTR _Event$[ebp]
  000b7	50		 push	 eax
  000b8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeWaitForSingleObject@20

; 1265 :             ntStatus = ioStatus.Status;

  000be	8b 5d f4	 mov	 ebx, DWORD PTR _ioStatus$[ebp]

; 1266 :         }
; 1267 :     }
; 1268 :     else {

  000c1	eb 0d		 jmp	 SHORT $L10232
$L10228:

; 1269 :         ntStatus = t1394_SubmitIrpSynch(deviceExtension->StackDeviceObject, Irp, pIrb);

  000c3	56		 push	 esi
  000c4	ff 75 0c	 push	 DWORD PTR _Irp$[ebp]
  000c7	ff 33		 push	 DWORD PTR [ebx]
  000c9	e8 00 00 00 00	 call	 _t1394_SubmitIrpSynch@12
  000ce	8b d8		 mov	 ebx, eax
$L10232:

; 1270 :     }
; 1271 :     
; 1272 :     if (NT_SUCCESS(ntStatus)) {

  000d0	3b df		 cmp	 ebx, edi
  000d2	7c 16		 jl	 SHORT $L10234

; 1273 : 
; 1274 :         *pBytesPerFrameAvailable = pIrb->u.IsochQueryResources.BytesPerFrameAvailable;

  000d4	8b 46 4c	 mov	 eax, DWORD PTR [esi+76]
  000d7	8b 4d 14	 mov	 ecx, DWORD PTR _pBytesPerFrameAvailable$[ebp]
  000da	89 01		 mov	 DWORD PTR [ecx], eax

; 1275 :         *pChannelsAvailable = pIrb->u.IsochQueryResources.ChannelsAvailable;

  000dc	8b 4e 50	 mov	 ecx, DWORD PTR [esi+80]
  000df	8b 45 18	 mov	 eax, DWORD PTR _pChannelsAvailable$[ebp]
  000e2	89 08		 mov	 DWORD PTR [eax], ecx
  000e4	8b 4e 54	 mov	 ecx, DWORD PTR [esi+84]
  000e7	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$L10234:

; 1276 : 
; 1277 :         TRACE(TL_TRACE, ("BytesPerFrameAvailable = 0x%x\n", *pBytesPerFrameAvailable));
; 1278 :         TRACE(TL_TRACE, ("ChannelsAvailable.LowPart = 0x%x\n", pChannelsAvailable->LowPart));
; 1279 :         TRACE(TL_TRACE, ("ChannelsAvailable.HighPart = 0x%x\n", pChannelsAvailable->HighPart));
; 1280 :     }
; 1281 :     else {
; 1282 : 
; 1283 :         TRACE(TL_ERROR, ("SubmitIrpSync failed = 0x%x\n", ntStatus));
; 1284 :     }
; 1285 : 
; 1286 :     ExFreePool(pIrb);

  000ea	56		 push	 esi
  000eb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePool@4
$Exit_IsochQueryResources$10223:

; 1287 : 
; 1288 : Exit_IsochQueryResources:
; 1289 : 
; 1290 :     if (allocNewIrp) 

  000f1	80 7d 0b 00	 cmp	 BYTE PTR _allocNewIrp$[ebp], 0
  000f5	5e		 pop	 esi
  000f6	74 0f		 je	 SHORT $L10236

; 1291 :         Irp->IoStatus = ioStatus;

  000f8	8b 4d f4	 mov	 ecx, DWORD PTR _ioStatus$[ebp]
  000fb	8b 45 0c	 mov	 eax, DWORD PTR _Irp$[ebp]
  000fe	89 48 18	 mov	 DWORD PTR [eax+24], ecx
  00101	8b 4d f8	 mov	 ecx, DWORD PTR _ioStatus$[ebp+4]
  00104	89 48 1c	 mov	 DWORD PTR [eax+28], ecx
$L10236:
  00107	5f		 pop	 edi

; 1292 :         
; 1293 :     EXIT("t1394_IsochQueryResources", ntStatus);
; 1294 :     return(ntStatus);

  00108	8b c3		 mov	 eax, ebx
  0010a	5b		 pop	 ebx

; 1295 : } // t1394_IsochQueryResources

  0010b	c9		 leave
  0010c	c2 14 00	 ret	 20			; 00000014H
_t1394_IsochQueryResources@20 ENDP
_TEXT	ENDS
PUBLIC	_t1394_IsochSetChannelBandwidth@16
; Function compile flags: /Ogsy
;	COMDAT _t1394_IsochSetChannelBandwidth@16
_TEXT	SEGMENT
_Event$ = -28						; size = 16
_ioStatus$ = -12					; size = 8
_newIrp$ = -4						; size = 4
_DeviceObject$ = 8					; size = 4
_allocNewIrp$ = 11					; size = 1
_Irp$ = 12						; size = 4
_hBandwidth$ = 16					; size = 4
_nMaxBytesPerFrame$ = 20				; size = 4
_t1394_IsochSetChannelBandwidth@16 PROC NEAR		; COMDAT

; 1304 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH

; 1305 :     NTSTATUS            ntStatus = STATUS_SUCCESS;
; 1306 :     PDEVICE_EXTENSION   deviceExtension = DeviceObject->DeviceExtension;

  00006	8b 45 08	 mov	 eax, DWORD PTR _DeviceObject$[ebp]
  00009	53		 push	 ebx
  0000a	8b 58 28	 mov	 ebx, DWORD PTR [eax+40]

; 1307 :     PIRB                pIrb;
; 1308 : 
; 1309 :     PIRP                newIrp;
; 1310 :     BOOLEAN             allocNewIrp = FALSE;
; 1311 :     KEVENT              Event;
; 1312 :     IO_STATUS_BLOCK     ioStatus;
; 1313 :     
; 1314 :     ENTER("t1394_IsochSetChannelBandwidth");
; 1315 : 
; 1316 :     TRACE(TL_TRACE, ("hBandwidth = 0x%x\n", hBandwidth));
; 1317 :     TRACE(TL_TRACE, ("nMaxBytesPerFrame = 0x%x\n", nMaxBytesPerFrame));
; 1318 : 
; 1319 :     //
; 1320 :     // If this is a UserMode request create a newIrp so that the request
; 1321 :     // will be issued from KernelMode
; 1322 :     //
; 1323 :     if (Irp->RequestorMode == UserMode) {

  0000d	8b 45 0c	 mov	 eax, DWORD PTR _Irp$[ebp]
  00010	57		 push	 edi

; 1324 : 
; 1325 :         newIrp = IoBuildDeviceIoControlRequest (IOCTL_1394_CLASS, deviceExtension->StackDeviceObject, 
; 1326 :                             NULL, 0, NULL, 0, TRUE, &Event, &ioStatus);

  00011	33 ff		 xor	 edi, edi
  00013	80 78 20 01	 cmp	 BYTE PTR [eax+32], 1
  00017	c6 45 0b 00	 mov	 BYTE PTR _allocNewIrp$[ebp], 0
  0001b	75 30		 jne	 SHORT $L10254
  0001d	8d 45 f4	 lea	 eax, DWORD PTR _ioStatus$[ebp]
  00020	50		 push	 eax
  00021	8d 45 e4	 lea	 eax, DWORD PTR _Event$[ebp]
  00024	50		 push	 eax
  00025	6a 01		 push	 1
  00027	57		 push	 edi
  00028	57		 push	 edi
  00029	57		 push	 edi
  0002a	57		 push	 edi
  0002b	ff 33		 push	 DWORD PTR [ebx]
  0002d	68 1d 02 22 00	 push	 2228765			; 0022021dH
  00032	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoBuildDeviceIoControlRequest@36

; 1327 : 
; 1328 :         if (!newIrp) {

  00038	3b c7		 cmp	 eax, edi
  0003a	89 45 fc	 mov	 DWORD PTR _newIrp$[ebp], eax
  0003d	75 0a		 jne	 SHORT $L10257

; 1329 : 
; 1330 :             TRACE(TL_ERROR, ("Failed to allocate newIrp!\n"));        
; 1331 :             ntStatus = STATUS_INSUFFICIENT_RESOURCES;

  0003f	bb 9a 00 00 c0	 mov	 ebx, -1073741670	; c000009aH

; 1332 :             goto Exit_IsochSetChannelBandwidth;            

  00044	e9 a7 00 00 00	 jmp	 $L10271
$L10257:

; 1333 :         }
; 1334 :         allocNewIrp = TRUE;

  00049	c6 45 0b 01	 mov	 BYTE PTR _allocNewIrp$[ebp], 1
$L10254:
  0004d	56		 push	 esi

; 1335 :     }
; 1336 :     
; 1337 :     pIrb = ExAllocatePool(NonPagedPool, sizeof(IRB));

  0004e	68 57 64 6d 20	 push	 544040023		; 206d6457H
  00053	68 58 01 00 00	 push	 344			; 00000158H
  00058	57		 push	 edi
  00059	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExAllocatePoolWithTag@12
  0005f	8b f0		 mov	 esi, eax

; 1338 : 
; 1339 :     if (!pIrb) {

  00061	3b f7		 cmp	 esi, edi
  00063	75 07		 jne	 SHORT $L10261

; 1340 : 
; 1341 :         TRACE(TL_ERROR, ("Failed to allocate pIrb!\n"));
; 1342 :         ntStatus = STATUS_INSUFFICIENT_RESOURCES;

  00065	bb 9a 00 00 c0	 mov	 ebx, -1073741670	; c000009aH

; 1343 :         goto Exit_IsochSetChannelBandwidth;

  0006a	eb 6e		 jmp	 SHORT $Exit_IsochSetChannelBandwidth$10259
$L10261:

; 1344 :     } // if
; 1345 : 
; 1346 :     RtlZeroMemory (pIrb, sizeof (IRB));

  0006c	33 c0		 xor	 eax, eax
  0006e	6a 56		 push	 86			; 00000056H
  00070	59		 pop	 ecx
  00071	8b fe		 mov	 edi, esi
  00073	f3 ab		 rep stosd

; 1347 :     pIrb->FunctionNumber = REQUEST_ISOCH_SET_CHANNEL_BANDWIDTH;
; 1348 :     pIrb->Flags = 0;
; 1349 :     pIrb->u.IsochSetChannelBandwidth.hBandwidth = hBandwidth;

  00075	8b 45 10	 mov	 eax, DWORD PTR _hBandwidth$[ebp]
  00078	33 ff		 xor	 edi, edi

; 1350 :     pIrb->u.IsochSetChannelBandwidth.nMaxBytesPerFrame = nMaxBytesPerFrame;
; 1351 : 
; 1352 :     //
; 1353 :     // If we allocated this irp, submit it asynchronously and wait for its
; 1354 :     // completion event to be signaled.  Otherwise submit it synchronously
; 1355 :     //
; 1356 :     if (allocNewIrp) {

  0007a	80 7d 0b 00	 cmp	 BYTE PTR _allocNewIrp$[ebp], 0
  0007e	89 46 48	 mov	 DWORD PTR [esi+72], eax
  00081	8b 45 14	 mov	 eax, DWORD PTR _nMaxBytesPerFrame$[ebp]
  00084	c7 06 10 00 00
	00		 mov	 DWORD PTR [esi], 16	; 00000010H
  0008a	89 7e 04	 mov	 DWORD PTR [esi+4], edi
  0008d	89 46 4c	 mov	 DWORD PTR [esi+76], eax
  00090	74 34		 je	 SHORT $L10264

; 1357 : 
; 1358 :         KeInitializeEvent (&Event, NotificationEvent, FALSE);

  00092	57		 push	 edi
  00093	57		 push	 edi
  00094	8d 45 e4	 lea	 eax, DWORD PTR _Event$[ebp]
  00097	50		 push	 eax
  00098	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeInitializeEvent@12

; 1359 :         ntStatus = t1394_SubmitIrpAsync (deviceExtension->StackDeviceObject, newIrp, pIrb);

  0009e	56		 push	 esi
  0009f	ff 75 fc	 push	 DWORD PTR _newIrp$[ebp]
  000a2	ff 33		 push	 DWORD PTR [ebx]
  000a4	e8 00 00 00 00	 call	 _t1394_SubmitIrpAsync@12
  000a9	8b d8		 mov	 ebx, eax

; 1360 : 
; 1361 :         if (ntStatus == STATUS_PENDING) {

  000ab	81 fb 03 01 00
	00		 cmp	 ebx, 259		; 00000103H
  000b1	75 20		 jne	 SHORT $L10268

; 1362 :             KeWaitForSingleObject (&Event, Executive, KernelMode, FALSE, NULL); 

  000b3	57		 push	 edi
  000b4	57		 push	 edi
  000b5	57		 push	 edi
  000b6	57		 push	 edi
  000b7	8d 45 e4	 lea	 eax, DWORD PTR _Event$[ebp]
  000ba	50		 push	 eax
  000bb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeWaitForSingleObject@20

; 1363 :             ntStatus = ioStatus.Status;

  000c1	8b 5d f4	 mov	 ebx, DWORD PTR _ioStatus$[ebp]

; 1364 :         }
; 1365 :     }
; 1366 :     else {

  000c4	eb 0d		 jmp	 SHORT $L10268
$L10264:

; 1367 :         ntStatus = t1394_SubmitIrpSynch(deviceExtension->StackDeviceObject, Irp, pIrb);

  000c6	56		 push	 esi
  000c7	ff 75 0c	 push	 DWORD PTR _Irp$[ebp]
  000ca	ff 33		 push	 DWORD PTR [ebx]
  000cc	e8 00 00 00 00	 call	 _t1394_SubmitIrpSynch@12
  000d1	8b d8		 mov	 ebx, eax
$L10268:

; 1368 :     }
; 1369 :     
; 1370 :     if (!NT_SUCCESS(ntStatus)) {
; 1371 : 
; 1372 :         TRACE(TL_ERROR, ("SubmitIrpSync failed = 0x%x\n", ntStatus));
; 1373 :     }
; 1374 :     
; 1375 :     ExFreePool(pIrb);

  000d3	56		 push	 esi
  000d4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePool@4
$Exit_IsochSetChannelBandwidth$10259:

; 1376 : 
; 1377 : Exit_IsochSetChannelBandwidth:
; 1378 : 
; 1379 :     if (allocNewIrp) 

  000da	80 7d 0b 00	 cmp	 BYTE PTR _allocNewIrp$[ebp], 0
  000de	5e		 pop	 esi
  000df	74 0f		 je	 SHORT $L10271

; 1380 :         Irp->IoStatus = ioStatus;

  000e1	8b 4d f4	 mov	 ecx, DWORD PTR _ioStatus$[ebp]
  000e4	8b 45 0c	 mov	 eax, DWORD PTR _Irp$[ebp]
  000e7	89 48 18	 mov	 DWORD PTR [eax+24], ecx
  000ea	8b 4d f8	 mov	 ecx, DWORD PTR _ioStatus$[ebp+4]
  000ed	89 48 1c	 mov	 DWORD PTR [eax+28], ecx
$L10271:
  000f0	5f		 pop	 edi

; 1381 :         
; 1382 :     EXIT("t1394_IsochSetChannelBandwidth",  ntStatus);
; 1383 :     return(ntStatus);

  000f1	8b c3		 mov	 eax, ebx
  000f3	5b		 pop	 ebx

; 1384 : } // t1394_IsochSetChannelBandwidth

  000f4	c9		 leave
  000f5	c2 10 00	 ret	 16			; 00000010H
_t1394_IsochSetChannelBandwidth@16 ENDP
_TEXT	ENDS
PUBLIC	_t1394_IsochModifyStreamProperties@24
; Function compile flags: /Ogsy
;	COMDAT _t1394_IsochModifyStreamProperties@24
_TEXT	SEGMENT
_Event$ = -28						; size = 16
_ioStatus$ = -12					; size = 8
_newIrp$ = -4						; size = 4
_DeviceObject$ = 8					; size = 4
_allocNewIrp$ = 11					; size = 1
_Irp$ = 12						; size = 4
_hResource$ = 16					; size = 4
_ChannelMask$ = 20					; size = 8
_fulSpeed$ = 28						; size = 4
_t1394_IsochModifyStreamProperties@24 PROC NEAR		; COMDAT

; 1395 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH

; 1396 :     NTSTATUS            ntStatus = STATUS_SUCCESS;
; 1397 :     PDEVICE_EXTENSION   deviceExtension = DeviceObject->DeviceExtension;

  00006	8b 45 08	 mov	 eax, DWORD PTR _DeviceObject$[ebp]
  00009	53		 push	 ebx
  0000a	8b 58 28	 mov	 ebx, DWORD PTR [eax+40]

; 1398 :     PIRB                pIrb;
; 1399 : 
; 1400 :     PIRP                newIrp;
; 1401 :     BOOLEAN             allocNewIrp = FALSE;
; 1402 :     KEVENT              Event;
; 1403 :     IO_STATUS_BLOCK     ioStatus;
; 1404 :     
; 1405 :     //
; 1406 :     // If this is a UserMode request create a newIrp so that the request
; 1407 :     // will be issued from KernelMode
; 1408 :     //
; 1409 :     if (Irp->RequestorMode == UserMode) {

  0000d	8b 45 0c	 mov	 eax, DWORD PTR _Irp$[ebp]
  00010	57		 push	 edi

; 1410 : 
; 1411 :         newIrp = IoBuildDeviceIoControlRequest (IOCTL_1394_CLASS, deviceExtension->StackDeviceObject, 
; 1412 :                             NULL, 0, NULL, 0, TRUE, &Event, &ioStatus);

  00011	33 ff		 xor	 edi, edi
  00013	80 78 20 01	 cmp	 BYTE PTR [eax+32], 1
  00017	c6 45 0b 00	 mov	 BYTE PTR _allocNewIrp$[ebp], 0
  0001b	75 30		 jne	 SHORT $L10291
  0001d	8d 45 f4	 lea	 eax, DWORD PTR _ioStatus$[ebp]
  00020	50		 push	 eax
  00021	8d 45 e4	 lea	 eax, DWORD PTR _Event$[ebp]
  00024	50		 push	 eax
  00025	6a 01		 push	 1
  00027	57		 push	 edi
  00028	57		 push	 edi
  00029	57		 push	 edi
  0002a	57		 push	 edi
  0002b	ff 33		 push	 DWORD PTR [ebx]
  0002d	68 1d 02 22 00	 push	 2228765			; 0022021dH
  00032	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoBuildDeviceIoControlRequest@36

; 1413 : 
; 1414 :         if (!newIrp) {

  00038	3b c7		 cmp	 eax, edi
  0003a	89 45 fc	 mov	 DWORD PTR _newIrp$[ebp], eax
  0003d	75 0a		 jne	 SHORT $L10294

; 1415 : 
; 1416 :             TRACE(TL_ERROR, ("Failed to allocate newIrp!\n"));        
; 1417 :             ntStatus = STATUS_INSUFFICIENT_RESOURCES;

  0003f	bb 9a 00 00 c0	 mov	 ebx, -1073741670	; c000009aH

; 1418 :             goto Exit_IsochModifyStreamProperties;            

  00044	e9 b3 00 00 00	 jmp	 $L10308
$L10294:

; 1419 :         }
; 1420 :         allocNewIrp = TRUE;

  00049	c6 45 0b 01	 mov	 BYTE PTR _allocNewIrp$[ebp], 1
$L10291:
  0004d	56		 push	 esi

; 1421 :     }
; 1422 :     
; 1423 :     pIrb = ExAllocatePool(NonPagedPool, sizeof(IRB));

  0004e	68 57 64 6d 20	 push	 544040023		; 206d6457H
  00053	68 58 01 00 00	 push	 344			; 00000158H
  00058	57		 push	 edi
  00059	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExAllocatePoolWithTag@12
  0005f	8b f0		 mov	 esi, eax

; 1424 : 
; 1425 :     if (!pIrb) {

  00061	3b f7		 cmp	 esi, edi
  00063	75 07		 jne	 SHORT $L10298

; 1426 : 
; 1427 :         TRACE(TL_ERROR, ("Failed to allocate pIrb!\n"));
; 1428 :         ntStatus = STATUS_INSUFFICIENT_RESOURCES;

  00065	bb 9a 00 00 c0	 mov	 ebx, -1073741670	; c000009aH

; 1429 :         goto Exit_IsochModifyStreamProperties;

  0006a	eb 7a		 jmp	 SHORT $Exit_IsochModifyStreamProperties$10296
$L10298:

; 1430 :     } // if
; 1431 : 
; 1432 :     RtlZeroMemory (pIrb, sizeof (IRB));

  0006c	33 c0		 xor	 eax, eax
  0006e	6a 56		 push	 86			; 00000056H
  00070	59		 pop	 ecx
  00071	8b fe		 mov	 edi, esi
  00073	f3 ab		 rep stosd

; 1433 :     pIrb->FunctionNumber = REQUEST_ISOCH_MODIFY_STREAM_PROPERTIES;
; 1434 :     pIrb->Flags = 0;
; 1435 :     pIrb->u.IsochModifyStreamProperties.hResource       = hResource;

  00075	8b 45 10	 mov	 eax, DWORD PTR _hResource$[ebp]
  00078	89 46 48	 mov	 DWORD PTR [esi+72], eax

; 1436 :     pIrb->u.IsochModifyStreamProperties.ChannelMask     = ChannelMask;

  0007b	8b 45 14	 mov	 eax, DWORD PTR _ChannelMask$[ebp]
  0007e	89 46 50	 mov	 DWORD PTR [esi+80], eax
  00081	8b 45 18	 mov	 eax, DWORD PTR _ChannelMask$[ebp+4]
  00084	33 ff		 xor	 edi, edi

; 1437 :     pIrb->u.IsochModifyStreamProperties.fulSpeed        = fulSpeed;
; 1438 : 
; 1439 :     //
; 1440 :     // If we allocated this irp, submit it asynchronously and wait for its
; 1441 :     // completion event to be signaled.  Otherwise submit it synchronously
; 1442 :     //
; 1443 :     if (allocNewIrp) {

  00086	80 7d 0b 00	 cmp	 BYTE PTR _allocNewIrp$[ebp], 0
  0008a	89 46 54	 mov	 DWORD PTR [esi+84], eax
  0008d	8b 45 1c	 mov	 eax, DWORD PTR _fulSpeed$[ebp]
  00090	c7 06 20 00 00
	00		 mov	 DWORD PTR [esi], 32	; 00000020H
  00096	89 7e 04	 mov	 DWORD PTR [esi+4], edi
  00099	89 46 58	 mov	 DWORD PTR [esi+88], eax
  0009c	74 34		 je	 SHORT $L10301

; 1444 : 
; 1445 :         KeInitializeEvent (&Event, NotificationEvent, FALSE);

  0009e	57		 push	 edi
  0009f	57		 push	 edi
  000a0	8d 45 e4	 lea	 eax, DWORD PTR _Event$[ebp]
  000a3	50		 push	 eax
  000a4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeInitializeEvent@12

; 1446 :         ntStatus = t1394_SubmitIrpAsync (deviceExtension->StackDeviceObject, newIrp, pIrb);

  000aa	56		 push	 esi
  000ab	ff 75 fc	 push	 DWORD PTR _newIrp$[ebp]
  000ae	ff 33		 push	 DWORD PTR [ebx]
  000b0	e8 00 00 00 00	 call	 _t1394_SubmitIrpAsync@12
  000b5	8b d8		 mov	 ebx, eax

; 1447 : 
; 1448 :         if (ntStatus == STATUS_PENDING) {

  000b7	81 fb 03 01 00
	00		 cmp	 ebx, 259		; 00000103H
  000bd	75 20		 jne	 SHORT $L10305

; 1449 :             KeWaitForSingleObject (&Event, Executive, KernelMode, FALSE, NULL); 

  000bf	57		 push	 edi
  000c0	57		 push	 edi
  000c1	57		 push	 edi
  000c2	57		 push	 edi
  000c3	8d 45 e4	 lea	 eax, DWORD PTR _Event$[ebp]
  000c6	50		 push	 eax
  000c7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeWaitForSingleObject@20

; 1450 :             ntStatus = ioStatus.Status;

  000cd	8b 5d f4	 mov	 ebx, DWORD PTR _ioStatus$[ebp]

; 1451 :         }
; 1452 :     }
; 1453 :     else {

  000d0	eb 0d		 jmp	 SHORT $L10305
$L10301:

; 1454 :         ntStatus = t1394_SubmitIrpSynch(deviceExtension->StackDeviceObject, Irp, pIrb);

  000d2	56		 push	 esi
  000d3	ff 75 0c	 push	 DWORD PTR _Irp$[ebp]
  000d6	ff 33		 push	 DWORD PTR [ebx]
  000d8	e8 00 00 00 00	 call	 _t1394_SubmitIrpSynch@12
  000dd	8b d8		 mov	 ebx, eax
$L10305:

; 1455 :     }
; 1456 :     
; 1457 :     if (!NT_SUCCESS(ntStatus)) {
; 1458 : 
; 1459 :         TRACE(TL_ERROR, ("SubmitIrpSync failed = 0x%x\n", ntStatus));
; 1460 :     }
; 1461 :     
; 1462 :     ExFreePool(pIrb);

  000df	56		 push	 esi
  000e0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePool@4
$Exit_IsochModifyStreamProperties$10296:

; 1463 : 
; 1464 : Exit_IsochModifyStreamProperties:
; 1465 : 
; 1466 :     if (allocNewIrp) 

  000e6	80 7d 0b 00	 cmp	 BYTE PTR _allocNewIrp$[ebp], 0
  000ea	5e		 pop	 esi
  000eb	74 0f		 je	 SHORT $L10308

; 1467 :         Irp->IoStatus = ioStatus;

  000ed	8b 4d f4	 mov	 ecx, DWORD PTR _ioStatus$[ebp]
  000f0	8b 45 0c	 mov	 eax, DWORD PTR _Irp$[ebp]
  000f3	89 48 18	 mov	 DWORD PTR [eax+24], ecx
  000f6	8b 4d f8	 mov	 ecx, DWORD PTR _ioStatus$[ebp+4]
  000f9	89 48 1c	 mov	 DWORD PTR [eax+28], ecx
$L10308:
  000fc	5f		 pop	 edi

; 1468 : 
; 1469 :     EXIT("t1394_IsochModifyStreamProperties", ntStatus);
; 1470 :     return ntStatus;

  000fd	8b c3		 mov	 eax, ebx
  000ff	5b		 pop	 ebx

; 1471 : }

  00100	c9		 leave
  00101	c2 18 00	 ret	 24			; 00000018H
_t1394_IsochModifyStreamProperties@24 ENDP
_TEXT	ENDS
PUBLIC	_t1394_IsochStop@16
; Function compile flags: /Ogsy
;	COMDAT _t1394_IsochStop@16
_TEXT	SEGMENT
_Event$ = -28						; size = 16
_ioStatus$ = -12					; size = 8
_newIrp$ = -4						; size = 4
_DeviceObject$ = 8					; size = 4
_allocNewIrp$ = 11					; size = 1
_Irp$ = 12						; size = 4
_hResource$ = 16					; size = 4
_fulFlags$ = 20						; size = 4
_t1394_IsochStop@16 PROC NEAR				; COMDAT

; 1480 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH

; 1481 :     NTSTATUS            ntStatus = STATUS_SUCCESS;
; 1482 :     PDEVICE_EXTENSION   deviceExtension = DeviceObject->DeviceExtension;

  00006	8b 45 08	 mov	 eax, DWORD PTR _DeviceObject$[ebp]
  00009	53		 push	 ebx
  0000a	8b 58 28	 mov	 ebx, DWORD PTR [eax+40]

; 1483 :     PIRB                pIrb;
; 1484 : 
; 1485 :     PIRP                newIrp;
; 1486 :     BOOLEAN             allocNewIrp = FALSE;
; 1487 :     KEVENT              Event;
; 1488 :     IO_STATUS_BLOCK     ioStatus;
; 1489 :     
; 1490 :     ENTER("t1394_IsochStop");
; 1491 : 
; 1492 :     TRACE(TL_TRACE, ("hResource = 0x%x\n", hResource));
; 1493 :     TRACE(TL_TRACE, ("fulFlags = 0x%x\n", fulFlags));
; 1494 : 
; 1495 :     //
; 1496 :     // If this is a UserMode request create a newIrp so that the request
; 1497 :     // will be issued from KernelMode
; 1498 :     //
; 1499 :     if (Irp->RequestorMode == UserMode) {

  0000d	8b 45 0c	 mov	 eax, DWORD PTR _Irp$[ebp]
  00010	57		 push	 edi

; 1500 : 
; 1501 :         newIrp = IoBuildDeviceIoControlRequest (IOCTL_1394_CLASS, deviceExtension->StackDeviceObject, 
; 1502 :                             NULL, 0, NULL, 0, TRUE, &Event, &ioStatus);

  00011	33 ff		 xor	 edi, edi
  00013	80 78 20 01	 cmp	 BYTE PTR [eax+32], 1
  00017	c6 45 0b 00	 mov	 BYTE PTR _allocNewIrp$[ebp], 0
  0001b	75 30		 jne	 SHORT $L10326
  0001d	8d 45 f4	 lea	 eax, DWORD PTR _ioStatus$[ebp]
  00020	50		 push	 eax
  00021	8d 45 e4	 lea	 eax, DWORD PTR _Event$[ebp]
  00024	50		 push	 eax
  00025	6a 01		 push	 1
  00027	57		 push	 edi
  00028	57		 push	 edi
  00029	57		 push	 edi
  0002a	57		 push	 edi
  0002b	ff 33		 push	 DWORD PTR [ebx]
  0002d	68 1d 02 22 00	 push	 2228765			; 0022021dH
  00032	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoBuildDeviceIoControlRequest@36

; 1503 : 
; 1504 :         if (!newIrp) {

  00038	3b c7		 cmp	 eax, edi
  0003a	89 45 fc	 mov	 DWORD PTR _newIrp$[ebp], eax
  0003d	75 0a		 jne	 SHORT $L10329

; 1505 : 
; 1506 :             TRACE(TL_ERROR, ("Failed to allocate newIrp!\n"));        
; 1507 :             ntStatus = STATUS_INSUFFICIENT_RESOURCES;

  0003f	bb 9a 00 00 c0	 mov	 ebx, -1073741670	; c000009aH

; 1508 :             goto Exit_IsochStop;            

  00044	e9 a7 00 00 00	 jmp	 $L10343
$L10329:

; 1509 :         }
; 1510 :         allocNewIrp = TRUE;

  00049	c6 45 0b 01	 mov	 BYTE PTR _allocNewIrp$[ebp], 1
$L10326:
  0004d	56		 push	 esi

; 1511 :     }
; 1512 :     
; 1513 :     pIrb = ExAllocatePool(NonPagedPool, sizeof(IRB));

  0004e	68 57 64 6d 20	 push	 544040023		; 206d6457H
  00053	68 58 01 00 00	 push	 344			; 00000158H
  00058	57		 push	 edi
  00059	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExAllocatePoolWithTag@12
  0005f	8b f0		 mov	 esi, eax

; 1514 : 
; 1515 :     if (!pIrb) {

  00061	3b f7		 cmp	 esi, edi
  00063	75 07		 jne	 SHORT $L10333

; 1516 : 
; 1517 :         TRACE(TL_ERROR, ("Failed to allocate pIrb!\n"));
; 1518 :         ntStatus = STATUS_INSUFFICIENT_RESOURCES;

  00065	bb 9a 00 00 c0	 mov	 ebx, -1073741670	; c000009aH

; 1519 :         goto Exit_IsochStop;

  0006a	eb 6e		 jmp	 SHORT $Exit_IsochStop$10331
$L10333:

; 1520 :     } // if
; 1521 : 
; 1522 :     RtlZeroMemory (pIrb, sizeof (IRB));

  0006c	33 c0		 xor	 eax, eax
  0006e	6a 56		 push	 86			; 00000056H
  00070	59		 pop	 ecx
  00071	8b fe		 mov	 edi, esi
  00073	f3 ab		 rep stosd

; 1523 :     pIrb->FunctionNumber = REQUEST_ISOCH_STOP;
; 1524 :     pIrb->Flags = 0;
; 1525 :     pIrb->u.IsochStop.hResource = hResource;

  00075	8b 45 10	 mov	 eax, DWORD PTR _hResource$[ebp]
  00078	33 ff		 xor	 edi, edi

; 1526 :     pIrb->u.IsochStop.fulFlags = fulFlags;
; 1527 : 
; 1528 :     //
; 1529 :     // If we allocated this irp, submit it asynchronously and wait for its
; 1530 :     // completion event to be signaled.  Otherwise submit it synchronously
; 1531 :     //
; 1532 :     if (allocNewIrp) {

  0007a	80 7d 0b 00	 cmp	 BYTE PTR _allocNewIrp$[ebp], 0
  0007e	89 46 48	 mov	 DWORD PTR [esi+72], eax
  00081	8b 45 14	 mov	 eax, DWORD PTR _fulFlags$[ebp]
  00084	c7 06 0c 00 00
	00		 mov	 DWORD PTR [esi], 12	; 0000000cH
  0008a	89 7e 04	 mov	 DWORD PTR [esi+4], edi
  0008d	89 46 4c	 mov	 DWORD PTR [esi+76], eax
  00090	74 34		 je	 SHORT $L10336

; 1533 : 
; 1534 :         KeInitializeEvent (&Event, NotificationEvent, FALSE);

  00092	57		 push	 edi
  00093	57		 push	 edi
  00094	8d 45 e4	 lea	 eax, DWORD PTR _Event$[ebp]
  00097	50		 push	 eax
  00098	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeInitializeEvent@12

; 1535 :         ntStatus = t1394_SubmitIrpAsync (deviceExtension->StackDeviceObject, newIrp, pIrb);

  0009e	56		 push	 esi
  0009f	ff 75 fc	 push	 DWORD PTR _newIrp$[ebp]
  000a2	ff 33		 push	 DWORD PTR [ebx]
  000a4	e8 00 00 00 00	 call	 _t1394_SubmitIrpAsync@12
  000a9	8b d8		 mov	 ebx, eax

; 1536 : 
; 1537 :         if (ntStatus == STATUS_PENDING) {

  000ab	81 fb 03 01 00
	00		 cmp	 ebx, 259		; 00000103H
  000b1	75 20		 jne	 SHORT $L10340

; 1538 :             KeWaitForSingleObject (&Event, Executive, KernelMode, FALSE, NULL); 

  000b3	57		 push	 edi
  000b4	57		 push	 edi
  000b5	57		 push	 edi
  000b6	57		 push	 edi
  000b7	8d 45 e4	 lea	 eax, DWORD PTR _Event$[ebp]
  000ba	50		 push	 eax
  000bb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeWaitForSingleObject@20

; 1539 :             ntStatus = ioStatus.Status;

  000c1	8b 5d f4	 mov	 ebx, DWORD PTR _ioStatus$[ebp]

; 1540 :         }
; 1541 :     }
; 1542 :     else {

  000c4	eb 0d		 jmp	 SHORT $L10340
$L10336:

; 1543 :         ntStatus = t1394_SubmitIrpSynch(deviceExtension->StackDeviceObject, Irp, pIrb);

  000c6	56		 push	 esi
  000c7	ff 75 0c	 push	 DWORD PTR _Irp$[ebp]
  000ca	ff 33		 push	 DWORD PTR [ebx]
  000cc	e8 00 00 00 00	 call	 _t1394_SubmitIrpSynch@12
  000d1	8b d8		 mov	 ebx, eax
$L10340:

; 1544 :     }
; 1545 :  
; 1546 :     if (!NT_SUCCESS(ntStatus)) {
; 1547 : 
; 1548 :         TRACE(TL_ERROR, ("SubmitIrpSync failed = 0x%x\n", ntStatus));
; 1549 :     }
; 1550 :     
; 1551 :     ExFreePool(pIrb);

  000d3	56		 push	 esi
  000d4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePool@4
$Exit_IsochStop$10331:

; 1552 :     
; 1553 : Exit_IsochStop:
; 1554 : 
; 1555 :     if (allocNewIrp) 

  000da	80 7d 0b 00	 cmp	 BYTE PTR _allocNewIrp$[ebp], 0
  000de	5e		 pop	 esi
  000df	74 0f		 je	 SHORT $L10343

; 1556 :         Irp->IoStatus = ioStatus;

  000e1	8b 4d f4	 mov	 ecx, DWORD PTR _ioStatus$[ebp]
  000e4	8b 45 0c	 mov	 eax, DWORD PTR _Irp$[ebp]
  000e7	89 48 18	 mov	 DWORD PTR [eax+24], ecx
  000ea	8b 4d f8	 mov	 ecx, DWORD PTR _ioStatus$[ebp+4]
  000ed	89 48 1c	 mov	 DWORD PTR [eax+28], ecx
$L10343:
  000f0	5f		 pop	 edi

; 1557 :         
; 1558 :     EXIT("t1394_IsochStop", ntStatus);
; 1559 :     return(ntStatus);

  000f1	8b c3		 mov	 eax, ebx
  000f3	5b		 pop	 ebx

; 1560 : } // t1394_IsochStop

  000f4	c9		 leave
  000f5	c2 10 00	 ret	 16			; 00000010H
_t1394_IsochStop@16 ENDP
_TEXT	ENDS
PUBLIC	_t1394_IsochTalk@20
; Function compile flags: /Ogsy
;	COMDAT _t1394_IsochTalk@20
_TEXT	SEGMENT
_Event$ = -28						; size = 16
_ioStatus$ = -12					; size = 8
_newIrp$ = -4						; size = 4
_DeviceObject$ = 8					; size = 4
_allocNewIrp$ = 11					; size = 1
_Irp$ = 12						; size = 4
_hResource$ = 16					; size = 4
_fulFlags$ = 20						; size = 4
_StartTime$ = 24					; size = 4
_t1394_IsochTalk@20 PROC NEAR				; COMDAT

; 1570 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH

; 1571 :     NTSTATUS            ntStatus = STATUS_SUCCESS;
; 1572 :     PDEVICE_EXTENSION   deviceExtension = DeviceObject->DeviceExtension;

  00006	8b 45 08	 mov	 eax, DWORD PTR _DeviceObject$[ebp]
  00009	53		 push	 ebx
  0000a	8b 58 28	 mov	 ebx, DWORD PTR [eax+40]

; 1573 :     PIRB                pIrb;
; 1574 : 
; 1575 :     PIRP                newIrp;
; 1576 :     BOOLEAN             allocNewIrp = FALSE;
; 1577 :     KEVENT              Event;
; 1578 :     IO_STATUS_BLOCK     ioStatus;
; 1579 :     
; 1580 :     ENTER("t1394_IsochTalk");
; 1581 : 
; 1582 :     TRACE(TL_TRACE, ("hResource = 0x%x\n", hResource));
; 1583 :     TRACE(TL_TRACE, ("fulFlags = 0x%x\n", fulFlags));
; 1584 :     TRACE(TL_TRACE, ("StartTime.CL_CycleOffset = 0x%x\n", StartTime.CL_CycleOffset));
; 1585 :     TRACE(TL_TRACE, ("StartTime.CL_CycleCount = 0x%x\n", StartTime.CL_CycleCount));
; 1586 :     TRACE(TL_TRACE, ("StartTime.CL_SecondCount = 0x%x\n", StartTime.CL_SecondCount));
; 1587 : 
; 1588 :     //
; 1589 :     // If this is a UserMode request create a newIrp so that the request
; 1590 :     // will be issued from KernelMode
; 1591 :     //
; 1592 :     if (Irp->RequestorMode == UserMode) {

  0000d	8b 45 0c	 mov	 eax, DWORD PTR _Irp$[ebp]
  00010	57		 push	 edi

; 1593 : 
; 1594 :         newIrp = IoBuildDeviceIoControlRequest (IOCTL_1394_CLASS, deviceExtension->StackDeviceObject, 
; 1595 :                             NULL, 0, NULL, 0, TRUE, &Event, &ioStatus);

  00011	33 ff		 xor	 edi, edi
  00013	80 78 20 01	 cmp	 BYTE PTR [eax+32], 1
  00017	c6 45 0b 00	 mov	 BYTE PTR _allocNewIrp$[ebp], 0
  0001b	75 30		 jne	 SHORT $L10363
  0001d	8d 45 f4	 lea	 eax, DWORD PTR _ioStatus$[ebp]
  00020	50		 push	 eax
  00021	8d 45 e4	 lea	 eax, DWORD PTR _Event$[ebp]
  00024	50		 push	 eax
  00025	6a 01		 push	 1
  00027	57		 push	 edi
  00028	57		 push	 edi
  00029	57		 push	 edi
  0002a	57		 push	 edi
  0002b	ff 33		 push	 DWORD PTR [ebx]
  0002d	68 1d 02 22 00	 push	 2228765			; 0022021dH
  00032	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoBuildDeviceIoControlRequest@36

; 1596 : 
; 1597 :         if (!newIrp) {

  00038	3b c7		 cmp	 eax, edi
  0003a	89 45 fc	 mov	 DWORD PTR _newIrp$[ebp], eax
  0003d	75 0a		 jne	 SHORT $L10366

; 1598 : 
; 1599 :             TRACE(TL_ERROR, ("Failed to allocate newIrp!\n"));        
; 1600 :             ntStatus = STATUS_INSUFFICIENT_RESOURCES;

  0003f	bb 9a 00 00 c0	 mov	 ebx, -1073741670	; c000009aH

; 1601 :             goto Exit_IsochTalk;

  00044	e9 ad 00 00 00	 jmp	 $L10380
$L10366:

; 1602 :         }
; 1603 :         allocNewIrp = TRUE;

  00049	c6 45 0b 01	 mov	 BYTE PTR _allocNewIrp$[ebp], 1
$L10363:
  0004d	56		 push	 esi

; 1604 :     }
; 1605 :     
; 1606 :     pIrb = ExAllocatePool(NonPagedPool, sizeof(IRB));

  0004e	68 57 64 6d 20	 push	 544040023		; 206d6457H
  00053	68 58 01 00 00	 push	 344			; 00000158H
  00058	57		 push	 edi
  00059	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExAllocatePoolWithTag@12
  0005f	8b f0		 mov	 esi, eax

; 1607 : 
; 1608 :     if (!pIrb) {

  00061	3b f7		 cmp	 esi, edi
  00063	75 07		 jne	 SHORT $L10370

; 1609 : 
; 1610 :         TRACE(TL_ERROR, ("Failed to allocate pIrb!\n"));
; 1611 :         ntStatus = STATUS_INSUFFICIENT_RESOURCES;

  00065	bb 9a 00 00 c0	 mov	 ebx, -1073741670	; c000009aH

; 1612 :         goto Exit_IsochTalk;

  0006a	eb 74		 jmp	 SHORT $Exit_IsochTalk$10368
$L10370:

; 1613 :     } // if
; 1614 : 
; 1615 :     RtlZeroMemory (pIrb, sizeof (IRB));

  0006c	33 c0		 xor	 eax, eax
  0006e	6a 56		 push	 86			; 00000056H
  00070	59		 pop	 ecx
  00071	8b fe		 mov	 edi, esi
  00073	f3 ab		 rep stosd

; 1616 :     pIrb->FunctionNumber = REQUEST_ISOCH_TALK;
; 1617 :     pIrb->Flags = 0;
; 1618 :     pIrb->u.IsochTalk.hResource = hResource;

  00075	8b 45 10	 mov	 eax, DWORD PTR _hResource$[ebp]
  00078	89 46 48	 mov	 DWORD PTR [esi+72], eax

; 1619 :     pIrb->u.IsochTalk.fulFlags = fulFlags;

  0007b	8b 45 14	 mov	 eax, DWORD PTR _fulFlags$[ebp]
  0007e	33 ff		 xor	 edi, edi

; 1620 :     pIrb->u.IsochTalk.StartTime = StartTime;
; 1621 : 
; 1622 :     //
; 1623 :     // If we allocated this irp, submit it asynchronously and wait for its
; 1624 :     // completion event to be signaled.  Otherwise submit it synchronously
; 1625 :     //
; 1626 :     if (allocNewIrp) {

  00080	80 7d 0b 00	 cmp	 BYTE PTR _allocNewIrp$[ebp], 0
  00084	89 46 4c	 mov	 DWORD PTR [esi+76], eax
  00087	8b 45 18	 mov	 eax, DWORD PTR _StartTime$[ebp]
  0008a	c7 06 0d 00 00
	00		 mov	 DWORD PTR [esi], 13	; 0000000dH
  00090	89 7e 04	 mov	 DWORD PTR [esi+4], edi
  00093	89 46 50	 mov	 DWORD PTR [esi+80], eax
  00096	74 34		 je	 SHORT $L10373

; 1627 : 
; 1628 :         KeInitializeEvent (&Event, NotificationEvent, FALSE);

  00098	57		 push	 edi
  00099	57		 push	 edi
  0009a	8d 45 e4	 lea	 eax, DWORD PTR _Event$[ebp]
  0009d	50		 push	 eax
  0009e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeInitializeEvent@12

; 1629 :         ntStatus = t1394_SubmitIrpAsync (deviceExtension->StackDeviceObject, newIrp, pIrb);

  000a4	56		 push	 esi
  000a5	ff 75 fc	 push	 DWORD PTR _newIrp$[ebp]
  000a8	ff 33		 push	 DWORD PTR [ebx]
  000aa	e8 00 00 00 00	 call	 _t1394_SubmitIrpAsync@12
  000af	8b d8		 mov	 ebx, eax

; 1630 : 
; 1631 :         if (ntStatus == STATUS_PENDING) {

  000b1	81 fb 03 01 00
	00		 cmp	 ebx, 259		; 00000103H
  000b7	75 20		 jne	 SHORT $L10377

; 1632 :             KeWaitForSingleObject (&Event, Executive, KernelMode, FALSE, NULL); 

  000b9	57		 push	 edi
  000ba	57		 push	 edi
  000bb	57		 push	 edi
  000bc	57		 push	 edi
  000bd	8d 45 e4	 lea	 eax, DWORD PTR _Event$[ebp]
  000c0	50		 push	 eax
  000c1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeWaitForSingleObject@20

; 1633 :             ntStatus = ioStatus.Status;

  000c7	8b 5d f4	 mov	 ebx, DWORD PTR _ioStatus$[ebp]

; 1634 :         }
; 1635 :     }
; 1636 :     else {

  000ca	eb 0d		 jmp	 SHORT $L10377
$L10373:

; 1637 :         ntStatus = t1394_SubmitIrpSynch(deviceExtension->StackDeviceObject, Irp, pIrb);

  000cc	56		 push	 esi
  000cd	ff 75 0c	 push	 DWORD PTR _Irp$[ebp]
  000d0	ff 33		 push	 DWORD PTR [ebx]
  000d2	e8 00 00 00 00	 call	 _t1394_SubmitIrpSynch@12
  000d7	8b d8		 mov	 ebx, eax
$L10377:

; 1638 :     }
; 1639 :  
; 1640 :     if (!NT_SUCCESS(ntStatus)) {
; 1641 : 
; 1642 :         TRACE(TL_ERROR, ("SubmitIrpSync failed = 0x%x\n", ntStatus));
; 1643 :     }
; 1644 :     
; 1645 :     ExFreePool(pIrb);

  000d9	56		 push	 esi
  000da	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePool@4
$Exit_IsochTalk$10368:

; 1646 : 
; 1647 : Exit_IsochTalk:
; 1648 : 
; 1649 :     if (allocNewIrp) 

  000e0	80 7d 0b 00	 cmp	 BYTE PTR _allocNewIrp$[ebp], 0
  000e4	5e		 pop	 esi
  000e5	74 0f		 je	 SHORT $L10380

; 1650 :         Irp->IoStatus = ioStatus;

  000e7	8b 4d f4	 mov	 ecx, DWORD PTR _ioStatus$[ebp]
  000ea	8b 45 0c	 mov	 eax, DWORD PTR _Irp$[ebp]
  000ed	89 48 18	 mov	 DWORD PTR [eax+24], ecx
  000f0	8b 4d f8	 mov	 ecx, DWORD PTR _ioStatus$[ebp+4]
  000f3	89 48 1c	 mov	 DWORD PTR [eax+28], ecx
$L10380:
  000f6	5f		 pop	 edi

; 1651 :         
; 1652 :     EXIT("t1394_IsochTalk", ntStatus);
; 1653 :     return(ntStatus);

  000f7	8b c3		 mov	 eax, ebx
  000f9	5b		 pop	 ebx

; 1654 : } // t1394_IsochTalk

  000fa	c9		 leave
  000fb	c2 14 00	 ret	 20			; 00000014H
_t1394_IsochTalk@20 ENDP
_TEXT	ENDS
PUBLIC	_t1394_IsochCleanup@4
; Function compile flags: /Ogsy
;	COMDAT _t1394_IsochCleanup@4
_TEXT	SEGMENT
_IsochDetachData$ = 8					; size = 4
_t1394_IsochCleanup@4 PROC NEAR				; COMDAT

; 1754 : {

  00000	53		 push	 ebx
  00001	56		 push	 esi

; 1755 :     ULONG               i;
; 1756 :     PDEVICE_EXTENSION   DeviceExtension;
; 1757 : 
; 1758 :     ENTER("t1394_IsochCleanup");
; 1759 : 
; 1760 :     DeviceExtension = IsochDetachData->DeviceExtension;

  00002	8b 74 24 0c	 mov	 esi, DWORD PTR _IsochDetachData$[esp+4]
  00006	8b 5e 08	 mov	 ebx, DWORD PTR [esi+8]
  00009	57		 push	 edi

; 1761 : 
; 1762 :     //
; 1763 :     // see if we need to detach this buffer
; 1764 :     //
; 1765 :     if ((!IsochDetachData) || (!DeviceExtension))

  0000a	33 ff		 xor	 edi, edi
  0000c	3b df		 cmp	 ebx, edi
  0000e	0f 84 ec 00 00
	00		 je	 $Exit_IsochDetachBuffers$10413

; 1766 :     {
; 1767 :         goto Exit_IsochDetachBuffers;
; 1768 :     }
; 1769 :     
; 1770 :     if (IsochDetachData->bDetach) {

  00014	39 7e 7c	 cmp	 DWORD PTR [esi+124], edi
  00017	74 7c		 je	 SHORT $L10414

; 1771 : 
; 1772 :         PIRB                pIrb;
; 1773 :         NTSTATUS            ntStatus;
; 1774 :         PIO_STACK_LOCATION  NextIrpStack;
; 1775 : 
; 1776 :         pIrb = ExAllocatePool(NonPagedPool, sizeof(IRB));

  00019	68 57 64 6d 20	 push	 544040023		; 206d6457H
  0001e	68 58 01 00 00	 push	 344			; 00000158H
  00023	57		 push	 edi
  00024	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExAllocatePoolWithTag@12
  0002a	8b d0		 mov	 edx, eax

; 1777 : 
; 1778 :         if (!pIrb) {

  0002c	3b d7		 cmp	 edx, edi
  0002e	0f 84 cc 00 00
	00		 je	 $Exit_IsochDetachBuffers$10413

; 1779 : 
; 1780 :             TRACE(TL_ERROR, ("Failed to allocate pIrb!\n"));
; 1781 :             TRACE(TL_WARNING, ("Can't detach buffer!\n"));
; 1782 :             ntStatus = STATUS_INSUFFICIENT_RESOURCES;
; 1783 :             goto Exit_IsochDetachBuffers;
; 1784 :         } // if
; 1785 : 
; 1786 :         // save the irb in our detach data context
; 1787 :         IsochDetachData->DetachIrb = pIrb;

  00034	89 56 18	 mov	 DWORD PTR [esi+24], edx

; 1788 : 
; 1789 :         RtlZeroMemory (pIrb, sizeof (IRB));

  00037	33 c0		 xor	 eax, eax
  00039	6a 56		 push	 86			; 00000056H
  0003b	8b fa		 mov	 edi, edx
  0003d	59		 pop	 ecx
  0003e	f3 ab		 rep stosd

; 1790 :         pIrb->FunctionNumber = REQUEST_ISOCH_DETACH_BUFFERS;
; 1791 :         pIrb->Flags = 0;

  00040	21 42 04	 and	 DWORD PTR [edx+4], eax
  00043	c7 02 07 00 00
	00		 mov	 DWORD PTR [edx], 7

; 1792 :         pIrb->u.IsochDetachBuffers.hResource = IsochDetachData->hResource;

  00049	8b 46 70	 mov	 eax, DWORD PTR [esi+112]
  0004c	89 42 48	 mov	 DWORD PTR [edx+72], eax

; 1793 :         pIrb->u.IsochDetachBuffers.nNumberOfDescriptors = IsochDetachData->numIsochDescriptors;

  0004f	8b 46 74	 mov	 eax, DWORD PTR [esi+116]
  00052	89 42 4c	 mov	 DWORD PTR [edx+76], eax

; 1794 :         pIrb->u.IsochDetachBuffers.pIsochDescriptor = IsochDetachData->IsochDescriptor;                                                                 

  00055	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00058	89 42 50	 mov	 DWORD PTR [edx+80], eax

; 1795 : 
; 1796 :         NextIrpStack = IoGetNextIrpStackLocation(IsochDetachData->newIrp);        

  0005b	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  0005e	8b 40 60	 mov	 eax, DWORD PTR [eax+96]
  00061	83 e8 24	 sub	 eax, 36			; 00000024H

; 1797 :         NextIrpStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;

  00064	c6 00 0f	 mov	 BYTE PTR [eax], 15	; 0000000fH

; 1798 :         NextIrpStack->Parameters.DeviceIoControl.IoControlCode = IOCTL_1394_CLASS;

  00067	c7 40 0c 1d 02
	22 00		 mov	 DWORD PTR [eax+12], 2228765 ; 0022021dH

; 1799 :         NextIrpStack->Parameters.Others.Argument1 = pIrb;

  0006e	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 1800 : 
; 1801 :         IoSetCompletionRoutine( IsochDetachData->newIrp,
; 1802 :                                 t1394_IsochDetachCompletionRoutine,
; 1803 :                                 IsochDetachData,
; 1804 :                                 TRUE,
; 1805 :                                 TRUE,
; 1806 :                                 TRUE
; 1807 :                                 );

  00071	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00074	8b 40 60	 mov	 eax, DWORD PTR [eax+96]
  00077	83 e8 24	 sub	 eax, 36			; 00000024H
  0007a	c7 40 1c 00 00
	00 00		 mov	 DWORD PTR [eax+28], OFFSET FLAT:_t1394_IsochDetachCompletionRoutine@12
  00081	89 70 20	 mov	 DWORD PTR [eax+32], esi
  00084	c6 40 03 e0	 mov	 BYTE PTR [eax+3], 224	; 000000e0H

; 1808 : 
; 1809 :         IoCallDriver(DeviceExtension->StackDeviceObject, IsochDetachData->newIrp);

  00088	8b 56 14	 mov	 edx, DWORD PTR [esi+20]
  0008b	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  0008d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@IofCallDriver@8

; 1810 :     }
; 1811 :     else {

  00093	eb 6b		 jmp	 SHORT $Exit_IsochDetachBuffers$10413
$L10414:

; 1812 : 
; 1813 :         TRACE(TL_TRACE, ("Complete Irp.\n"));
; 1814 : 
; 1815 :         if (IsochDetachData->AttachIrb)

  00095	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  00098	3b c7		 cmp	 eax, edi
  0009a	55		 push	 ebp
  0009b	8b 2d 00 00 00
	00		 mov	 ebp, DWORD PTR __imp__ExFreePool@4
  000a1	74 03		 je	 SHORT $L10428

; 1816 :         {
; 1817 :             ExFreePool(IsochDetachData->AttachIrb);

  000a3	50		 push	 eax
  000a4	ff d5		 call	 ebp
$L10428:

; 1818 :         }
; 1819 : 
; 1820 :         for (i=0; i<IsochDetachData->numIsochDescriptors; i++)

  000a6	33 db		 xor	 ebx, ebx
  000a8	39 7e 74	 cmp	 DWORD PTR [esi+116], edi
  000ab	76 1e		 jbe	 SHORT $L10431
$L10429:

; 1821 :         {
; 1822 :             if (IsochDetachData->IsochDescriptor[i].Mdl)

  000ad	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  000b0	8b 44 07 04	 mov	 eax, DWORD PTR [edi+eax+4]
  000b4	85 c0		 test	 eax, eax
  000b6	74 07		 je	 SHORT $L10430

; 1823 :             {
; 1824 :                 IoFreeMdl(IsochDetachData->IsochDescriptor[i].Mdl);

  000b8	50		 push	 eax
  000b9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoFreeMdl@4
$L10430:
  000bf	43		 inc	 ebx
  000c0	81 c7 ac 00 00
	00		 add	 edi, 172		; 000000acH
  000c6	3b 5e 74	 cmp	 ebx, DWORD PTR [esi+116]
  000c9	72 e2		 jb	 SHORT $L10429
$L10431:

; 1825 :             }
; 1826 :         }
; 1827 : 
; 1828 :         ExFreePool(IsochDetachData->IsochDescriptor);

  000cb	ff 76 0c	 push	 DWORD PTR [esi+12]
  000ce	ff d5		 call	 ebp

; 1829 : 
; 1830 :         IsochDetachData->Irp->IoStatus.Status = IsochDetachData->AttachStatus;

  000d0	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  000d3	8b 4e 20	 mov	 ecx, DWORD PTR [esi+32]
  000d6	89 48 18	 mov	 DWORD PTR [eax+24], ecx

; 1831 : 
; 1832 :         // only set this if its a success...
; 1833 :         if (NT_SUCCESS(IsochDetachData->AttachStatus))

  000d9	83 7e 20 00	 cmp	 DWORD PTR [esi+32], 0
  000dd	7c 09		 jl	 SHORT $L10434

; 1834 :         {
; 1835 :             IsochDetachData->Irp->IoStatus.Information = IsochDetachData->outputBufferLength;

  000df	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  000e2	8b 4e 78	 mov	 ecx, DWORD PTR [esi+120]
  000e5	89 48 1c	 mov	 DWORD PTR [eax+28], ecx
$L10434:

; 1836 :         }
; 1837 : 
; 1838 :         //
; 1839 :         // Complete original Irp and free the one we allocated in
; 1840 :         // IsochAttachBuffers
; 1841 :         //
; 1842 :         IoCompleteRequest(IsochDetachData->Irp, IO_NO_INCREMENT);

  000e8	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  000eb	32 d2		 xor	 dl, dl
  000ed	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@IofCompleteRequest@8

; 1843 :         IoFreeIrp (IsochDetachData->newIrp);

  000f3	ff 76 14	 push	 DWORD PTR [esi+20]
  000f6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoFreeIrp@4

; 1844 : 
; 1845 :         // all done with IsochDetachData, lets deallocate it...
; 1846 :         ExFreePool(IsochDetachData);

  000fc	56		 push	 esi
  000fd	ff d5		 call	 ebp
  000ff	5d		 pop	 ebp
$Exit_IsochDetachBuffers$10413:
  00100	5f		 pop	 edi
  00101	5e		 pop	 esi
  00102	5b		 pop	 ebx

; 1847 :     }
; 1848 : 
; 1849 : Exit_IsochDetachBuffers:
; 1850 : 
; 1851 :     EXIT("t1394_IsochCleanup", 0);
; 1852 : } // t1394_IsochCleanup

  00103	c2 04 00	 ret	 4
_t1394_IsochCleanup@4 ENDP
_TEXT	ENDS
PUBLIC	_DriverEntry@8
EXTRN	_t1394VDev_IoControl@8:NEAR
EXTRN	_t1394VDev_PnpAddDevice@8:NEAR
EXTRN	_t1394VDev_Pnp@8:NEAR
EXTRN	_t1394VDev_Power@8:NEAR
; Function compile flags: /Ogsy
; File d:\srv03rtm\drivers\wdm\1394\tools\test\driver\1394vdev\1394vdev.c
;	COMDAT _DriverEntry@8
_TEXT	SEGMENT
_DriverObject$ = 8					; size = 4
_RegistryPath$ = 12					; size = 4
_DriverEntry@8 PROC NEAR				; COMDAT

; 37   :     NTSTATUS    ntStatus = STATUS_SUCCESS;
; 38   : 
; 39   :     ENTER("DriverEntry");
; 40   : 
; 41   :     DriverObject->MajorFunction[IRP_MJ_CREATE]          = t1394VDev_Create;

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _DriverObject$[esp-4]

; 42   :     DriverObject->MajorFunction[IRP_MJ_CLOSE]           = t1394VDev_Close;
; 43   :     DriverObject->MajorFunction[IRP_MJ_PNP]             = t1394VDev_Pnp;
; 44   :     DriverObject->MajorFunction[IRP_MJ_POWER]           = t1394VDev_Power;
; 45   :     DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL]  = t1394VDev_IoControl;

  00004	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:_t1394VDev_IoControl@8
  00009	c7 40 38 00 00
	00 00		 mov	 DWORD PTR [eax+56], OFFSET FLAT:_t1394VDev_Create@8
  00010	c7 40 40 00 00
	00 00		 mov	 DWORD PTR [eax+64], OFFSET FLAT:_t1394VDev_Close@8
  00017	c7 80 a4 00 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+164], OFFSET FLAT:_t1394VDev_Pnp@8
  00021	c7 80 90 00 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+144], OFFSET FLAT:_t1394VDev_Power@8
  0002b	89 48 70	 mov	 DWORD PTR [eax+112], ecx

; 46   :     DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL]  = t1394VDev_IoControl;

  0002e	89 88 94 00 00
	00		 mov	 DWORD PTR [eax+148], ecx

; 47   :     DriverObject->DriverExtension->AddDevice            = t1394VDev_PnpAddDevice;

  00034	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  00037	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], OFFSET FLAT:_t1394VDev_PnpAddDevice@8

; 48   : 
; 49   :     EXIT("DriverEntry", ntStatus);
; 50   :     return(ntStatus);

  0003e	33 c0		 xor	 eax, eax

; 51   : } // DriverEntry

  00040	c2 08 00	 ret	 8
_DriverEntry@8 ENDP
_TEXT	ENDS
PUBLIC	_t1394_IsochCallback@8
; Function compile flags: /Ogsy
; File d:\srv03rtm\drivers\wdm\1394\tools\test\driver\common\isochapi.c
;	COMDAT _t1394_IsochCallback@8
_TEXT	SEGMENT
_DeviceExtension$ = 8					; size = 4
_IsochDetachData$ = 12					; size = 4
_t1394_IsochCallback@8 PROC NEAR			; COMDAT

; 1661 : {

  00000	56		 push	 esi

; 1662 :     KIRQL               Irql;
; 1663 : 
; 1664 :     ENTER("t1394_IsochCallback");
; 1665 : 
; 1666 :     if (!IsochDetachData)

  00001	8b 74 24 0c	 mov	 esi, DWORD PTR _IsochDetachData$[esp]
  00005	85 f6		 test	 esi, esi
  00007	74 5e		 je	 SHORT $Exit_IsochCallback$10388
  00009	53		 push	 ebx
  0000a	57		 push	 edi

; 1667 :     {
; 1668 :         goto Exit_IsochCallback;
; 1669 :     }
; 1670 : 
; 1671 :     // make sure somebody else isn't already handling cleaning up for this request
; 1672 :     KeAcquireSpinLock(&DeviceExtension->IsochSpinLock, &Irql);

  0000b	8b 7c 24 10	 mov	 edi, DWORD PTR _DeviceExtension$[esp+8]
  0000f	8d 5f 20	 lea	 ebx, DWORD PTR [edi+32]
  00012	8b cb		 mov	 ecx, ebx
  00014	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@KfAcquireSpinLock@4

; 1673 :     if ((!DeviceExtension->bShutdown) &&
; 1674 :     	(t1394_IsOnList(&IsochDetachData->IsochDetachList, &DeviceExtension->IsochDetachData)))

  0001a	80 7f 28 00	 cmp	 BYTE PTR [edi+40], 0
  0001e	8a d0		 mov	 dl, al
  00020	75 3b		 jne	 SHORT $L10389
  00022	83 c7 50	 add	 edi, 80			; 00000050H
  00025	57		 push	 edi
  00026	56		 push	 esi
  00027	e8 00 00 00 00	 call	 _t1394_IsOnList@8
  0002c	84 c0		 test	 al, al
  0002e	74 2d		 je	 SHORT $L10389

; 1675 :     {
; 1676 : 
; 1677 :         RemoveEntryList(&IsochDetachData->IsochDetachList);

  00030	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00033	8b 06		 mov	 eax, DWORD PTR [esi]
  00035	89 01		 mov	 DWORD PTR [ecx], eax
  00037	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 1678 : 		KeReleaseSpinLock(&DeviceExtension->IsochSpinLock, Irql);

  0003a	8b cb		 mov	 ecx, ebx
  0003c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@KfReleaseSpinLock@8

; 1679 :         KeCancelTimer(&IsochDetachData->Timer);

  00042	8d 46 28	 lea	 eax, DWORD PTR [esi+40]
  00045	50		 push	 eax
  00046	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeCancelTimer@4

; 1680 : 
; 1681 :         TRACE(TL_TRACE, ("IsochCallback: IsochDetachData = 0x%x\n", IsochDetachData));
; 1682 :         TRACE(TL_TRACE, ("IsochCallback: IsochDetachData->Irp = 0x%x\n", IsochDetachData->Irp));
; 1683 :         TRACE(TL_TRACE, ("IsochCallback: IsochDetachData->newIrp = 0x%x\n", IsochDetachData->newIrp));
; 1684 : 
; 1685 :         // need to save the status of the attach
; 1686 :         // we'll clean up in the same spot for success's and timeout's
; 1687 :         IsochDetachData->AttachStatus = IsochDetachData->Irp->IoStatus.Status;

  0004c	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0004f	8b 40 18	 mov	 eax, DWORD PTR [eax+24]

; 1688 :         t1394_IsochCleanup(IsochDetachData);

  00052	56		 push	 esi
  00053	89 46 20	 mov	 DWORD PTR [esi+32], eax
  00056	e8 00 00 00 00	 call	 _t1394_IsochCleanup@4

; 1689 :     }
; 1690 :     else

  0005b	eb 08		 jmp	 SHORT $L10908
$L10389:

; 1691 :     {
; 1692 :     	TRACE(TL_TRACE, ("IsochCallback: Entry 0x%x not on List 0x%x\n", 
; 1693 :     		IsochDetachData->IsochDetachList, DeviceExtension->IsochDetachData));
; 1694 :     	KeReleaseSpinLock(&DeviceExtension->IsochSpinLock, Irql);

  0005d	8b cb		 mov	 ecx, ebx
  0005f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@KfReleaseSpinLock@8
$L10908:
  00065	5f		 pop	 edi
  00066	5b		 pop	 ebx
$Exit_IsochCallback$10388:
  00067	5e		 pop	 esi

; 1695 :     }
; 1696 : 
; 1697 : Exit_IsochCallback:
; 1698 :     EXIT("t1394_IsochCallback", 0);
; 1699 : } // t1394_IsochCallback

  00068	c2 08 00	 ret	 8
_t1394_IsochCallback@8 ENDP
_TEXT	ENDS
PUBLIC	_t1394_IsochTimeout@16
; Function compile flags: /Ogsy
;	COMDAT _t1394_IsochTimeout@16
_TEXT	SEGMENT
_Dpc$ = 8						; size = 4
_IsochDetachData$ = 12					; size = 4
_SystemArgument1$ = 16					; size = 4
_SystemArgument2$ = 20					; size = 4
_t1394_IsochTimeout@16 PROC NEAR			; COMDAT

; 1708 : {

  00000	56		 push	 esi

; 1709 :     KIRQL               Irql;
; 1710 :     PDEVICE_EXTENSION   DeviceExtension;
; 1711 : 
; 1712 :     ENTER("t1394_IsochTimeout");
; 1713 :     TRACE(TL_WARNING, ("Isoch Timeout!\n"));
; 1714 : 
; 1715 : 	//
; 1716 : 	// ISSUE: the device extension we are referencing comes from the IsochDetachData
; 1717 : 	// but it is possible this memory has been freed before we enter this function.
; 1718 : 	// The only way to check is to validate against our DeviceExtension->IsochDetachList
; 1719 : 	// but if the IsochDetachData has been freed then that won't be accessible
; 1720 : 	//
; 1721 :     DeviceExtension = IsochDetachData->DeviceExtension;

  00001	8b 74 24 0c	 mov	 esi, DWORD PTR _IsochDetachData$[esp]
  00005	57		 push	 edi
  00006	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]

; 1722 :     if (DeviceExtension) 

  00009	85 ff		 test	 edi, edi
  0000b	74 50		 je	 SHORT $L10405
  0000d	53		 push	 ebx

; 1723 :     {
; 1724 :     	// make sure nobody else has already handled this request yet
; 1725 :         KeAcquireSpinLock(&DeviceExtension->IsochSpinLock, &Irql);

  0000e	8d 5f 20	 lea	 ebx, DWORD PTR [edi+32]
  00011	8b cb		 mov	 ecx, ebx
  00013	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@KfAcquireSpinLock@4

; 1726 : 		if (t1394_IsOnList(&IsochDetachData->IsochDetachList, &DeviceExtension->IsochDetachData))

  00019	83 c7 50	 add	 edi, 80			; 00000050H
  0001c	57		 push	 edi
  0001d	56		 push	 esi
  0001e	8a d0		 mov	 dl, al
  00020	e8 00 00 00 00	 call	 _t1394_IsOnList@8
  00025	84 c0		 test	 al, al
  00027	74 2b		 je	 SHORT $L10403

; 1727 : 		{
; 1728 :         	RemoveEntryList(&IsochDetachData->IsochDetachList);

  00029	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0002c	8b 06		 mov	 eax, DWORD PTR [esi]
  0002e	89 01		 mov	 DWORD PTR [ecx], eax
  00030	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 1729 :         	KeReleaseSpinLock(&DeviceExtension->IsochSpinLock, Irql);

  00033	8b cb		 mov	 ecx, ebx
  00035	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@KfReleaseSpinLock@8

; 1730 :         	KeCancelTimer(&IsochDetachData->Timer);

  0003b	8d 46 28	 lea	 eax, DWORD PTR [esi+40]
  0003e	50		 push	 eax
  0003f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeCancelTimer@4

; 1731 : 
; 1732 :         	TRACE(TL_TRACE, ("IsochTimeout: IsochDetachData = 0x%x\n", IsochDetachData));
; 1733 : 	        TRACE(TL_TRACE, ("IsochTimeout: IsochDetachData->Irp = 0x%x\n", IsochDetachData->Irp));
; 1734 : 	        TRACE(TL_TRACE, ("IsochTimeout: IsochDetachData->newIrp = 0x%x\n", IsochDetachData->newIrp));
; 1735 : 
; 1736 : 	        // need to save the status of the attach
; 1737 : 	        // we'll clean up in the same spot for success's and timeout's
; 1738 : 	        IsochDetachData->AttachStatus = STATUS_TIMEOUT;
; 1739 : 	        t1394_IsochCleanup(IsochDetachData);

  00045	56		 push	 esi
  00046	c7 46 20 02 01
	00 00		 mov	 DWORD PTR [esi+32], 258	; 00000102H
  0004d	e8 00 00 00 00	 call	 _t1394_IsochCleanup@4

; 1740 : 		}
; 1741 : 		else

  00052	eb 08		 jmp	 SHORT $L10918
$L10403:

; 1742 : 		{
; 1743 : 			KeReleaseSpinLock(&DeviceExtension->IsochSpinLock, Irql);

  00054	8b cb		 mov	 ecx, ebx
  00056	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@KfReleaseSpinLock@8
$L10918:
  0005c	5b		 pop	 ebx
$L10405:
  0005d	5f		 pop	 edi
  0005e	5e		 pop	 esi

; 1744 : 		}
; 1745 :     }
; 1746 : 
; 1747 :     EXIT("t1394_IsochTimeout", 0);
; 1748 : } // t1394_IsochTimeout

  0005f	c2 10 00	 ret	 16			; 00000010H
_t1394_IsochTimeout@16 ENDP
_TEXT	ENDS
PUBLIC	_t1394_IsochAttachBuffers@28
EXTRN	__imp__KeInitializeDpc@12:NEAR
EXTRN	__imp__KeInitializeTimer@4:NEAR
EXTRN	__imp__KeSetTimer@16:NEAR
; Function compile flags: /Ogsy
;	COMDAT _t1394_IsochAttachBuffers@28
_TEXT	SEGMENT
_newIrp$ = -8						; size = 4
_pIrb$ = -4						; size = 4
_i$ = 8							; size = 4
_DeviceObject$ = 8					; size = 4
_Irp$ = 12						; size = 4
_outputBufferLength$ = 16				; size = 4
_hResource$ = 20					; size = 4
_nNumberOfDescriptors$ = 24				; size = 4
_StackSize$ = 28					; size = 1
_pIsochDescriptor$ = 28					; size = 4
_pR3TempDescriptor$ = 32				; size = 4
_R3_IsochDescriptor$ = 32				; size = 4
_t1394_IsochAttachBuffers@28 PROC NEAR			; COMDAT

; 370  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx

; 371  :     NTSTATUS                    ntStatus = STATUS_SUCCESS;
; 372  :     PDEVICE_EXTENSION           deviceExtension = DeviceObject->DeviceExtension;

  00005	8b 45 08	 mov	 eax, DWORD PTR _DeviceObject$[ebp]
  00008	53		 push	 ebx
  00009	8b 58 28	 mov	 ebx, DWORD PTR [eax+40]

; 373  :     PIRB                        pIrb;
; 374  :     ULONG                       i, j;
; 375  :     PISOCH_DETACH_DATA          pIsochDetachData    = NULL;
; 376  :     PRING3_ISOCH_DESCRIPTOR     pR3TempDescriptor;
; 377  :     KIRQL                       Irql;
; 378  :     PIO_STACK_LOCATION          NextIrpStack;
; 379  :     LARGE_INTEGER               deltaTime;
; 380  : 
; 381  :     PIRP                newIrp;
; 382  :     CCHAR               StackSize;
; 383  : 
; 384  :     ENTER("t1394_IsochAttachBuffers");
; 385  : 
; 386  :     TRACE(TL_TRACE, ("outputBufferLength = 0x%x\n", outputBufferLength));
; 387  :     TRACE(TL_TRACE, ("hResource = 0x%x\n", hResource));
; 388  :     TRACE(TL_TRACE, ("nNumberOfDescriptors = 0x%x\n", nNumberOfDescriptors));
; 389  :     TRACE(TL_TRACE, ("R3_IsochDescriptor = 0x%x\n", R3_IsochDescriptor));
; 390  : 
; 391  :     //
; 392  :     // Just assume that we are being passed a Irp that was created in UserMode
; 393  :     // and allocate one here, because we need to keep an Irp around for
; 394  :     // the callback routine.  Must submit this asynchronously so use IoAllocateIrp
; 395  :     //
; 396  :     StackSize = deviceExtension->StackDeviceObject->StackSize;

  0000c	8b 03		 mov	 eax, DWORD PTR [ebx]
  0000e	8a 40 30	 mov	 al, BYTE PTR [eax+48]
  00011	56		 push	 esi
  00012	33 f6		 xor	 esi, esi
  00014	88 45 1c	 mov	 BYTE PTR _StackSize$[ebp], al

; 397  :     newIrp = IoAllocateIrp (StackSize, FALSE);

  00017	56		 push	 esi
  00018	ff 75 1c	 push	 DWORD PTR _StackSize$[ebp]
  0001b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoAllocateIrp@8

; 398  : 
; 399  :     if (!newIrp) {

  00021	3b c6		 cmp	 eax, esi
  00023	89 45 f8	 mov	 DWORD PTR _newIrp$[ebp], eax
  00026	75 0a		 jne	 SHORT $L9925

; 400  : 
; 401  :         TRACE(TL_ERROR, ("Failed to allocate newIrp!\n"));
; 402  :         ntStatus = STATUS_INSUFFICIENT_RESOURCES;

  00028	b8 9a 00 00 c0	 mov	 eax, -1073741670	; c000009aH

; 403  :         goto Exit_IsochAttachBuffers;            

  0002d	e9 9c 02 00 00	 jmp	 $Exit_IsochAttachBuffers$9927
$L9925:
  00032	57		 push	 edi

; 404  :     }
; 405  : 
; 406  :     //
; 407  :     // allocate the irb
; 408  :     //
; 409  :     pIrb = ExAllocatePool(NonPagedPool, sizeof(IRB));

  00033	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__ExAllocatePoolWithTag@12
  00039	68 57 64 6d 20	 push	 544040023		; 206d6457H
  0003e	68 58 01 00 00	 push	 344			; 00000158H
  00043	56		 push	 esi
  00044	ff d7		 call	 edi

; 410  : 
; 411  :     if (!pIrb) {

  00046	85 c0		 test	 eax, eax
  00048	89 45 fc	 mov	 DWORD PTR _pIrb$[ebp], eax
  0004b	75 0a		 jne	 SHORT $L9929
$L10939:

; 412  : 
; 413  :         TRACE(TL_ERROR, ("Failed to allocate pIrb!\n"));
; 414  :         ntStatus = STATUS_INSUFFICIENT_RESOURCES;

  0004d	b8 9a 00 00 c0	 mov	 eax, -1073741670	; c000009aH

; 415  :         goto Exit_IsochAttachBuffers;

  00052	e9 76 02 00 00	 jmp	 $L10938
$L9929:

; 416  :     } // if
; 417  : 
; 418  :     //
; 419  :     // allocate our isoch descriptors
; 420  :     //
; 421  :     pIsochDescriptor = ExAllocatePool(NonPagedPool, sizeof(ISOCH_DESCRIPTOR)*nNumberOfDescriptors);

  00057	8b 45 18	 mov	 eax, DWORD PTR _nNumberOfDescriptors$[ebp]
  0005a	69 c0 ac 00 00
	00		 imul	 eax, 172		; 000000acH
  00060	68 57 64 6d 20	 push	 544040023		; 206d6457H
  00065	50		 push	 eax
  00066	6a 00		 push	 0
  00068	ff d7		 call	 edi
  0006a	8b d0		 mov	 edx, eax

; 422  : 
; 423  :     if (!pIsochDescriptor) {

  0006c	85 d2		 test	 edx, edx
  0006e	89 55 1c	 mov	 DWORD PTR _pIsochDescriptor$[ebp], edx
  00071	75 08		 jne	 SHORT $L9932

; 424  : 
; 425  :         TRACE(TL_ERROR, ("Failed to allocate pIsochDescriptor!\n"));
; 426  :         if (pIrb)
; 427  :             ExFreePool(pIrb);

  00073	ff 75 fc	 push	 DWORD PTR _pIrb$[ebp]

; 428  : 
; 429  :         ntStatus = STATUS_INSUFFICIENT_RESOURCES;
; 430  :         goto Exit_IsochAttachBuffers;

  00076	e9 e1 01 00 00	 jmp	 $L10940
$L9932:

; 431  :     }
; 432  : 
; 433  :     pR3TempDescriptor = R3_IsochDescriptor;

  0007b	8b 45 20	 mov	 eax, DWORD PTR _R3_IsochDescriptor$[ebp]

; 434  :     for (i=0;i < nNumberOfDescriptors; i++) {

  0007e	83 65 08 00	 and	 DWORD PTR _i$[ebp], 0
  00082	83 7d 18 00	 cmp	 DWORD PTR _nNumberOfDescriptors$[ebp], 0
  00086	89 45 20	 mov	 DWORD PTR _pR3TempDescriptor$[ebp], eax
  00089	0f 86 5d 01 00
	00		 jbe	 $L9937

; 431  :     }
; 432  : 
; 433  :     pR3TempDescriptor = R3_IsochDescriptor;

  0008f	8d 7a 04	 lea	 edi, DWORD PTR [edx+4]
  00092	eb 03		 jmp	 SHORT $L9935
$L10935:
  00094	8b 45 20	 mov	 eax, DWORD PTR _pR3TempDescriptor$[ebp]
$L9935:

; 435  : 
; 436  :         TRACE(TL_TRACE, ("pR3TempDescriptor = 0x%x\n", pR3TempDescriptor));
; 437  :         TRACE(TL_TRACE, ("pR3TempDescriptor->fulFlags = 0x%x\n", pR3TempDescriptor->fulFlags));
; 438  :         TRACE(TL_TRACE, ("pR3TempDescriptor->ulLength = 0x%x\n", pR3TempDescriptor->ulLength));
; 439  :         TRACE(TL_TRACE, ("pR3TempDescriptor->nMaxBytesPerFrame = 0x%x\n", pR3TempDescriptor->nMaxBytesPerFrame));
; 440  :         TRACE(TL_TRACE, ("pR3TempDescriptor->ulSynch = 0x%x\n", pR3TempDescriptor->ulSynch));
; 441  :         TRACE(TL_TRACE, ("pR3TempDescriptor->ulTag = 0x%x\n", pR3TempDescriptor->ulTag));
; 442  :         TRACE(TL_TRACE, ("pR3TempDescriptor->CycleTime.CL_CycleOffset = 0x%x\n", pR3TempDescriptor->CycleTime.CL_CycleOffset));
; 443  :         TRACE(TL_TRACE, ("pR3TempDescriptor->CycleTime.CL_CycleCount = 0x%x\n", pR3TempDescriptor->CycleTime.CL_CycleCount));
; 444  :         TRACE(TL_TRACE, ("pR3TempDescriptor->CycleTime.CL_SecondCount = 0x%x\n", pR3TempDescriptor->CycleTime.CL_SecondCount));
; 445  :         TRACE(TL_TRACE, ("pR3TempDescriptor->Data = 0x%x\n", &pR3TempDescriptor->Data));
; 446  : 
; 447  :         TRACE(TL_TRACE, ("pIsochDescriptor[%x] = 0x%x\n", i, &pIsochDescriptor[i]));
; 448  : 
; 449  :         // if we have a ulLength, create the Mdl. if not, Mdl=NULL
; 450  :         if (pR3TempDescriptor->ulLength) {

  00097	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0009a	33 c9		 xor	 ecx, ecx
  0009c	3b d1		 cmp	 edx, ecx
  0009e	74 2e		 je	 SHORT $L9938

; 451  : 
; 452  :             pIsochDescriptor[i].Mdl = IoAllocateMdl (pR3TempDescriptor->Data,
; 453  :                                                      pR3TempDescriptor->ulLength,
; 454  :                                                      FALSE,
; 455  :                                                      FALSE,
; 456  :                                                      NULL);

  000a0	51		 push	 ecx
  000a1	51		 push	 ecx
  000a2	51		 push	 ecx
  000a3	52		 push	 edx
  000a4	83 c0 20	 add	 eax, 32			; 00000020H
  000a7	50		 push	 eax
  000a8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoAllocateMdl@20

; 457  : 
; 458  :             
; 459  : 			if (!pIsochDescriptor[i].Mdl)

  000ae	85 c0		 test	 eax, eax
  000b0	89 07		 mov	 DWORD PTR [edi], eax
  000b2	0f 84 44 01 00
	00		 je	 $L10930

; 474  : 			}
; 475  : 			
; 476  : 			MmBuildMdlForNonPagedPool(pIsochDescriptor[i].Mdl);

  000b8	50		 push	 eax
  000b9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MmBuildMdlForNonPagedPool@4

; 477  :             pIsochDescriptor[i].ulLength = MmGetMdlByteCount(pIsochDescriptor[i].Mdl);

  000bf	8b 07		 mov	 eax, DWORD PTR [edi]
  000c1	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  000c4	89 47 04	 mov	 DWORD PTR [edi+4], eax

; 478  :         }
; 479  :         else {

  000c7	8b 45 20	 mov	 eax, DWORD PTR _pR3TempDescriptor$[ebp]
  000ca	33 c9		 xor	 ecx, ecx
  000cc	eb 08		 jmp	 SHORT $L9946
$L9938:

; 480  : 
; 481  :             pIsochDescriptor[i].Mdl = NULL;

  000ce	89 0f		 mov	 DWORD PTR [edi], ecx

; 482  :             pIsochDescriptor[i].ulLength = pR3TempDescriptor->ulLength;

  000d0	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000d3	89 57 04	 mov	 DWORD PTR [edi+4], edx
$L9946:

; 483  :         }
; 484  : 
; 485  :         pIsochDescriptor[i].fulFlags = pR3TempDescriptor->fulFlags;

  000d6	8b 10		 mov	 edx, DWORD PTR [eax]
  000d8	89 57 fc	 mov	 DWORD PTR [edi-4], edx

; 486  :         pIsochDescriptor[i].nMaxBytesPerFrame = pR3TempDescriptor->nMaxBytesPerFrame;

  000db	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  000de	89 57 08	 mov	 DWORD PTR [edi+8], edx

; 487  :         pIsochDescriptor[i].ulSynch = pR3TempDescriptor->ulSynch;

  000e1	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  000e4	89 57 0c	 mov	 DWORD PTR [edi+12], edx

; 488  :         pIsochDescriptor[i].ulTag = pR3TempDescriptor->ulTag;

  000e7	8b 50 10	 mov	 edx, DWORD PTR [eax+16]
  000ea	89 57 10	 mov	 DWORD PTR [edi+16], edx

; 489  :         pIsochDescriptor[i].CycleTime = pR3TempDescriptor->CycleTime;

  000ed	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  000f0	89 57 14	 mov	 DWORD PTR [edi+20], edx

; 490  : 
; 491  :         if (pR3TempDescriptor->bUseCallback) {

  000f3	39 48 18	 cmp	 DWORD PTR [eax+24], ecx
  000f6	0f 84 cb 00 00
	00		 je	 $L9948

; 492  : 
; 493  :             //
; 494  :             // i'm hoping this is the last descriptor. they should have only set this in the
; 495  :             // last descriptor, since elsewhere it's not supported.
; 496  :             //
; 497  :             if (i != nNumberOfDescriptors-1) {

  000fc	8b 4d 18	 mov	 ecx, DWORD PTR _nNumberOfDescriptors$[ebp]
  000ff	49		 dec	 ecx
  00100	39 4d 08	 cmp	 DWORD PTR _i$[ebp], ecx
  00103	74 09		 je	 SHORT $L9949

; 498  : 
; 499  :                 TRACE(TL_TRACE, ("Callback on descriptor prior to last!\n"));
; 500  : 
; 501  :                 // setting callback to NULL
; 502  :                 pIsochDescriptor[i].Callback = NULL;

  00105	83 67 18 00	 and	 DWORD PTR [edi+24], 0

; 503  :             }
; 504  :             else {

  00109	e9 bc 00 00 00	 jmp	 $L9960
$L9949:

; 505  : 
; 506  :                 // need to save hResource, numDescriptors and Irp to use when detaching.
; 507  :                 // this needs to be done before we submit the irp, since the isoch callback
; 508  :                 // can be called before the submitirpsynch call completes.
; 509  :                 pIsochDetachData = ExAllocatePool(NonPagedPool, sizeof(ISOCH_DETACH_DATA));

  0010e	68 57 64 6d 20	 push	 544040023		; 206d6457H
  00113	68 80 00 00 00	 push	 128			; 00000080H
  00118	6a 00		 push	 0
  0011a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExAllocatePoolWithTag@12
  00120	8b f0		 mov	 esi, eax

; 510  : 
; 511  :                 if (!pIsochDetachData)

  00122	85 f6		 test	 esi, esi
  00124	0f 84 0a 01 00
	00		 je	 $L10931

; 525  :                 }
; 526  : 
; 527  :                 pIsochDetachData->AttachIrb = pIrb;

  0012a	8b 45 fc	 mov	 eax, DWORD PTR _pIrb$[ebp]

; 528  : 
; 529  : 				KeAcquireSpinLock(&deviceExtension->IsochSpinLock, &Irql);

  0012d	8d 4b 20	 lea	 ecx, DWORD PTR [ebx+32]
  00130	89 46 1c	 mov	 DWORD PTR [esi+28], eax
  00133	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@KfAcquireSpinLock@4

; 530  :                 InsertHeadList(&deviceExtension->IsochDetachData, &pIsochDetachData->IsochDetachList);

  00139	8d 4b 50	 lea	 ecx, DWORD PTR [ebx+80]
  0013c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0013e	89 16		 mov	 DWORD PTR [esi], edx
  00140	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
  00143	89 72 04	 mov	 DWORD PTR [edx+4], esi
  00146	89 31		 mov	 DWORD PTR [ecx], esi

; 531  : 				KeReleaseSpinLock(&deviceExtension->IsochSpinLock, Irql);

  00148	8a d0		 mov	 dl, al
  0014a	8d 4b 20	 lea	 ecx, DWORD PTR [ebx+32]
  0014d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@KfReleaseSpinLock@8

; 532  : 
; 533  :                 KeInitializeTimer(&pIsochDetachData->Timer);

  00153	8d 46 28	 lea	 eax, DWORD PTR [esi+40]
  00156	50		 push	 eax
  00157	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeInitializeTimer@4

; 534  :                 KeInitializeDpc(&pIsochDetachData->TimerDpc, t1394_IsochTimeout, pIsochDetachData);

  0015d	56		 push	 esi
  0015e	8d 46 50	 lea	 eax, DWORD PTR [esi+80]
  00161	68 00 00 00 00	 push	 OFFSET FLAT:_t1394_IsochTimeout@16
  00166	50		 push	 eax
  00167	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeInitializeDpc@12

; 535  : 
; 536  :                 deltaTime.LowPart = ISOCH_DETACH_TIMEOUT_VALUE;
; 537  :                 deltaTime.HighPart = -1;
; 538  :                 KeSetTimer(&pIsochDetachData->Timer, deltaTime, &pIsochDetachData->TimerDpc);

  0016d	8d 46 50	 lea	 eax, DWORD PTR [esi+80]
  00170	50		 push	 eax
  00171	83 ca ff	 or	 edx, -1
  00174	52		 push	 edx
  00175	b9 00 1f 0a fa	 mov	 ecx, -100000000		; fa0a1f00H
  0017a	51		 push	 ecx
  0017b	8d 46 28	 lea	 eax, DWORD PTR [esi+40]
  0017e	50		 push	 eax
  0017f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeSetTimer@16

; 539  : 
; 540  :                 pIsochDetachData->outputBufferLength = outputBufferLength;

  00185	8b 45 10	 mov	 eax, DWORD PTR _outputBufferLength$[ebp]
  00188	89 46 78	 mov	 DWORD PTR [esi+120], eax

; 541  :                 pIsochDetachData->DeviceExtension = deviceExtension;
; 542  :                 pIsochDetachData->hResource = hResource;

  0018b	8b 45 14	 mov	 eax, DWORD PTR _hResource$[ebp]
  0018e	89 46 70	 mov	 DWORD PTR [esi+112], eax

; 543  :                 pIsochDetachData->numIsochDescriptors = nNumberOfDescriptors;

  00191	8b 45 18	 mov	 eax, DWORD PTR _nNumberOfDescriptors$[ebp]
  00194	89 46 74	 mov	 DWORD PTR [esi+116], eax

; 544  :                 pIsochDetachData->IsochDescriptor = pIsochDescriptor;

  00197	8b 45 1c	 mov	 eax, DWORD PTR _pIsochDescriptor$[ebp]
  0019a	89 46 0c	 mov	 DWORD PTR [esi+12], eax

; 545  :                 pIsochDetachData->Irp = Irp;

  0019d	8b 45 0c	 mov	 eax, DWORD PTR _Irp$[ebp]
  001a0	89 46 10	 mov	 DWORD PTR [esi+16], eax

; 546  :                 pIsochDetachData->newIrp = newIrp;

  001a3	8b 45 f8	 mov	 eax, DWORD PTR _newIrp$[ebp]
  001a6	89 46 14	 mov	 DWORD PTR [esi+20], eax

; 547  :                 pIsochDetachData->bDetach = pR3TempDescriptor->bAutoDetach;

  001a9	8b 45 20	 mov	 eax, DWORD PTR _pR3TempDescriptor$[ebp]
  001ac	89 5e 08	 mov	 DWORD PTR [esi+8], ebx
  001af	8b 40 1c	 mov	 eax, DWORD PTR [eax+28]
  001b2	89 46 7c	 mov	 DWORD PTR [esi+124], eax

; 548  : 
; 549  :                 pIsochDescriptor[i].Callback = t1394_IsochCallback;
; 550  : 
; 551  :                 pIsochDescriptor[i].Context1 = deviceExtension;
; 552  :                 pIsochDescriptor[i].Context2 = pIsochDetachData;
; 553  : 
; 554  :                 TRACE(TL_TRACE, ("IsochAttachBuffers: pIsochDetachData = 0x%x\n", pIsochDetachData));
; 555  :                 TRACE(TL_TRACE, ("IsochAttachBuffers: pIsochDetachData->Irp = 0x%x\n", pIsochDetachData->Irp));
; 556  :             }
; 557  :         }
; 558  :         else {

  001b5	8b 45 20	 mov	 eax, DWORD PTR _pR3TempDescriptor$[ebp]
  001b8	c7 47 18 00 00
	00 00		 mov	 DWORD PTR [edi+24], OFFSET FLAT:_t1394_IsochCallback@8
  001bf	89 5f 1c	 mov	 DWORD PTR [edi+28], ebx
  001c2	89 77 20	 mov	 DWORD PTR [edi+32], esi
  001c5	eb 03		 jmp	 SHORT $L9960
$L9948:

; 559  : 
; 560  :             pIsochDescriptor[i].Callback = NULL;

  001c7	89 4f 18	 mov	 DWORD PTR [edi+24], ecx
$L9960:

; 561  :         }
; 562  : 
; 563  :         TRACE(TL_TRACE, ("pIsochDescriptor[%x].fulFlags = 0x%x\n", i, pIsochDescriptor[i].fulFlags));
; 564  :         TRACE(TL_TRACE, ("pIsochDescriptor[%x].ulLength = 0x%x\n", i, pIsochDescriptor[i].ulLength));
; 565  :         TRACE(TL_TRACE, ("pIsochDescriptor[%x].nMaxBytesPerFrame = 0x%x\n", i, pIsochDescriptor[i].nMaxBytesPerFrame));
; 566  :         TRACE(TL_TRACE, ("pIsochDescriptor[%x].ulSynch = 0x%x\n", i, pIsochDescriptor[i].ulSynch));
; 567  :         TRACE(TL_TRACE, ("pIsochDescriptor[%x].ulTag = 0x%x\n", i, pIsochDescriptor[i].ulTag));
; 568  :         TRACE(TL_TRACE, ("pIsochDescriptor[%x].CycleTime.CL_CycleOffset = 0x%x\n", i, pIsochDescriptor[i].CycleTime.CL_CycleOffset));
; 569  :         TRACE(TL_TRACE, ("pIsochDescriptor[%x].CycleTime.CL_CycleCount = 0x%x\n", i, pIsochDescriptor[i].CycleTime.CL_CycleCount));
; 570  :         TRACE(TL_TRACE, ("pIsochDescriptor[%x].CycleTime.CL_SecondCount = 0x%x\n", i, pIsochDescriptor[i].CycleTime.CL_SecondCount));
; 571  : 
; 572  :         pR3TempDescriptor =
; 573  :            (PRING3_ISOCH_DESCRIPTOR)((ULONG_PTR)pR3TempDescriptor +
; 574  :                                      pIsochDescriptor[i].ulLength +
; 575  :                                      sizeof(RING3_ISOCH_DESCRIPTOR));

  001ca	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  001cd	ff 45 08	 inc	 DWORD PTR _i$[ebp]
  001d0	8d 44 08 24	 lea	 eax, DWORD PTR [eax+ecx+36]
  001d4	89 45 20	 mov	 DWORD PTR _pR3TempDescriptor$[ebp], eax
  001d7	8b 45 08	 mov	 eax, DWORD PTR _i$[ebp]
  001da	81 c7 ac 00 00
	00		 add	 edi, 172		; 000000acH
  001e0	3b 45 18	 cmp	 eax, DWORD PTR _nNumberOfDescriptors$[ebp]
  001e3	0f 82 ab fe ff
	ff		 jb	 $L10935

; 510  : 
; 511  :                 if (!pIsochDetachData)

  001e9	8b 55 1c	 mov	 edx, DWORD PTR _pIsochDescriptor$[ebp]
$L9937:

; 576  :     } // for
; 577  : 
; 578  :     // lets make sure the device is still around
; 579  :     // if it isn't, we free the irb and return, our pnp
; 580  :     // cleanup will take care of everything else
; 581  :     if (deviceExtension->bShutdown) {

  001ec	80 7b 28 00	 cmp	 BYTE PTR [ebx+40], 0
  001f0	74 75		 je	 SHORT $L9965

; 582  : 
; 583  :         TRACE(TL_TRACE, ("Shutdown!\n"));
; 584  :         ntStatus = STATUS_NO_SUCH_DEVICE;

  001f2	b8 0e 00 00 c0	 mov	 eax, -1073741810	; c000000eH

; 585  :         goto Exit_IsochAttachBuffers;

  001f7	e9 d1 00 00 00	 jmp	 $L10938
$L10930:

; 460  : 			{
; 461  : 				// we failed to alloc our mdl for this descriptor, free the previosly alloc'd mdls, and exit
; 462  : 				TRACE(TL_WARNING, ("Failed to allocate MDL for isoch descriptor num = 0x%x\n", i));
; 463  : 			
; 464  : 				for (j = 0; j < i; j++)

  001fc	8b 7d 08	 mov	 edi, DWORD PTR _i$[ebp]
  001ff	85 ff		 test	 edi, edi
  00201	76 1e		 jbe	 SHORT $L9943
  00203	8b 45 1c	 mov	 eax, DWORD PTR _pIsochDescriptor$[ebp]
  00206	83 c0 04	 add	 eax, 4
  00209	8b f0		 mov	 esi, eax
$L10936:

; 465  : 				{
; 466  : 					if (pIsochDescriptor[j].Mdl)

  0020b	8b 06		 mov	 eax, DWORD PTR [esi]
  0020d	85 c0		 test	 eax, eax
  0020f	74 07		 je	 SHORT $L9942

; 467  : 					{
; 468  : 						IoFreeMdl (pIsochDescriptor[j].Mdl);

  00211	50		 push	 eax
  00212	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoFreeMdl@4
$L9942:
  00218	81 c6 ac 00 00
	00		 add	 esi, 172		; 000000acH
  0021e	4f		 dec	 edi
  0021f	75 ea		 jne	 SHORT $L10936
$L9943:

; 469  : 					}
; 470  : 				}
; 471  : 				ExFreePool(pIsochDescriptor);

  00221	ff 75 1c	 push	 DWORD PTR _pIsochDescriptor$[ebp]
  00224	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePool@4

; 472  : 				ntStatus = STATUS_INVALID_PARAMETER;

  0022a	b8 0d 00 00 c0	 mov	 eax, -1073741811	; c000000dH

; 473  : 				goto Exit_IsochAttachBuffers;

  0022f	e9 99 00 00 00	 jmp	 $L10938
$L10931:

; 512  :                 {
; 513  : 					for (j = 0; j < i; j++)

  00234	8b 7d 08	 mov	 edi, DWORD PTR _i$[ebp]
  00237	85 ff		 test	 edi, edi
  00239	76 1e		 jbe	 SHORT $L9956
  0023b	8b 45 1c	 mov	 eax, DWORD PTR _pIsochDescriptor$[ebp]
  0023e	83 c0 04	 add	 eax, 4
  00241	8b f0		 mov	 esi, eax
$L10937:

; 514  : 					{
; 515  : 						if (pIsochDescriptor[j].Mdl)

  00243	8b 06		 mov	 eax, DWORD PTR [esi]
  00245	85 c0		 test	 eax, eax
  00247	74 07		 je	 SHORT $L9955

; 516  : 						{
; 517  : 							IoFreeMdl (pIsochDescriptor[j].Mdl);

  00249	50		 push	 eax
  0024a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoFreeMdl@4
$L9955:
  00250	81 c6 ac 00 00
	00		 add	 esi, 172		; 000000acH
  00256	4f		 dec	 edi
  00257	75 ea		 jne	 SHORT $L10937
$L9956:

; 518  : 						}
; 519  : 					}
; 520  : 
; 521  :                     TRACE(TL_ERROR, ("Failed to allocate pIsochDetachData!\n"));
; 522  :                     ExFreePool(pIsochDescriptor);

  00259	ff 75 1c	 push	 DWORD PTR _pIsochDescriptor$[ebp]
$L10940:
  0025c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePool@4

; 523  :                     ntStatus = STATUS_INSUFFICIENT_RESOURCES;                    
; 524  :                     goto Exit_IsochAttachBuffers;

  00262	e9 e6 fd ff ff	 jmp	 $L10939
$L9965:

; 586  :     }
; 587  : 
; 588  :     RtlZeroMemory (pIrb, sizeof (IRB));

  00267	8b 7d fc	 mov	 edi, DWORD PTR _pIrb$[ebp]
  0026a	33 c0		 xor	 eax, eax
  0026c	6a 56		 push	 86			; 00000056H
  0026e	59		 pop	 ecx
  0026f	f3 ab		 rep stosd

; 589  :     pIrb->FunctionNumber = REQUEST_ISOCH_ATTACH_BUFFERS;

  00271	8b 4d fc	 mov	 ecx, DWORD PTR _pIrb$[ebp]

; 590  :     pIrb->Flags = 0;

  00274	21 41 04	 and	 DWORD PTR [ecx+4], eax

; 591  :     pIrb->u.IsochAttachBuffers.hResource = hResource;

  00277	8b 45 14	 mov	 eax, DWORD PTR _hResource$[ebp]
  0027a	89 41 48	 mov	 DWORD PTR [ecx+72], eax

; 592  :     pIrb->u.IsochAttachBuffers.nNumberOfDescriptors = nNumberOfDescriptors;

  0027d	8b 45 18	 mov	 eax, DWORD PTR _nNumberOfDescriptors$[ebp]
  00280	89 41 4c	 mov	 DWORD PTR [ecx+76], eax

; 593  :     pIrb->u.IsochAttachBuffers.pIsochDescriptor = pIsochDescriptor;
; 594  : 
; 595  :     // mark our original irp pending
; 596  :     IoMarkIrpPending(Irp);

  00283	8b 45 0c	 mov	 eax, DWORD PTR _Irp$[ebp]
  00286	89 51 50	 mov	 DWORD PTR [ecx+80], edx

; 597  :     
; 598  :     //
; 599  :     // Submit the newIrp directly to the driver below us
; 600  :     //
; 601  :     NextIrpStack = IoGetNextIrpStackLocation(newIrp);

  00289	8b 55 f8	 mov	 edx, DWORD PTR _newIrp$[ebp]
  0028c	c7 01 06 00 00
	00		 mov	 DWORD PTR [ecx], 6
  00292	8b 40 60	 mov	 eax, DWORD PTR [eax+96]
  00295	80 48 03 01	 or	 BYTE PTR [eax+3], 1
  00299	8b 42 60	 mov	 eax, DWORD PTR [edx+96]
  0029c	83 e8 24	 sub	 eax, 36			; 00000024H

; 602  :     NextIrpStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;

  0029f	c6 00 0f	 mov	 BYTE PTR [eax], 15	; 0000000fH

; 603  :     NextIrpStack->Parameters.DeviceIoControl.IoControlCode = IOCTL_1394_CLASS;

  002a2	c7 40 0c 1d 02
	22 00		 mov	 DWORD PTR [eax+12], 2228765 ; 0022021dH

; 604  :     NextIrpStack->Parameters.Others.Argument1 = pIrb; 

  002a9	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 605  : 
; 606  :     IoSetCompletionRoutine( newIrp,
; 607  :                             t1394_IsochAttachCompletionRoutine,
; 608  :                             pIsochDetachData,
; 609  :                             TRUE,
; 610  :                             TRUE,
; 611  :                             TRUE
; 612  :                             );

  002ac	8b 42 60	 mov	 eax, DWORD PTR [edx+96]
  002af	83 e8 24	 sub	 eax, 36			; 00000024H
  002b2	c7 40 1c 00 00
	00 00		 mov	 DWORD PTR [eax+28], OFFSET FLAT:_t1394_IsochAttachCompletionRoutine@12
  002b9	89 70 20	 mov	 DWORD PTR [eax+32], esi
  002bc	c6 40 03 e0	 mov	 BYTE PTR [eax+3], 224	; 000000e0H

; 613  : 
; 614  :     IoCallDriver(deviceExtension->StackDeviceObject, newIrp);

  002c0	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  002c2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@IofCallDriver@8

; 615  :     ntStatus = STATUS_PENDING;

  002c8	b8 03 01 00 00	 mov	 eax, 259		; 00000103H
$L10938:
  002cd	5f		 pop	 edi
$Exit_IsochAttachBuffers$9927:
  002ce	5e		 pop	 esi
  002cf	5b		 pop	 ebx

; 616  :     
; 617  : Exit_IsochAttachBuffers:
; 618  : 
; 619  :     EXIT("t1394_IsochAttachBuffers", ntStatus);
; 620  :     return(ntStatus);
; 621  : } // t1394_IsochAttachBuffers

  002d0	c9		 leave
  002d1	c2 1c 00	 ret	 28			; 0000001cH
_t1394_IsochAttachBuffers@28 ENDP
_TEXT	ENDS
END

