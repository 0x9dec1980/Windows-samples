; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.2190 

	TITLE	.\power.c
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT _t1394VDev_Power@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _t1394VDev_SystemSetPowerIrpCompletion@12
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _t1394VDev_DeviceSetPowerIrpCompletion@20
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _GUID_1394VDEV
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT _GUID_1394DIAG
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT _BUS1394_CLASS_GUID
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
sxdata	SEGMENT DWORD USE32 'SXDATA'
sxdata	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBC
INCLUDELIB OLDNAMES

PUBLIC	_BUS1394_CLASS_GUID
PUBLIC	_GUID_1394DIAG
PUBLIC	_GUID_1394VDEV
;	COMDAT _BUS1394_CLASS_GUID
CONST	SEGMENT
_BUS1394_CLASS_GUID DD 06bdd1fc1H
	DW	0810fH
	DW	011d0H
	DB	0beH
	DB	0c7H
	DB	08H
	DB	00H
	DB	02bH
	DB	0e2H
	DB	09H
	DB	02fH
CONST	ENDS
;	COMDAT _GUID_1394DIAG
CONST	SEGMENT
_GUID_1394DIAG DD 0c459df55H
	DW	0db08H
	DW	011d1H
	DB	0b0H
	DB	09H
	DB	00H
	DB	0a0H
	DB	0c9H
	DB	08H
	DB	01fH
	DB	0f6H
CONST	ENDS
;	COMDAT _GUID_1394VDEV
CONST	SEGMENT
_GUID_1394VDEV DD 0737613e5H
	DW	069eaH
	DW	04b96H
	DB	09cH
	DB	02aH
	DB	0eeH
	DB	0bcH
	DB	022H
	DB	0fH
	DB	04cH
	DB	039H
CONST	ENDS
PUBLIC	_t1394VDev_DeviceSetPowerIrpCompletion@20
EXTRN	__imp__IoAllocateIrp@8:NEAR
EXTRN	_t1394_SubmitIrpSynch@12:NEAR
EXTRN	__imp_@IofCompleteRequest@8:NEAR
EXTRN	__imp__IoFreeIrp@4:NEAR
EXTRN	__imp__ExAllocatePoolWithTag@12:NEAR
EXTRN	__imp__PoSetPowerState@12:NEAR
EXTRN	__imp__ExFreePool@4:NEAR
EXTRN	__imp__PoStartNextPowerIrp@4:NEAR
; Function compile flags: /Ogsy
; File d:\srv03rtm\drivers\wdm\1394\tools\test\driver\1394vdev\power.c
;	COMDAT _t1394VDev_DeviceSetPowerIrpCompletion@20
_TEXT	SEGMENT
_sIrp$ = -4						; size = 4
_StackSize$ = 8						; size = 1
_Irp$ = 8						; size = 4
_DeviceObject$ = 8					; size = 4
_MinorFunction$ = 12					; size = 1
_state$ = 16						; size = 4
_PowerContext$ = 20					; size = 4
_IoStatus$ = 24						; size = 4
_t1394VDev_DeviceSetPowerIrpCompletion@20 PROC NEAR	; COMDAT

; 203  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 204  :     PDEVICE_EXTENSION   deviceExtension = (PDEVICE_EXTENSION) PowerContext->DeviceObject->DeviceExtension;

  00004	8b 45 14	 mov	 eax, DWORD PTR _PowerContext$[ebp]
  00007	8b 08		 mov	 ecx, DWORD PTR [eax]
  00009	56		 push	 esi
  0000a	8b 71 28	 mov	 esi, DWORD PTR [ecx+40]
  0000d	57		 push	 edi

; 205  :     PIRP                sIrp = PowerContext->SIrp;

  0000e	8b 78 04	 mov	 edi, DWORD PTR [eax+4]

; 206  :     PIRP                Irp;
; 207  :     PIRB                pIrb;
; 208  :     CCHAR               StackSize;
; 209  :     NTSTATUS            ntStatus = IoStatus->Status;
; 210  : 
; 211  :     ENTER("t1394VDev_DevicePowerIrpCompletion");
; 212  : 
; 213  :     if(!NT_SUCCESS(ntStatus))

  00011	8b 45 18	 mov	 eax, DWORD PTR _IoStatus$[ebp]
  00014	83 38 00	 cmp	 DWORD PTR [eax], 0
  00017	89 7d fc	 mov	 DWORD PTR _sIrp$[ebp], edi
  0001a	0f 8c 8c 00 00
	00		 jl	 $Exit_t1394VDev_DeviceSetPowerIrpCompletion$8802
  00020	53		 push	 ebx

; 214  :     {
; 215  :         TRACE(TL_WARNING, ("Device Power Irp failed by driver below us = 0x%x\n", ntStatus));
; 216  :         goto Exit_t1394VDev_DeviceSetPowerIrpCompletion;
; 217  :     }
; 218  : 
; 219  :     // set the new power state
; 220  :     PoSetPowerState(DeviceObject, DevicePowerState, state);

  00021	8b 5d 10	 mov	 ebx, DWORD PTR _state$[ebp]
  00024	53		 push	 ebx
  00025	6a 01		 push	 1
  00027	ff 75 08	 push	 DWORD PTR _DeviceObject$[ebp]
  0002a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PoSetPowerState@12

; 221  : 
; 222  :     // figure out how to respond to this power state change
; 223  :     if (state.DeviceState < deviceExtension->CurrentDevicePowerState)

  00030	3b 5e 2c	 cmp	 ebx, DWORD PTR [esi+44]
  00033	7d 6f		 jge	 SHORT $L8803

; 224  :     {
; 225  :         // adding power
; 226  :         // check to see if we are working again
; 227  :         if (PowerDeviceD0 == state.DeviceState)

  00035	83 fb 01	 cmp	 ebx, 1
  00038	75 6e		 jne	 SHORT $L8812

; 228  :         {
; 229  :             TRACE (TL_TRACE, ("Restarting our device\n"));
; 230  :             deviceExtension->bShutdown = FALSE;
; 231  :             
; 232  :             // update the generation count                    
; 233  :             StackSize = deviceExtension->StackDeviceObject->StackSize;

  0003a	8b 06		 mov	 eax, DWORD PTR [esi]
  0003c	c6 46 28 00	 mov	 BYTE PTR [esi+40], 0
  00040	8a 40 30	 mov	 al, BYTE PTR [eax+48]
  00043	88 45 08	 mov	 BYTE PTR _StackSize$[ebp], al

; 234  :             Irp = IoAllocateIrp(StackSize, FALSE);

  00046	6a 00		 push	 0
  00048	ff 75 08	 push	 DWORD PTR _StackSize$[ebp]
  0004b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoAllocateIrp@8

; 235  :             
; 236  :             pIrb = ExAllocatePool(NonPagedPool, sizeof(IRB));

  00051	68 57 64 6d 20	 push	 544040023		; 206d6457H
  00056	68 58 01 00 00	 push	 344			; 00000158H
  0005b	6a 00		 push	 0
  0005d	89 45 08	 mov	 DWORD PTR _Irp$[ebp], eax
  00060	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExAllocatePoolWithTag@12
  00066	8b d8		 mov	 ebx, eax

; 237  :         
; 238  :             if (!pIrb) {

  00068	85 db		 test	 ebx, ebx

; 239  :         
; 240  :                 TRACE(TL_ERROR, ("Failed to allocate pIrb!\n"));        
; 241  :                 ntStatus = STATUS_INSUFFICIENT_RESOURCES;
; 242  :                 goto Exit_t1394VDev_DeviceSetPowerIrpCompletion;

  0006a	74 3f		 je	 SHORT $L8840

; 243  :             } // if
; 244  :         
; 245  :             RtlZeroMemory (pIrb, sizeof (IRB));

  0006c	6a 56		 push	 86			; 00000056H
  0006e	59		 pop	 ecx

; 246  :             pIrb->FunctionNumber = REQUEST_GET_GENERATION_COUNT;
; 247  :             pIrb->Flags = 0;        
; 248  :         
; 249  :             ntStatus = t1394_SubmitIrpSynch(deviceExtension->StackDeviceObject, Irp, pIrb);

  0006f	53		 push	 ebx
  00070	ff 75 08	 push	 DWORD PTR _Irp$[ebp]
  00073	33 c0		 xor	 eax, eax
  00075	8b fb		 mov	 edi, ebx
  00077	f3 ab		 rep stosd
  00079	21 43 04	 and	 DWORD PTR [ebx+4], eax
  0007c	c7 03 1a 00 00
	00		 mov	 DWORD PTR [ebx], 26	; 0000001aH
  00082	ff 36		 push	 DWORD PTR [esi]
  00084	e8 00 00 00 00	 call	 _t1394_SubmitIrpSynch@12

; 250  : 
; 251  :             if (NT_SUCCESS(ntStatus))

  00089	85 c0		 test	 eax, eax
  0008b	7c 06		 jl	 SHORT $L8810

; 252  :             {
; 253  :                 deviceExtension->GenerationCount = pIrb->u.GetGenerationCount.GenerationCount;

  0008d	8b 43 48	 mov	 eax, DWORD PTR [ebx+72]
  00090	89 46 34	 mov	 DWORD PTR [esi+52], eax
$L8810:

; 254  :                 TRACE(TL_TRACE, ("Retrieved Generation Count = 0x%x\n", deviceExtension->GenerationCount));
; 255  :             }
; 256  :             else
; 257  :             {
; 258  :                 TRACE(TL_ERROR, ("Error, could not retrieve Generation Count, 0x%x\n", ntStatus));
; 259  :             }
; 260  : 
; 261  :             IoFreeIrp(Irp);

  00093	ff 75 08	 push	 DWORD PTR _Irp$[ebp]
  00096	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoFreeIrp@4

; 262  :         }
; 263  :     }
; 264  :     else

  0009c	8b 5d 10	 mov	 ebx, DWORD PTR _state$[ebp]
  0009f	8b 7d fc	 mov	 edi, DWORD PTR _sIrp$[ebp]
  000a2	eb 04		 jmp	 SHORT $L8812
$L8803:

; 265  :     {
; 266  :         // removing power
; 267  :         deviceExtension->bShutdown = TRUE;

  000a4	c6 46 28 01	 mov	 BYTE PTR [esi+40], 1
$L8812:

; 268  :     }
; 269  :         
; 270  :     // save the current device power state
; 271  :     deviceExtension->CurrentDevicePowerState = state.DeviceState;

  000a8	89 5e 2c	 mov	 DWORD PTR [esi+44], ebx
$L8840:
  000ab	5b		 pop	 ebx
$Exit_t1394VDev_DeviceSetPowerIrpCompletion$8802:

; 272  : 
; 273  : Exit_t1394VDev_DeviceSetPowerIrpCompletion:
; 274  : 
; 275  :     // Here we copy the D-IRP status into the S-IRP
; 276  :     sIrp->IoStatus.Status = IoStatus->Status;

  000ac	8b 45 18	 mov	 eax, DWORD PTR _IoStatus$[ebp]
  000af	8b 00		 mov	 eax, DWORD PTR [eax]

; 277  : 
; 278  :     // Release the IRP
; 279  :     PoStartNextPowerIrp(sIrp);    

  000b1	57		 push	 edi
  000b2	89 47 18	 mov	 DWORD PTR [edi+24], eax
  000b5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PoStartNextPowerIrp@4

; 280  :     sIrp->IoStatus.Information = 0;

  000bb	83 67 1c 00	 and	 DWORD PTR [edi+28], 0

; 281  :     IoCompleteRequest(sIrp, IO_NO_INCREMENT);

  000bf	32 d2		 xor	 dl, dl
  000c1	8b cf		 mov	 ecx, edi
  000c3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@IofCompleteRequest@8

; 282  : 
; 283  :     // Cleanup
; 284  :     ExFreePool(PowerContext);

  000c9	ff 75 14	 push	 DWORD PTR _PowerContext$[ebp]
  000cc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePool@4
  000d2	5f		 pop	 edi
  000d3	5e		 pop	 esi

; 285  :     
; 286  :     EXIT("t1394VDev_DevicePowerIrpCompletion", ntStatus);
; 287  : }

  000d4	c9		 leave
  000d5	c2 14 00	 ret	 20			; 00000014H
_t1394VDev_DeviceSetPowerIrpCompletion@20 ENDP
_TEXT	ENDS
PUBLIC	_t1394VDev_SystemSetPowerIrpCompletion@12
EXTRN	__imp__PoRequestPowerIrp@24:NEAR
; Function compile flags: /Ogsy
;	COMDAT _t1394VDev_SystemSetPowerIrpCompletion@12
_TEXT	SEGMENT
_deviceExtension$ = -4					; size = 4
_DeviceObject$ = 8					; size = 4
_pDIrp$ = 12						; size = 4
_Irp$ = 12						; size = 4
_NotUsed$ = 16						; size = 4
_t1394VDev_SystemSetPowerIrpCompletion@12 PROC NEAR	; COMDAT

; 117  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 118  : 
; 119  :     PDEVICE_EXTENSION           deviceExtension     = DeviceObject->DeviceExtension;

  00004	8b 45 08	 mov	 eax, DWORD PTR _DeviceObject$[ebp]
  00007	8b 40 28	 mov	 eax, DWORD PTR [eax+40]
  0000a	53		 push	 ebx

; 120  :     NTSTATUS                    ntStatus            = Irp->IoStatus.Status;
; 121  :     PIO_STACK_LOCATION          stack               = IoGetCurrentIrpStackLocation(Irp);
; 122  :     POWER_STATE                 state               = stack->Parameters.Power.State;

  0000b	8b 5d 0c	 mov	 ebx, DWORD PTR _Irp$[ebp]
  0000e	89 45 fc	 mov	 DWORD PTR _deviceExtension$[ebp], eax
  00011	8b 43 60	 mov	 eax, DWORD PTR [ebx+96]
  00014	56		 push	 esi
  00015	8b 70 0c	 mov	 esi, DWORD PTR [eax+12]

; 123  :     POWER_COMPLETION_CONTEXT    *powerContext       = NULL;
; 124  :     PIRP                        pDIrp               = NULL;

  00018	33 c0		 xor	 eax, eax

; 125  : 
; 126  :     ENTER("t1394VDev_SystemPowerIrpCompletion");
; 127  : 
; 128  :     if (!NT_SUCCESS(ntStatus)) {

  0001a	39 43 18	 cmp	 DWORD PTR [ebx+24], eax
  0001d	57		 push	 edi
  0001e	89 45 0c	 mov	 DWORD PTR _pDIrp$[ebp], eax
  00021	7d 15		 jge	 SHORT $L8767

; 129  : 
; 130  :         TRACE(TL_TRACE, ("Set System Power Irp failed, status = 0x%x\n", ntStatus));
; 131  :         PoStartNextPowerIrp(Irp);

  00023	53		 push	 ebx
  00024	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PoStartNextPowerIrp@4
$L8778:

; 185  :     {
; 186  :         ntStatus = STATUS_MORE_PROCESSING_REQUIRED;

  0002a	be 16 00 00 c0	 mov	 esi, -1073741802	; c0000016H
$L8780:
  0002f	5f		 pop	 edi

; 187  :     }
; 188  : 
; 189  :     EXIT("t1394VDev_SystemPowerIrpCompletion", ntStatus);    
; 190  :     return ntStatus;

  00030	8b c6		 mov	 eax, esi
  00032	5e		 pop	 esi
  00033	5b		 pop	 ebx

; 191  : }

  00034	c9		 leave
  00035	c2 0c 00	 ret	 12			; 0000000cH
$L8767:

; 132  :         ntStatus = STATUS_SUCCESS;
; 133  :         goto Exit_SystemSetPowerIrpCompletion;
; 134  :     }
; 135  : 
; 136  :     // allocate powerContext
; 137  :     powerContext = (POWER_COMPLETION_CONTEXT*)
; 138  :                 ExAllocatePool(NonPagedPool, sizeof(POWER_COMPLETION_CONTEXT));

  00038	68 57 64 6d 20	 push	 544040023		; 206d6457H
  0003d	6a 08		 push	 8
  0003f	50		 push	 eax
  00040	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExAllocatePoolWithTag@12
  00046	8b f8		 mov	 edi, eax

; 139  : 
; 140  :     if (!powerContext) {

  00048	85 ff		 test	 edi, edi
  0004a	75 07		 jne	 SHORT $L8772

; 141  : 
; 142  :         TRACE(TL_TRACE, ("Failed to allocate powerContext, status = 0x%x\n", ntStatus));
; 143  :         ntStatus = STATUS_INSUFFICIENT_RESOURCES;

  0004c	be 9a 00 00 c0	 mov	 esi, -1073741670	; c000009aH

; 144  :         goto Exit_SystemSetPowerIrpCompletion;

  00051	eb 2f		 jmp	 SHORT $L8843
$L8772:

; 145  : 
; 146  :     } else {
; 147  : 
; 148  :         if (state.SystemState == PowerSystemWorking) {
; 149  : 
; 150  :             state.DeviceState = PowerDeviceD0;
; 151  :         }
; 152  :         else {
; 153  :                     
; 154  :             state.DeviceState = PowerDeviceD3;
; 155  :         }
; 156  :         
; 157  :         powerContext->DeviceObject = DeviceObject;

  00053	8b 45 08	 mov	 eax, DWORD PTR _DeviceObject$[ebp]
  00056	4e		 dec	 esi
  00057	89 07		 mov	 DWORD PTR [edi], eax
  00059	f7 de		 neg	 esi

; 158  :         powerContext->SIrp = Irp;
; 159  :         
; 160  :         ntStatus = PoRequestPowerIrp(deviceExtension->StackDeviceObject,
; 161  :                                     IRP_MN_SET_POWER,
; 162  :                                     state,
; 163  :                                     t1394VDev_DeviceSetPowerIrpCompletion,
; 164  :                                     powerContext,
; 165  :                                     &pDIrp);

  0005b	8d 45 0c	 lea	 eax, DWORD PTR _pDIrp$[ebp]
  0005e	50		 push	 eax
  0005f	8b 45 fc	 mov	 eax, DWORD PTR _deviceExtension$[ebp]
  00062	1b f6		 sbb	 esi, esi
  00064	57		 push	 edi
  00065	83 e6 03	 and	 esi, 3
  00068	68 00 00 00 00	 push	 OFFSET FLAT:_t1394VDev_DeviceSetPowerIrpCompletion@20
  0006d	46		 inc	 esi
  0006e	56		 push	 esi
  0006f	6a 02		 push	 2
  00071	89 5f 04	 mov	 DWORD PTR [edi+4], ebx
  00074	ff 30		 push	 DWORD PTR [eax]
  00076	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PoRequestPowerIrp@24
  0007c	8b f0		 mov	 esi, eax

; 166  :         
; 167  :         TRACE(TL_TRACE, ("New Device Set Power Irp = 0x%x\n", pDIrp));
; 168  :     }
; 169  : 
; 170  : Exit_SystemSetPowerIrpCompletion:
; 171  : 
; 172  :     if (!NT_SUCCESS(ntStatus)) {

  0007e	85 f6		 test	 esi, esi
$Exit_SystemSetPowerIrpCompletion$8769:
  00080	7d a8		 jge	 SHORT $L8778
$L8843:

; 173  : 
; 174  : 
; 175  :         TRACE(TL_TRACE, ("System SetPowerIrp Completion routine failed = 0x%x\n", ntStatus));
; 176  : 
; 177  :         if (powerContext) {

  00082	85 ff		 test	 edi, edi
  00084	74 07		 je	 SHORT $L8779

; 178  :             ExFreePool(powerContext);

  00086	57		 push	 edi
  00087	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePool@4
$L8779:

; 179  :         }
; 180  : 
; 181  :         PoStartNextPowerIrp(Irp);

  0008d	53		 push	 ebx
  0008e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PoStartNextPowerIrp@4

; 182  :         Irp->IoStatus.Status = ntStatus;

  00094	89 73 18	 mov	 DWORD PTR [ebx+24], esi

; 183  :     }
; 184  :     else

  00097	eb 96		 jmp	 SHORT $L8780
_t1394VDev_SystemSetPowerIrpCompletion@12 ENDP
_TEXT	ENDS
PUBLIC	_t1394VDev_Power@8
EXTRN	__imp__PoCallDriver@8:NEAR
; Function compile flags: /Ogsy
;	COMDAT _t1394VDev_Power@8
_TEXT	SEGMENT
_deviceExtension$ = 8					; size = 4
_DeviceObject$ = 8					; size = 4
_Irp$ = 12						; size = 4
_t1394VDev_Power@8 PROC NEAR				; COMDAT

; 30   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 31   :     NTSTATUS                ntStatus = STATUS_SUCCESS;
; 32   :     PIO_STACK_LOCATION      IrpSp;
; 33   :     PDEVICE_EXTENSION       deviceExtension;
; 34   :     POWER_STATE             State;
; 35   :     KIRQL                   Irql;
; 36   : 
; 37   :     ENTER("t1394VDev_Power");
; 38   : 
; 39   :     deviceExtension = DeviceObject->DeviceExtension;

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _DeviceObject$[ebp]
  00006	53		 push	 ebx

; 40   : 
; 41   :     IrpSp = IoGetCurrentIrpStackLocation(Irp);

  00007	8b 5d 0c	 mov	 ebx, DWORD PTR _Irp$[ebp]
  0000a	56		 push	 esi
  0000b	8b 71 28	 mov	 esi, DWORD PTR [ecx+40]
  0000e	8b 4b 60	 mov	 ecx, DWORD PTR [ebx+96]

; 42   : 
; 43   :     State = IrpSp->Parameters.Power.State;
; 44   : 
; 45   :     TRACE(TL_TRACE, ("Power.Type = 0x%x\n", IrpSp->Parameters.Power.Type));
; 46   :     TRACE(TL_TRACE, ("Power.State.SystemState = 0x%x\n", State.SystemState));
; 47   :     TRACE(TL_TRACE, ("Power.State.DeviceState = 0x%x\n", State.DeviceState));
; 48   : 
; 49   :     switch (IrpSp->MinorFunction) {

  00011	0f b6 51 01	 movzx	 edx, BYTE PTR [ecx+1]
  00015	33 c0		 xor	 eax, eax
  00017	4a		 dec	 edx
  00018	4a		 dec	 edx
  00019	89 75 08	 mov	 DWORD PTR _deviceExtension$[ebp], esi
  0001c	74 1a		 je	 SHORT $L8724

; 79   : 
; 80   :                 default:
; 81   :                     break;
; 82   : 
; 83   :             }
; 84   :             break; // IRP_MN_SET_POWER
; 85   : 
; 86   :         case IRP_MN_QUERY_POWER:
; 87   :             TRACE(TL_TRACE, ("IRP_MN_QUERY_POWER\n"));
; 88   : 
; 89   :             PoStartNextPowerIrp(Irp);
; 90   :             IoSkipCurrentIrpStackLocation(Irp);
; 91   :             ntStatus = PoCallDriver(deviceExtension->StackDeviceObject, Irp);
; 92   : 
; 93   :             break; // IRP_MN_QUERY_POWER
; 94   : 
; 95   :         default:
; 96   :             TRACE(TL_TRACE, ("Default = 0x%x\n", IrpSp->MinorFunction));
; 97   : 
; 98   :             PoStartNextPowerIrp(Irp);

  0001e	53		 push	 ebx
  0001f	4a		 dec	 edx
  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PoStartNextPowerIrp@4

; 99   :             IoSkipCurrentIrpStackLocation(Irp);

  00026	fe 43 23	 inc	 BYTE PTR [ebx+35]
  00029	83 43 60 24	 add	 DWORD PTR [ebx+96], 36	; 00000024H

; 100  :             ntStatus = PoCallDriver(deviceExtension->StackDeviceObject, Irp);

  0002d	53		 push	 ebx
  0002e	ff 36		 push	 DWORD PTR [esi]
  00030	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PoCallDriver@8

; 101  : 
; 102  :             break; // default

  00036	eb 5f		 jmp	 SHORT $L8726
$L8724:

; 50   : 
; 51   :         case IRP_MN_SET_POWER:
; 52   :             
; 53   :             TRACE(TL_TRACE, ("IRP_MN_SET_POWER\n"));                        
; 54   : 
; 55   :             switch (IrpSp->Parameters.Power.Type) {

  00038	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  0003b	2b c8		 sub	 ecx, eax
  0003d	57		 push	 edi
  0003e	74 1d		 je	 SHORT $L8729
  00040	49		 dec	 ecx
  00041	75 53		 jne	 SHORT $L8846

; 68   :                     break;
; 69   :                 
; 70   :                 case DevicePowerState:
; 71   :                     TRACE(TL_TRACE, ("DevicePowerState\n"));
; 72   :                     TRACE(TL_TRACE, ("Current device state = 0x%x, new device state = 0x%x\n", 
; 73   :                                      deviceExtension->CurrentDevicePowerState, State.DeviceState));
; 74   : 
; 75   :                     PoStartNextPowerIrp(Irp);

  00043	53		 push	 ebx
  00044	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PoStartNextPowerIrp@4

; 76   :                     IoCopyCurrentIrpStackLocationToNext(Irp);

  0004a	8b 73 60	 mov	 esi, DWORD PTR [ebx+96]
  0004d	8d 46 dc	 lea	 eax, DWORD PTR [esi-36]
  00050	6a 07		 push	 7
  00052	59		 pop	 ecx
  00053	8b f8		 mov	 edi, eax
  00055	f3 a5		 rep movsd
  00057	c6 40 03 00	 mov	 BYTE PTR [eax+3], 0

; 77   :                     ntStatus = PoCallDriver(deviceExtension->StackDeviceObject, Irp);
; 78   :                     break; // DevicePowerState

  0005b	eb 2d		 jmp	 SHORT $L8847
$L8729:

; 56   : 
; 57   :                 case SystemPowerState:
; 58   :                     TRACE(TL_TRACE, ("SystemPowerState\n"));
; 59   :                     
; 60   :                     // Send the IRP down
; 61   :                     PoStartNextPowerIrp(Irp);

  0005d	53		 push	 ebx
  0005e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PoStartNextPowerIrp@4

; 62   :                     IoCopyCurrentIrpStackLocationToNext(Irp);

  00064	8b 73 60	 mov	 esi, DWORD PTR [ebx+96]
  00067	8d 46 dc	 lea	 eax, DWORD PTR [esi-36]
  0006a	6a 07		 push	 7
  0006c	8b f8		 mov	 edi, eax
  0006e	59		 pop	 ecx
  0006f	f3 a5		 rep movsd
  00071	c6 40 03 00	 mov	 BYTE PTR [eax+3], 0

; 63   :                     IoSetCompletionRoutine(Irp,
; 64   :                         (PIO_COMPLETION_ROUTINE) t1394VDev_SystemSetPowerIrpCompletion,
; 65   :                         NULL, TRUE, TRUE, TRUE);

  00075	8b 43 60	 mov	 eax, DWORD PTR [ebx+96]
  00078	83 e8 24	 sub	 eax, 36			; 00000024H
  0007b	83 60 20 00	 and	 DWORD PTR [eax+32], 0
  0007f	c7 40 1c 00 00
	00 00		 mov	 DWORD PTR [eax+28], OFFSET FLAT:_t1394VDev_SystemSetPowerIrpCompletion@12
  00086	c6 40 03 e0	 mov	 BYTE PTR [eax+3], 224	; 000000e0H
$L8847:

; 66   : 
; 67   :                     ntStatus = PoCallDriver(deviceExtension->StackDeviceObject, Irp);

  0008a	8b 45 08	 mov	 eax, DWORD PTR _deviceExtension$[ebp]
  0008d	53		 push	 ebx
  0008e	ff 30		 push	 DWORD PTR [eax]
  00090	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PoCallDriver@8
$L8846:
  00096	5f		 pop	 edi
$L8726:
  00097	5e		 pop	 esi
  00098	5b		 pop	 ebx

; 103  :             
; 104  :     } // switch
; 105  : 
; 106  :     EXIT("t1394VDev_Power", ntStatus);
; 107  :     return(ntStatus);
; 108  : } // t1394Vdev_Power

  00099	5d		 pop	 ebp
  0009a	c2 08 00	 ret	 8
_t1394VDev_Power@8 ENDP
_TEXT	ENDS
END

